{"id": "ca_001", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What is the primary purpose of the Claude Agent SDK?", "ground_truth": "The Claude Agent SDK is Anthropic's open-source framework for building autonomous AI agents in Python and TypeScript that can perform tasks independently using built-in and custom tools.", "source": "overview"}
{"id": "ca_002", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "Name three built-in tools available in the Claude Agent SDK.", "ground_truth": "Three built-in tools are: file operations (reading/writing files), code execution (running Python or other code), and web search (querying the internet for information).", "source": "built_in_tools"}
{"id": "ca_003", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What does the agent loop in Claude Agent SDK do?", "ground_truth": "The agent loop is the core execution mechanism that continuously processes Claude's responses, executes tools, and feeds results back to Claude until the agent completes its task.", "source": "agent_loop"}
{"id": "ca_004", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What is MCP in the context of Claude Agent SDK?", "ground_truth": "MCP (Model Context Protocol) is a standard that enables integration of custom tools and services into the Claude Agent SDK, allowing agents to extend their capabilities beyond built-in tools.", "source": "mcp_integration"}
{"id": "ca_005", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What are the two main approaches to subagent orchestration in Claude Agent SDK?", "ground_truth": "The two main approaches are filesystem-based orchestration (agents coordinate through shared file systems) and programmatic orchestration (direct control and communication between agents in code).", "source": "subagent_orchestration"}
{"id": "ca_006", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What does the session management feature allow agents to do?", "ground_truth": "Session management allows agents to resume previous sessions and fork sessions to create branches, enabling continuity and exploration of different execution paths.", "source": "session_management"}
{"id": "ca_007", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What are hooks used for in Claude Agent SDK?", "ground_truth": "Hooks are callbacks that trigger on tool events, allowing developers to monitor, log, or react to specific actions when tools are invoked during agent execution.", "source": "hooks"}
{"id": "ca_008", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What is the difference between ClaudeSDKClient and the query() API in Claude Agent SDK?", "ground_truth": "ClaudeSDKClient is a full-featured client for building agents with tools and orchestration, while the query() API is a simpler interface for direct Claude interactions without agent framework features.", "source": "client_comparison"}
{"id": "ca_009", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "How can developers create custom tools in Claude Agent SDK?", "ground_truth": "Developers can create custom tools by implementing them as in-process MCP servers that expose capabilities following the MCP protocol, which agents can then discover and use.", "source": "custom_tools"}
{"id": "ca_010", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What does prompt caching in Claude Agent SDK help optimize?", "ground_truth": "Prompt caching reduces latency and costs by caching frequently used prompts and context, allowing the agent to reuse cached results for similar requests.", "source": "prompt_caching"}
{"id": "ca_011", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What are permissions in the Claude Agent SDK used for?", "ground_truth": "Permissions provide fine-grained control over agent capabilities, allowing developers to restrict which tools an agent can access and what actions it can perform.", "source": "permissions"}
{"id": "ca_012", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What does streaming responses enable in Claude Agent SDK?", "ground_truth": "Streaming responses allow agents to receive and process Claude's output incrementally in real-time, rather than waiting for the entire response, improving responsiveness.", "source": "streaming"}
{"id": "ca_013", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What are agent skills in Claude Agent SDK?", "ground_truth": "Agent skills are pre-defined or custom capabilities that agents can use to accomplish tasks, typically implemented as tools accessible through the built-in or custom tool ecosystem.", "source": "agent_skills"}
{"id": "ca_014", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "Name three authentication methods supported by Claude Agent SDK.", "ground_truth": "Three authentication methods are: API key authentication (direct Anthropic API), Bedrock (AWS), and Vertex AI (Google Cloud).", "source": "authentication"}
{"id": "ca_015", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What is the purpose of slash commands in Claude Agent SDK?", "ground_truth": "Slash commands provide shorthand notation for agents to invoke specific actions or tools quickly, improving usability and reducing the complexity of agent interactions.", "source": "slash_commands"}
{"id": "ca_016", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What role do plugins play in Claude Agent SDK?", "ground_truth": "Plugins extend Claude Agent SDK functionality by providing pre-built integrations, tools, or behaviors that developers can activate to enhance agent capabilities without building from scratch.", "source": "plugins"}
{"id": "ca_017", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What does configuration in Claude Agent SDK determine?", "ground_truth": "Configuration allows developers to set sources and customize agent behavior, including which authentication method to use, default models, tool availability, and runtime parameters.", "source": "configuration"}
{"id": "ca_018", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "Is Azure AI Foundry a supported authentication method in Claude Agent SDK?", "ground_truth": "Yes, Azure AI Foundry is a supported authentication method, allowing agents deployed on Azure to authenticate securely using Azure credentials.", "source": "authentication"}
{"id": "ca_019", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "What is the built-in tool for code execution in Claude Agent SDK used for?", "ground_truth": "The code execution tool allows agents to run Python or other code programmatically, enabling dynamic computations, data processing, and automation within the agent workflow.", "source": "built_in_tools"}
{"id": "ca_020", "domain": "claude_agent_sdk", "difficulty": "easy", "question": "Can Claude Agent SDK be used with both Python and TypeScript?", "ground_truth": "Yes, Claude Agent SDK is available as an open-source framework supporting both Python and TypeScript, allowing developers to build agents in their preferred language.", "source": "overview"}
{"id": "ca_021", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "When would you choose to use ClaudeSDKClient directly instead of the query() API, and what are the trade-offs?", "ground_truth": "ClaudeSDKClient provides full control over the agent loop, tool execution, and session management, enabling complex workflows with subagents and custom hooks. The query() API is simpler but abstracts away loop control; use ClaudeSDKClient when you need fine-grained control over agent behavior, session resumption, or orchestration of multiple agents.", "source": "ClaudeSDKClient vs query() API"}
{"id": "ca_022", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "Explain how MCP integration in the Claude Agent SDK differs from using built-in tools like file operations and code execution.", "ground_truth": "Built-in tools are pre-integrated and require no configuration; MCP integration allows custom tools to be plugged in as in-process or external servers, providing extensibility beyond the standard toolkit. MCP tools follow the Model Context Protocol standard, enabling reusable tool specifications and custom business logic.", "source": "MCP integration for custom tools"}
{"id": "ca_023", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "What is the purpose of hooks for tool events in the Claude Agent SDK, and how might they be used in a production system?", "ground_truth": "Hooks allow you to intercept and react to tool execution events (before/after calls, errors). In production, they enable logging, monitoring, audit trails, cost tracking, and dynamic permission enforcement based on runtime context.", "source": "hooks for tool events"}
{"id": "ca_024", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "Compare filesystem-based versus programmatic subagent orchestration. When would you use each approach?", "ground_truth": "Filesystem-based orchestration uses file system conventions to discover and manage subagents, simpler for static hierarchies. Programmatic orchestration provides dynamic control over agent instantiation and communication, preferred when subagent selection or behavior depends on runtime state or user input.", "source": "subagent orchestration"}
{"id": "ca_025", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "What is session forking in the Claude Agent SDK, and how does it differ from resuming a session?", "ground_truth": "Session resuming continues an existing conversation from where it left off, maintaining the full context and history. Session forking creates a branch from a previous point, allowing you to explore alternative agent paths without losing the original session state.", "source": "session management (resume, fork)"}
{"id": "ca_026", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "How does prompt caching improve agent efficiency, and what are the considerations for implementing it in a multi-turn agent loop?", "ground_truth": "Prompt caching stores frequently-accessed context (like system prompts or tool definitions) to reduce token processing costs on subsequent requests. In a multi-turn loop, cache invalidation must be managed carefully when agent capabilities or context changes between turns.", "source": "prompt caching"}
{"id": "ca_027", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "Describe how fine-grained permissions work in the Claude Agent SDK and why they are important for agent safety.", "ground_truth": "Fine-grained permissions allow you to restrict specific agent capabilities (e.g., read-only file access, limited web search scope). They are critical for safety in untrusted or multi-tenant environments, preventing agents from performing unintended or harmful operations.", "source": "permissions (fine-grained agent capabilities)"}
{"id": "ca_028", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "What is the agent loop in the Claude Agent SDK, and how do hooks fit into its execution model?", "ground_truth": "The agent loop is the core cycle of: receive input \u2192 generate plan \u2192 execute tools \u2192 process output \u2192 loop. Hooks inject custom logic at key points (before tool execution, after response generation), enabling monitoring, intervention, and customization without modifying core loop logic.", "source": "agent loop"}
{"id": "ca_029", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "How can you implement custom tools as in-process MCP servers, and what are the advantages over external MCP servers?", "ground_truth": "In-process MCP servers are custom tool implementations that run in the same process as the agent, sharing memory and state directly. Advantages include lower latency, simplified deployment, and direct access to agent context; disadvantages are reduced isolation and scaling limitations.", "source": "custom tools as in-process MCP servers"}
{"id": "ca_030", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "What are the key differences between streaming responses and standard response handling in the Claude Agent SDK?", "ground_truth": "Streaming responses return results incrementally, enabling real-time feedback and lower perceived latency; standard responses return complete results at once. Streaming requires different handling logic and is useful for long-running operations or user-facing interfaces.", "source": "streaming responses"}
{"id": "ca_031", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "Explain how configuration sources in the Claude Agent SDK work and why layering configurations is important.", "ground_truth": "Configuration sources (environment variables, config files, runtime parameters) can be layered with precedence rules, allowing flexibility across environments (dev, staging, prod). Layering enables secure secrets management, environment-specific behavior, and easy deployment without code changes.", "source": "configuration (setting sources)"}
{"id": "ca_032", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "How do agent skills differ from tools in the Claude Agent SDK, and how do you compose them?", "ground_truth": "Agent skills are higher-level abstractions that combine multiple tools and logic to achieve specific goals, while tools are individual capabilities. Skills are composed by packaging tool combinations with decision logic, enabling agents to handle complex multi-step tasks more naturally.", "source": "agent skills"}
{"id": "ca_033", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "What is the role of slash commands in the Claude Agent SDK, and how do they enhance user interaction?", "ground_truth": "Slash commands provide a structured interface for users to invoke specific agent actions or skills (e.g., /search, /analyze). They improve usability by making available actions explicit and discoverable, and they can be validated and routed to appropriate handlers.", "source": "slash commands"}
{"id": "ca_034", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "How does the plugin system in the Claude Agent SDK enable extensibility, and what is a typical plugin architecture?", "ground_truth": "Plugins extend SDK functionality by providing hooks, custom tools, or middleware that integrate seamlessly into the agent lifecycle. Typical architecture includes plugin registration, hook definitions, and initialization that allows third-party developers to add capabilities without modifying core code.", "source": "plugins"}
{"id": "ca_035", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "Compare API key authentication with Bedrock, Vertex, and Azure AI Foundry authentication in the Claude Agent SDK. When would you choose each?", "ground_truth": "API key auth is simplest for direct Anthropic API access; Bedrock is for AWS environments with IAM integration; Vertex for Google Cloud users; Azure AI Foundry for Azure deployments. Choose based on your cloud provider, infrastructure, and security requirements.", "source": "authentication (API key, Bedrock, Vertex, Azure AI Foundry)"}
{"id": "ca_036", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "What challenges arise when orchestrating multiple subagents, and how does the SDK help manage them?", "ground_truth": "Challenges include coordinating tool execution across agents, managing shared state, handling failures, and controlling costs. The SDK provides session management, hook integration, and programmatic orchestration to address these concerns.", "source": "subagent orchestration (filesystem-based, programmatic, built-in)"}
{"id": "ca_037", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "How would you design a permission model for an agent that prevents unauthorized file deletions while allowing necessary read operations?", "ground_truth": "Define fine-grained permissions specifying file operation types (read, write, delete) and directory scopes, restricting delete operations to specific safe directories or disabling them entirely. Enforce permissions via hooks that validate requests before tool execution.", "source": "permissions (fine-grained agent capabilities)"}
{"id": "ca_038", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "Explain how web search as a built-in tool differs from code execution, and what safety considerations apply to each.", "ground_truth": "Web search queries external information sources with network access; code execution runs Python/JavaScript in a sandboxed environment. Web search safety concerns include rate limiting and information reliability; code execution requires sandboxing to prevent resource exhaustion and malicious operations.", "source": "built-in tools (file operations, code execution, web search)"}
{"id": "ca_039", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "In what scenarios would you implement custom logging via hooks rather than relying on built-in logging, and what data would you capture?", "ground_truth": "Implement custom hooks logging for detailed audit trails, cost tracking per tool, user behavior analysis, or integration with external logging systems. Capture tool names, inputs, outputs, execution time, errors, and user context to enable monitoring and compliance.", "source": "hooks for tool events"}
{"id": "ca_040", "domain": "claude_agent_sdk", "difficulty": "medium", "question": "How does MCP integration enable code reusability across different agent projects, and what standards does it follow?", "ground_truth": "MCP (Model Context Protocol) provides a standardized interface for tools, allowing the same tool specification to be used across multiple projects and agent systems. This promotes code reuse, standardization, and ecosystem interoperability.", "source": "MCP integration for custom tools"}
{"id": "ca_041", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "When implementing a custom tool as an in-process MCP server within the Claude Agent SDK, what are the critical considerations for preventing resource exhaustion and ensuring the agent loop remains responsive during long-running tool executions?", "ground_truth": "In-process MCP servers must implement proper async/await patterns and timeouts to prevent blocking the agent loop. Critical considerations include: setting execution timeouts on tool calls, implementing resource limits (memory, CPU) within the tool handler, using non-blocking I/O operations, and potentially spawning heavy computations in separate worker threads/processes while maintaining thread-safe communication with the agent loop.", "source": "custom_tools_mcp_servers"}
{"id": "ca_042", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "Explain the security implications of using filesystem-based subagent orchestration versus programmatic orchestration in the Claude Agent SDK, particularly regarding capability isolation and permission boundaries.", "ground_truth": "Filesystem-based orchestration relies on the filesystem's permission model for isolation, which may be insufficient for security-critical applications. Programmatic orchestration allows fine-grained per-subagent permission configuration through the permissions system, enabling explicit capability whitelisting. Programmatic orchestration is more secure because it enforces permissions at the SDK level rather than relying on OS-level file access controls, reducing the attack surface for privilege escalation.", "source": "subagent_orchestration_permissions"}
{"id": "ca_043", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "When using session management with fork() to create divergent agent execution branches, what are the potential consistency issues if the forked sessions attempt to modify shared external state (e.g., files, databases), and how should applications mitigate this?", "ground_truth": "Session fork() creates independent execution contexts but does not isolate external state modifications. Concurrent writes from forked sessions can cause data corruption or inconsistency. Mitigation strategies include: implementing optimistic locking/version control for shared resources, using transactional semantics for database operations, establishing a parent session as the source of truth for state merges, or using file-level locks and conflict resolution strategies before resuming the parent session.", "source": "session_management_fork"}
{"id": "ca_044", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "Describe the performance trade-offs between using prompt caching with the Claude Agent SDK versus implementing a custom vector database for tool result caching in multi-turn agent interactions.", "ground_truth": "Prompt caching caches token-level representations of repeated prompts/context, reducing input token costs but adding latency for cache lookup and hit validation. Custom vector database caching stores semantic representations of tool results, enabling fuzzy matching and reuse across semantically similar requests but requires embedding overhead and vector search latency. Prompt caching is superior for identical repeated contexts; vector caching excels when tool results are reusable across semantically similar but syntactically different queries. Hybrid approaches may optimize both latency and cost.", "source": "prompt_caching_performance"}
{"id": "ca_045", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "In the Claude Agent SDK, what are the functional and architectural differences between ClaudeSDKClient and the query() API, and when should you choose one over the other in a production multi-agent system?", "ground_truth": "ClaudeSDKClient provides full agent orchestration, session management, subagent support, hooks, and streaming within a unified framework. The query() API is a stateless interface for single-turn interactions without agent loop overhead. Use ClaudeSDKClient for stateful, multi-turn autonomous agents with complex tool coordination; use query() API for simple LLM queries, embedding in legacy systems, or when agent overhead is unnecessary. ClaudeSDKClient is preferred for production multi-agent systems requiring resumability and rich tool orchestration.", "source": "claude_sdk_client_vs_query_api"}
{"id": "ca_046", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "When configuring authentication across multiple cloud providers (API key, Bedrock, Vertex, Azure AI Foundry) in a single Claude Agent SDK application, what are the security best practices for credential rotation, and how does the SDK's configuration system support this?", "ground_truth": "Use environment variables or secure credential managers (AWS Secrets Manager, Azure Key Vault, Google Cloud Secret Manager) rather than hardcoding credentials. The SDK's configuration sources (environment, config files) should support dynamic reloading without restarting the agent. Implement credential rotation strategies: periodically refresh tokens, monitor credential expiration, and use temporary credentials (STS tokens) where available. The SDK's configuration layer should abstract provider-specific authentication, allowing seamless switching between providers without agent restart.", "source": "authentication_multi_cloud"}
{"id": "ca_047", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "Explain how hooks for tool events in the Claude Agent SDK can be leveraged to implement observability and cost tracking across a distributed multi-agent system, including edge cases where tool execution fails or times out.", "ground_truth": "Tool event hooks (pre-execution, post-execution, error) emit structured event data including tool name, input, output, latency, and token usage. Implement hooks that log events to centralized observability platforms (Datadog, New Relic, Prometheus) and accumulate cost metrics per agent/tool/user. Handle edge cases: capture timeout events and partial failures, correlate events across subagents using trace IDs, and aggregate costs even for failed tool calls. Use async hook handlers to avoid blocking the agent loop while sending metrics.", "source": "hooks_observability_cost"}
{"id": "ca_048", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "In a scenario where multiple agents need to coordinate through MCP integration with shared custom tools, what are the synchronization challenges, and how should you design the custom MCP server to handle concurrent tool invocations from different agent instances?", "ground_truth": "Shared MCP servers must handle concurrent requests from multiple agent instances, risking race conditions on shared state (e.g., file modifications, database transactions). Design patterns: use request queuing with IDs to serialize critical operations, implement atomic operations with rollback support, apply distributed locking (Redis, Consul), or adopt event-sourcing for state management. Each tool invocation should include context (agent ID, session ID) for auditing and conflict resolution. Use connection pooling and async handlers to prevent deadlocks.", "source": "mcp_integration_concurrency"}
{"id": "ca_049", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "Describe the relationship between agent skills, slash commands, and plugins in the Claude Agent SDK, and explain how permission boundaries differ across these three extension mechanisms.", "ground_truth": "Agent skills are declarative capability sets that define what an agent can do; slash commands are user-invoked shortcuts that trigger specific agent behaviors; plugins extend functionality through hooks and custom handlers. Skills are evaluated at the agent initialization level with coarse-grained permissions. Slash commands operate at runtime and inherit agent permissions but can have additional user-level authorization checks. Plugins operate at the SDK infrastructure level and require explicit capability grants independent of agent skills. Permission scope: skills (agent-level), slash commands (user + agent level), plugins (SDK-level).", "source": "skills_slash_commands_plugins"}
{"id": "ca_050", "domain": "claude_agent_sdk", "difficulty": "hard", "question": "When streaming responses from a Claude Agent SDK agent that uses subagents and MCP-based custom tools, what are the challenges in maintaining consistent streaming semantics across nested agent boundaries, and how should you structure your streaming handlers?", "ground_truth": "Streaming across nested agents requires proper context propagation of stream state, token deltas, and tool execution events through subagent boundaries. Challenges: subagent responses must be buffered or re-streamed from the parent, tool invocations in subagents may complete asynchronously relative to parent streaming, and token accounting becomes complex. Solution: implement a streaming aggregator at the parent level that collects subagent stream events and re-emits them with proper sequencing. Use structured event types (token_delta, tool_call, tool_result) with source attribution. Ensure the streaming handler is async-safe and handles backpressure from slow consumers.", "source": "streaming_nested_agents"}
