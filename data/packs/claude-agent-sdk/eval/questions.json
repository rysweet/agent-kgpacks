[
  {
    "id": "ca_001",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What is the Claude Agent SDK?",
    "ground_truth": "The Claude Agent SDK is Anthropic's open-source framework for building autonomous AI agents in Python and TypeScript. It provides tools and abstractions for creating agents that can loop, call tools, and interact with external systems.",
    "source": "agent_sdk_overview"
  },
  {
    "id": "ca_002",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "Name three built-in tools provided by the Claude Agent SDK.",
    "ground_truth": "The Claude Agent SDK includes built-in tools for file operations, code execution, and web search. These tools enable agents to interact with the filesystem, run Python code, and search the internet without additional setup.",
    "source": "built_in_tools"
  },
  {
    "id": "ca_003",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What does MCP stand for in the context of the Claude Agent SDK?",
    "ground_truth": "MCP stands for Model Context Protocol. It is a standard used to integrate custom tools with the Claude Agent SDK, allowing agents to access external tools and data sources.",
    "source": "mcp_integration"
  },
  {
    "id": "ca_004",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What is the agent loop in the Claude Agent SDK?",
    "ground_truth": "The agent loop is the core execution mechanism where the agent repeatedly receives tasks, calls tools as needed, and processes results until the task is complete or a stopping condition is met.",
    "source": "agent_loop"
  },
  {
    "id": "ca_005",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What is a subagent in the Claude Agent SDK?",
    "ground_truth": "A subagent is a separate agent instance that can be orchestrated by a parent agent to handle specific tasks or domains. Subagents can be created and managed filesystem-based, programmatically, or using built-in orchestration.",
    "source": "subagent_orchestration"
  },
  {
    "id": "ca_006",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "Name the three methods for organizing subagents in the Claude Agent SDK.",
    "ground_truth": "The three methods for subagent orchestration are: filesystem-based (directory structure), programmatic (code-based creation), and built-in (using SDK abstractions for automatic management).",
    "source": "subagent_orchestration"
  },
  {
    "id": "ca_007",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What is session management in the Claude Agent SDK?",
    "ground_truth": "Session management allows agents to maintain state across interactions. Key capabilities include resuming previous sessions to continue work and forking sessions to create independent branches from a checkpoint.",
    "source": "session_management"
  },
  {
    "id": "ca_008",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What are hooks in the Claude Agent SDK?",
    "ground_truth": "Hooks are callback mechanisms that intercept and control agent behavior by triggering custom logic in response to tool events. They allow developers to monitor, modify, or prevent tool execution.",
    "source": "hooks"
  },
  {
    "id": "ca_009",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What is the purpose of fine-grained permissions in the Claude Agent SDK?",
    "ground_truth": "Fine-grained permissions control which capabilities an agent has access to. They restrict an agent's ability to perform specific actions, such as file operations or code execution, enhancing security and control.",
    "source": "permissions"
  },
  {
    "id": "ca_010",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What is the difference between ClaudeSDKClient and the query() API?",
    "ground_truth": "ClaudeSDKClient is the full-featured SDK client that provides agent capabilities including tool use, sessions, and hooks. The query() API is a simpler interface for single API calls without agent orchestration features.",
    "source": "client_comparison"
  },
  {
    "id": "ca_011",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What are custom tools in the Claude Agent SDK?",
    "ground_truth": "Custom tools are user-defined extensions that allow agents to interact with specific services or systems. They can be implemented as in-process MCP servers and integrated via the SDK's tool registration mechanism.",
    "source": "custom_tools"
  },
  {
    "id": "ca_012",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "Does the Claude Agent SDK support streaming responses?",
    "ground_truth": "Yes, the Claude Agent SDK supports streaming responses, enabling real-time delivery of agent outputs rather than waiting for complete results. This improves user experience for long-running operations.",
    "source": "streaming_responses"
  },
  {
    "id": "ca_013",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What is prompt caching in the Claude Agent SDK?",
    "ground_truth": "Prompt caching is a feature that caches frequently used prompts or context to reduce latency and costs. The SDK can leverage cached prompts for repeated agent interactions with similar inputs.",
    "source": "prompt_caching"
  },
  {
    "id": "ca_014",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "How can you configure the Claude Agent SDK?",
    "ground_truth": "Configuration in the Claude Agent SDK can be set through multiple sources, typically including environment variables, configuration files, and programmatic settings. The SDK prioritizes settings based on a defined precedence order.",
    "source": "configuration"
  },
  {
    "id": "ca_015",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What are agent skills in the Claude Agent SDK?",
    "ground_truth": "Agent skills are predefined capabilities or modules that agents can use to accomplish specific tasks. They encapsulate functionality and can be dynamically loaded or composed into agents.",
    "source": "agent_skills"
  },
  {
    "id": "ca_016",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What are slash commands in the Claude Agent SDK context?",
    "ground_truth": "Slash commands are special user inputs (e.g., /help, /reset) that trigger specific agent actions or workflows. They provide a simple interface for users to interact with agent functionality.",
    "source": "slash_commands"
  },
  {
    "id": "ca_017",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "How does authentication work in the Claude Agent SDK?",
    "ground_truth": "The Claude Agent SDK supports multiple authentication methods: API keys for direct Anthropic access, AWS Bedrock, Google Vertex AI, and Azure AI Foundry. Authentication is typically configured via environment variables or SDK initialization.",
    "source": "authentication"
  },
  {
    "id": "ca_018",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What programming languages does the Claude Agent SDK support?",
    "ground_truth": "The Claude Agent SDK supports Python and TypeScript, providing language-specific implementations and SDKs for building agents in either ecosystem.",
    "source": "language_support"
  },
  {
    "id": "ca_019",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "What is a plugin in the Claude Agent SDK?",
    "ground_truth": "Plugins are modular extensions that add functionality to the Claude Agent SDK. They can provide new tools, skills, authentication methods, or other capabilities that extend the agent framework.",
    "source": "plugins"
  },
  {
    "id": "ca_020",
    "domain": "claude_agent_sdk",
    "difficulty": "easy",
    "question": "Can custom tools in the Claude Agent SDK run as in-process MCP servers?",
    "ground_truth": "Yes, custom tools can be implemented as in-process MCP servers, allowing them to run within the same process as the agent without requiring separate deployment or network communication.",
    "source": "custom_tools_mcp"
  },
  {
    "id": "ca_021",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "What is the primary difference between using ClaudeSDKClient and the query() API when building agents with the Claude Agent SDK?",
    "ground_truth": "ClaudeSDKClient provides full agent loop control with built-in tools and subagent orchestration capabilities, while query() API is a simpler interface for direct Claude interactions without agent infrastructure. ClaudeSDKClient enables autonomous agent behavior with tool use and session management.",
    "source": "ClaudeSDKClient_vs_query_API"
  },
  {
    "id": "ca_022",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "How does the agent loop in Claude Agent SDK determine when to stop executing and return results to the user?",
    "ground_truth": "The agent loop continues until Claude chooses to stop using tools (indicating completion), an error occurs, or a maximum iteration limit is reached. The loop terminates when the model decides it has sufficient information to provide a final response without further tool invocation.",
    "source": "agent_loop"
  },
  {
    "id": "ca_023",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "What are the three primary approaches for orchestrating subagents in the Claude Agent SDK?",
    "ground_truth": "The three approaches are: filesystem-based (agents defined in directory structure), programmatic (agents created and configured in code), and built-in (agents provided as part of the SDK). Each approach offers different levels of flexibility and integration capabilities.",
    "source": "subagent_orchestration"
  },
  {
    "id": "ca_024",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "When implementing custom tools as in-process MCP servers, what is a key consideration for performance compared to external MCP servers?",
    "ground_truth": "In-process MCP servers eliminate network latency and serialization overhead, providing faster tool execution than external servers. However, they run in the same process as the agent, requiring careful resource management to avoid blocking the agent loop.",
    "source": "custom_tools_MCP"
  },
  {
    "id": "ca_025",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "How does session management in the Claude Agent SDK allow developers to implement conversational continuity across multiple user interactions?",
    "ground_truth": "Sessions store agent state and conversation history, allowing agents to resume from previous states using unique session IDs or fork sessions to create parallel conversation branches. This enables long-running conversations while maintaining context and tool state.",
    "source": "session_management"
  },
  {
    "id": "ca_026",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "What specific hook events are available for intercepting tool execution in the Claude Agent SDK, and when would you use them?",
    "ground_truth": "Hook events include before/after tool invocation, tool result processing, and error handling. These hooks enable logging, validation, tool result transformation, and permission enforcement before tools execute or after they complete.",
    "source": "hooks_tool_events"
  },
  {
    "id": "ca_027",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "How do fine-grained permissions in the Claude Agent SDK control agent capabilities, and what is a real-world scenario where this matters?",
    "ground_truth": "Fine-grained permissions specify which tools an agent can access and what actions those tools can perform (e.g., read-only vs. write access to files). This is critical in multi-tenant systems or when agents operate with elevated privileges but should have limited scope.",
    "source": "permissions_fine_grained"
  },
  {
    "id": "ca_028",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "What is the relationship between MCP integration and the built-in tools in the Claude Agent SDK?",
    "ground_truth": "Built-in tools (file operations, code execution, web search) are provided natively by the SDK, while MCP integration allows connecting external tools and services as additional MCP servers. MCP servers extend the agent's capabilities beyond built-in tools.",
    "source": "MCP_integration"
  },
  {
    "id": "ca_029",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "How does prompt caching improve agent performance in the Claude Agent SDK, particularly for long-running agents?",
    "ground_truth": "Prompt caching stores frequently used system prompts and context in the API, reducing token consumption and latency for subsequent requests. Long-running agents benefit by caching agent instructions and tool definitions across multiple iterations.",
    "source": "prompt_caching"
  },
  {
    "id": "ca_030",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "What are the authentication options available in the Claude Agent SDK, and when would you choose Bedrock or Vertex AI over direct Anthropic API?",
    "ground_truth": "Authentication options include Anthropic API key (direct), AWS Bedrock, Google Vertex AI, and Azure AI Foundry. Choose Bedrock/Vertex when you have existing AWS/GCP infrastructure, need regional deployment, or require enterprise integrations with those platforms.",
    "source": "authentication_options"
  },
  {
    "id": "ca_031",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "How do agent skills differ from traditional tool definitions in the Claude Agent SDK?",
    "ground_truth": "Agent skills are high-level capabilities that agents can execute, often composed of multiple tools and workflows, while tools are individual functions the agent can call. Skills provide abstraction for complex operations and can bundle related tools with shared context.",
    "source": "agent_skills"
  },
  {
    "id": "ca_032",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "What configuration sources does the Claude Agent SDK support, and how do they interact when multiple sources provide overlapping settings?",
    "ground_truth": "Configuration sources include environment variables, configuration files, and programmatic settings. When overlapping settings exist, precedence typically follows: programmatic settings > configuration files > environment variables, allowing flexible override patterns.",
    "source": "configuration_sources"
  },
  {
    "id": "ca_033",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "How does streaming responses work in the Claude Agent SDK, and what are the trade-offs compared to waiting for complete agent execution?",
    "ground_truth": "Streaming responses allow returning partial results and tool execution progress in real-time rather than waiting for full completion. Trade-off: improved UX and lower time-to-first-token vs. inability to modify agent behavior mid-stream once tokens are sent.",
    "source": "streaming_responses"
  },
  {
    "id": "ca_034",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "What is the purpose of slash commands in the Claude Agent SDK, and how do they relate to agent functionality?",
    "ground_truth": "Slash commands provide a command-like interface for users to trigger specific agent actions or workflows (e.g., /analyze, /summarize). They act as shortcuts to agent skills or predefined tool sequences, simplifying agent interaction patterns.",
    "source": "slash_commands"
  },
  {
    "id": "ca_035",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "How do plugins extend the Claude Agent SDK, and what distinguishes them from custom tools or MCP servers?",
    "ground_truth": "Plugins provide packaged integrations that modify or extend agent behavior at a higher level than individual tools. Unlike custom tools (single functions) or MCP servers (tool collections), plugins can inject capabilities throughout the agent lifecycle.",
    "source": "plugins"
  },
  {
    "id": "ca_036",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "What considerations should you make when deciding between a filesystem-based or programmatic subagent orchestration approach?",
    "ground_truth": "Filesystem-based is better for simple, static agent definitions and configuration-as-code patterns; programmatic is better for dynamic agent creation, conditional logic, and runtime flexibility. Choose based on whether your agent topology is known at startup or changes during execution.",
    "source": "subagent_orchestration_design"
  },
  {
    "id": "ca_037",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "How does the code execution tool in the Claude Agent SDK handle security, and what limitations exist?",
    "ground_truth": "The code execution tool runs code in a sandboxed environment with resource limits and restricted system access. Limitations include no unlimited execution time, restricted file system access outside designated directories, and no arbitrary system command execution.",
    "source": "code_execution_tool"
  },
  {
    "id": "ca_038",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "When forking a session in the Claude Agent SDK, what state is preserved and what is reset?",
    "ground_truth": "Forking preserves the conversation history and context up to the fork point, creating an independent branch. The forked session has its own state going forward, allowing parallel exploration while maintaining shared history before the fork.",
    "source": "session_fork"
  },
  {
    "id": "ca_039",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "How does the web search tool in the Claude Agent SDK integrate with the agent loop, and what are its latency implications?",
    "ground_truth": "The web search tool allows agents to retrieve current information during execution, adding network latency to each search operation. Agents should use it judiciously when real-time information is needed, as multiple searches can extend total execution time significantly.",
    "source": "web_search_tool"
  },
  {
    "id": "ca_040",
    "domain": "claude_agent_sdk",
    "difficulty": "medium",
    "question": "What is the recommended approach for handling agent errors and retries in the Claude Agent SDK's agent loop?",
    "ground_truth": "Use hooks to intercept errors, implement exponential backoff for transient failures, and configure maximum retry limits per tool. Provide error context to the agent through tool results so it can adapt its strategy rather than simply retrying the same approach.",
    "source": "error_handling_agent_loop"
  },
  {
    "id": "ca_041",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "When implementing custom tools as in-process MCP servers within the Claude Agent SDK, what are the performance and isolation trade-offs compared to spawning separate MCP server processes, and how does this choice impact agent loop efficiency?",
    "ground_truth": "In-process MCP servers reduce latency and avoid inter-process communication overhead, improving agent loop responsiveness, but sacrifice isolation and fault tolerance\u2014a crashed tool can crash the agent. Separate processes provide isolation and stability but introduce serialization overhead and increased complexity in the agent loop.",
    "source": "custom_tools_mcp_servers"
  },
  {
    "id": "ca_042",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "Explain the architectural differences between filesystem-based subagent orchestration and programmatic subagent orchestration in the Claude Agent SDK. When would you choose one over the other for a production system?",
    "ground_truth": "Filesystem-based orchestration persists agent configurations on disk, enabling stateless scaling and easier version control, but has slower discovery and higher latency. Programmatic orchestration keeps subagents in memory for faster invocation but requires careful state management and is less suitable for distributed systems. Choose filesystem for scalable multi-tenant systems; choose programmatic for low-latency, tightly-coupled workflows.",
    "source": "subagent_orchestration"
  },
  {
    "id": "ca_043",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "How do hooks for tool events in the Claude Agent SDK enable fine-grained control over agent behavior, and what security risks could arise from improper hook implementation in a multi-tenant environment?",
    "ground_truth": "Hooks intercept tool execution before and after invocation, allowing validation, logging, and mutation of inputs/outputs. In multi-tenant scenarios, poorly implemented hooks could leak user data between tenants, fail to enforce permission boundaries, or allow malicious modification of tool results. Hooks must isolate tenant context and validate all mutations against the agent's permission model.",
    "source": "hooks_tool_events"
  },
  {
    "id": "ca_044",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "What are the implications of using prompt caching in conjunction with session management (resume and fork operations) in the Claude Agent SDK? How might cache invalidation affect agent state consistency?",
    "ground_truth": "Prompt caching reduces latency and cost for repeated context, but when resuming or forking sessions, cached tokens may become stale if the agent's knowledge base or system prompt has been updated. Cache invalidation must be coordinated with session state to prevent the agent from using outdated cached context, requiring explicit cache busting or versioning strategies.",
    "source": "prompt_caching_sessions"
  },
  {
    "id": "ca_045",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "In the Claude Agent SDK, how does the permission model enforce fine-grained agent capabilities, and what attack vectors exist if permissions are not properly validated at both the ClaudeSDKClient and individual tool levels?",
    "ground_truth": "Permissions restrict which tools an agent can invoke and what actions those tools can perform. Vulnerabilities arise if ClaudeSDKClient doesn't enforce permissions before tool invocation, if hooks bypass permission checks, or if tools accept overly broad parameters. An attacker could craft prompts exploiting permission gaps (e.g., requesting file operations outside allowed directories) or use escalation through tool chaining.",
    "source": "permissions_fine_grained"
  },
  {
    "id": "ca_046",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "Compare the ClaudeSDKClient approach versus the query() API for agent construction. What are the architectural trade-offs regarding extensibility, state management, and backward compatibility?",
    "ground_truth": "ClaudeSDKClient provides a stateful, extensible object-oriented interface supporting full agent lifecycle (loops, hooks, sessions), making it suitable for complex agentic workflows. The query() API is a simpler, stateless wrapper for one-off requests, offering ease-of-use but limiting customization and session management. ClaudeSDKClient requires more boilerplate but ensures better backward compatibility as the SDK evolves.",
    "source": "claudesdkclient_vs_query"
  },
  {
    "id": "ca_047",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "How does MCP integration in the Claude Agent SDK handle tool schema validation and type safety across Python and TypeScript implementations? What happens when an external MCP server exposes tools with ambiguous or conflicting schemas?",
    "ground_truth": "MCP servers expose tools via JSON schemas, which the SDK parses and validates for type compatibility. Type safety varies: TypeScript provides compile-time checking via generated types, while Python relies on runtime validation. Conflicting schemas (duplicate tool names, incompatible parameter types) cause runtime errors or silent failures; the SDK typically fails safely by rejecting ambiguous tools or raising a validation exception.",
    "source": "mcp_integration"
  },
  {
    "id": "ca_048",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "What are the performance implications of streaming responses in the Claude Agent SDK's agent loop, and how does streaming interact with prompt caching and tool invocation latency?",
    "ground_truth": "Streaming enables real-time token delivery and lower time-to-first-token (TTFT), improving perceived responsiveness. However, it complicates tool invocation logic\u2014the agent must buffer streamed tokens to determine when a tool call is complete. Prompt caching benefits streaming by reducing input processing time, but cache hits don't eliminate token generation latency. Streaming adds complexity to session management if resuming mid-stream.",
    "source": "streaming_responses"
  },
  {
    "id": "ca_049",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "Describe the configuration sources and precedence order in the Claude Agent SDK. How would you troubleshoot a scenario where authentication fails unexpectedly due to conflicting configuration sources (environment variables, configuration files, programmatic settings)?",
    "ground_truth": "Configuration precedence typically follows: programmatic settings > environment variables > configuration files > defaults. Authentication failures from conflicting sources occur when an agent reads credentials from the wrong precedence level. Troubleshooting involves: (1) verify API key in each source, (2) check which source is active via SDK debug logs, (3) explicitly set credentials programmatically to override lower-precedence sources, (4) ensure Bedrock/Vertex/Azure credentials match the selected backend.",
    "source": "configuration_sources"
  },
  {
    "id": "ca_050",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "How do agent skills and plugins extend the base Claude Agent SDK, and what are the risks of third-party plugin integration in terms of security, performance, and state corruption?",
    "ground_truth": "Skills and plugins register custom tools and behaviors, extending the agent without modifying core SDK code. Security risks include: plugins gaining unintended access to agent memory/sessions, injecting malicious prompts, or bypassing permission models. Performance risks: poorly optimized plugins blocking the agent loop or consuming excessive resources. State corruption occurs if plugins mutate session state without proper synchronization or transaction management. Mitigations: sandbox plugins, validate plugin schemas, implement version pinning, and audit third-party code.",
    "source": "agent_skills_plugins"
  },
  {
    "id": "ca_051",
    "domain": "claude_agent_sdk",
    "difficulty": "hard",
    "question": "In a multi-cloud deployment using Claude Agent SDK with Anthropic API, AWS Bedrock, Google Vertex AI, and Azure AI Foundry, what are the authentication and credential management complexities, and how would you implement a credential rotation strategy without disrupting active agent sessions?",
    "ground_truth": "Multi-cloud authentication requires managing API keys, IAM roles, and service principals across providers with different expiration policies. Credential rotation risks agent failures if keys expire mid-session. Solutions: (1) use a secrets management system (e.g., HashiCorp Vault) to centralize rotation, (2) implement credential refresh hooks in ClaudeSDKClient to swap credentials without restarting sessions, (3) maintain credential caches with TTL-based invalidation, (4) test rotation against running agents before production rollout.",
    "source": "authentication_multicloud"
  }
]
