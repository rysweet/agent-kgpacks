[
  {
    "id": "ga_001",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What is the trigger keyword used to make a workflow reusable by other workflows?",
    "ground_truth": "The `workflow_call` trigger enables a workflow to be called from another workflow. It must be defined in the `on:` section of the workflow file to allow other workflows to reference it as a reusable workflow.",
    "source": "reusable_workflows"
  },
  {
    "id": "ga_002",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What file defines the metadata and inputs for a composite action?",
    "ground_truth": "The `action.yml` file (or `action.yaml`) defines the metadata, inputs, outputs, description, and runs configuration for a composite action. It must be located in the root directory of the action.",
    "source": "composite_actions"
  },
  {
    "id": "ga_003",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "Which permission must be granted to enable OIDC token generation in GitHub Actions?",
    "ground_truth": "The `id-token: write` permission must be granted in the job to allow GitHub Actions to request and generate OIDC ID tokens for cloud provider federation.",
    "source": "oidc_authentication"
  },
  {
    "id": "ga_004",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What is the maximum nesting level allowed for reusable workflows?",
    "ground_truth": "Reusable workflows can be nested up to 10 levels deep. A workflow can call another reusable workflow, which can call another, and so on, with a maximum depth of 10 levels.",
    "source": "reusable_workflows"
  },
  {
    "id": "ga_005",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "How do you pass secrets to a called reusable workflow?",
    "ground_truth": "Secrets are inherited automatically by reusable workflows and do not need to be explicitly passed. The called workflow can access secrets through the `secrets` context without explicit mapping.",
    "source": "reusable_workflows"
  },
  {
    "id": "ga_006",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What does the `fail-fast` strategy option do in a matrix job?",
    "ground_truth": "The `fail-fast` option cancels all in-progress jobs if any matrix job fails when set to `true`. When set to `false`, other jobs continue running even if one fails.",
    "source": "matrix_strategies"
  },
  {
    "id": "ga_007",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "Which GitHub Actions action is used to cache dependencies and build artifacts?",
    "ground_truth": "The `actions/cache` action is used to cache files and directories to improve workflow performance. It stores and retrieves cached data using a provided key and optional restore-keys.",
    "source": "caching"
  },
  {
    "id": "ga_008",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What is the purpose of environment protection rules in GitHub Actions?",
    "ground_truth": "Environment protection rules enforce approval requirements and deployment branch restrictions before a job using that environment can execute, adding control over deployments.",
    "source": "environments"
  },
  {
    "id": "ga_009",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What does the `actions/upload-artifact` action do?",
    "ground_truth": "The `actions/upload-artifact` action uploads files or directories from the workflow run to artifact storage, making them available for download or use in subsequent jobs and workflows.",
    "source": "artifacts"
  },
  {
    "id": "ga_010",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What is a concurrency group used for in GitHub Actions?",
    "ground_truth": "Concurrency groups ensure that only one job or workflow with the same concurrency group name runs at a time. Other queued jobs with the same group are cancelled when a new one starts.",
    "source": "concurrency_groups"
  },
  {
    "id": "ga_011",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What workflow command is used to mask sensitive values in job logs?",
    "ground_truth": "The `add-mask` workflow command masks a string value in logs by replacing it with `***`. It is called using `echo \"::add-mask::{value}\"` format.",
    "source": "workflow_commands"
  },
  {
    "id": "ga_012",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "How do you reference a composite action from a workflow?",
    "ground_truth": "A composite action is referenced using the `uses:` keyword with the path to the action directory (e.g., `uses: ./path/to/action` or `uses: owner/repo/path/to/action@ref`).",
    "source": "composite_actions"
  },
  {
    "id": "ga_013",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What is the recommended security practice for referencing external GitHub Actions?",
    "ground_truth": "Pin actions to a full commit SHA instead of using branch names or version tags to prevent unexpected changes if the action is compromised or updated maliciously.",
    "source": "security_hardening"
  },
  {
    "id": "ga_014",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What does the `max-parallel` option in a matrix strategy control?",
    "ground_truth": "The `max-parallel` option limits the maximum number of matrix jobs that run concurrently. It ensures resource consumption is controlled when running large matrices.",
    "source": "matrix_strategies"
  },
  {
    "id": "ga_015",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What is the default retention period for artifacts in GitHub Actions?",
    "ground_truth": "The default retention period for artifacts is 90 days. Organizations and repositories can customize this retention period up to a maximum allowed by their plan.",
    "source": "artifacts"
  },
  {
    "id": "ga_016",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What does setting `GITHUB_TOKEN` permissions to read-only prevent?",
    "ground_truth": "Setting `GITHUB_TOKEN` permissions to read-only (`contents: read`) prevents the workflow from modifying repository contents, creating issues, or making other write operations that could be exploited.",
    "source": "security_hardening"
  },
  {
    "id": "ga_017",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "How do you define inputs for a reusable workflow?",
    "ground_truth": "Inputs are defined under `on.workflow_call.inputs` in the workflow file, specifying the input name, type (string, boolean, choice, environment), and optional default values and descriptions.",
    "source": "reusable_workflows"
  },
  {
    "id": "ga_018",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What is the primary advantage of using OIDC authentication over static secrets?",
    "ground_truth": "OIDC authentication eliminates the need to store long-lived cloud provider credentials in GitHub, using short-lived tokens instead and reducing the risk of credential exposure.",
    "source": "oidc_authentication"
  },
  {
    "id": "ga_019",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "What security restriction applies to workflows triggered by pull requests from forks?",
    "ground_truth": "Workflows triggered by pull requests from forks run with restricted `GITHUB_TOKEN` permissions and do not have access to secrets, preventing malicious code from accessing sensitive data.",
    "source": "security_hardening"
  },
  {
    "id": "ga_020",
    "domain": "github_actions_advanced",
    "difficulty": "easy",
    "question": "How do you use the `include` option in a matrix strategy?",
    "ground_truth": "The `include` option adds additional configuration combinations to a matrix by specifying extra variable combinations that extend the default matrix, allowing custom job configurations.",
    "source": "matrix_strategies"
  },
  {
    "id": "ga_021",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "When using reusable workflows with the workflow_call trigger, what is the maximum nesting depth supported, and what happens if you exceed it?",
    "ground_truth": "The maximum nesting depth for reusable workflows is 10 levels. If you exceed this limit, the workflow will fail with an error indicating that the call depth has been exceeded.",
    "source": "reusable_workflows_nesting"
  },
  {
    "id": "ga_022",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "Explain how secrets are inherited in reusable workflows when called from a caller workflow. Can you override inherited secrets in the called workflow?",
    "ground_truth": "Secrets are automatically inherited from the caller workflow context when using reusable workflows. You cannot override secrets in the called workflow; they are passed as read-only and maintain their original values from the caller's context.",
    "source": "reusable_workflows_secrets"
  },
  {
    "id": "ga_023",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "What is the difference between using workflow outputs and job outputs in a reusable workflow called via workflow_call?",
    "ground_truth": "Workflow outputs defined in a reusable workflow's outputs section are exposed to the caller workflow, while job outputs remain internal to that job. Only workflow outputs are accessible via the caller's job outputs mapping.",
    "source": "reusable_workflows_outputs"
  },
  {
    "id": "ga_024",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "In a composite action's action.yml, what are the key differences between defining 'inputs' and 'outputs', and how do they affect the action's contract?",
    "ground_truth": "Inputs define parameters the action accepts when called, while outputs define values the action produces and makes available to the caller. Inputs are required/optional and typed, whereas outputs are always exposed from the composite action's steps and consumed by the caller.",
    "source": "composite_actions_metadata"
  },
  {
    "id": "ga_025",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "What must you configure to enable OIDC token authentication for AWS in GitHub Actions, and what permission is required in the workflow?",
    "ground_truth": "You must configure an IAM role with trust relationship for the GitHub OIDC provider, and add the id-token: write permission in the workflow to allow GitHub to request and pass the OIDC token to AWS for federation.",
    "source": "oidc_authentication"
  },
  {
    "id": "ga_026",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "Describe what information is contained in the JWT claims of a GitHub-generated OIDC token, and give an example of how custom sub claims can be used.",
    "ground_truth": "The JWT includes claims like iss (issuer), aud (audience), sub (subject with actor/ref info), and others. Custom sub claims can be configured in the cloud provider's trust policy to restrict token usage to specific branches, repos, or environments, improving security.",
    "source": "oidc_jwt_claims"
  },
  {
    "id": "ga_027",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "In environment protection rules, what is the purpose of 'required reviewers' and how does it interact with deployment workflows?",
    "ground_truth": "Required reviewers enforce that specified users or teams must approve deployments to that environment before the workflow proceeds. The workflow pauses at deployment steps, waiting for approval from designated reviewers, preventing unauthorized deployments.",
    "source": "environments_protection"
  },
  {
    "id": "ga_028",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "How do deployment branches in environment settings restrict workflow execution, and what is the relationship between environment secrets and these branches?",
    "ground_truth": "Deployment branches specify which refs (branches/tags) can access and deploy to an environment. Environment secrets are only available to workflows deploying to that environment from allowed branches, providing environment-specific secret isolation.",
    "source": "environments_deployment_branches"
  },
  {
    "id": "ga_029",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "When using matrix strategies with dynamic matrices, what is the difference between 'include' and 'exclude' operations, and in what order are they applied?",
    "ground_truth": "'Include' adds new matrix combinations to the base matrix, while 'exclude' removes specific combinations. Exclude is applied after include, so you can add combinations and then refine by removing unwanted ones.",
    "source": "matrix_strategies_dynamic"
  },
  {
    "id": "ga_030",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "What does the fail-fast property do in matrix strategies, and what are the trade-offs of setting it to true versus false?",
    "ground_truth": "When fail-fast is true, GitHub cancels all in-progress jobs if any matrix job fails, providing faster feedback. Setting it to false allows all jobs to complete regardless of failures, which takes longer but captures all failure patterns for debugging.",
    "source": "matrix_strategies_fail_fast"
  },
  {
    "id": "ga_031",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "Explain how max-parallel in matrix strategies affects job execution and what considerations should guide your choice of this value.",
    "ground_truth": "Max-parallel limits the number of concurrent matrix jobs running simultaneously. Higher values speed up execution but consume more runner resources; lower values conserve resources but extend total execution time. Choose based on available runner capacity and time constraints.",
    "source": "matrix_strategies_max_parallel"
  },
  {
    "id": "ga_032",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "When using actions/cache, what is a cache hit versus cache miss, and what are the implications for workflow performance?",
    "ground_truth": "A cache hit occurs when the specified key exists, retrieving cached data and skipping rebuild steps. A cache miss requires rebuilding and storing the cache. Hits significantly improve performance; misses add build time but store data for future runs.",
    "source": "caching_actions_cache"
  },
  {
    "id": "ga_033",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "How does cache scope work in GitHub Actions\u2014specifically, how do caches created on one branch differ from caches on another branch?",
    "ground_truth": "Caches are scoped to the branch they're created on and are accessible to subsequent runs on that branch. Caches from other branches are not accessible, but a branch can restore caches from parent branches (for pull requests, the base branch cache is available).",
    "source": "caching_scope"
  },
  {
    "id": "ga_034",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "Describe the difference between artifact retention and cache retention in GitHub Actions, and when you should use each.",
    "ground_truth": "Artifacts are build outputs preserved long-term (up to 90 days default) for download and inspection, while caches are temporary dependencies optimized for speed (5-7 days, LRU eviction). Use artifacts for deliverables/logs; use caches for dependency acceleration.",
    "source": "artifacts_vs_caching"
  },
  {
    "id": "ga_035",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "What is a concurrency group in GitHub Actions, and how does it prevent duplicate workflows from running simultaneously?",
    "ground_truth": "A concurrency group ensures that only one workflow in that group runs at a time. If a new run with the same concurrency group key starts before a previous one completes, the previous run is cancelled, preventing duplicate or conflicting executions.",
    "source": "concurrency_groups"
  },
  {
    "id": "ga_036",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "In GitHub Actions workflow commands, what is the purpose of add-mask, and why is it important for secret management?",
    "ground_truth": "add-mask prevents a specified string from being logged in job output by replacing it with *** in logs. It's critical for hiding dynamic secrets or generated tokens that shouldn't appear in publicly visible workflow logs.",
    "source": "workflow_commands_mask"
  },
  {
    "id": "ga_037",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "Explain the difference between GITHUB_TOKEN permissions when set at workflow level versus job level, and what is the principle of least privilege?",
    "ground_truth": "Workflow-level permissions apply to all jobs, while job-level permissions override workflow defaults for that job only. Least privilege means granting only the minimum necessary permissions; restricting GITHUB_TOKEN to required scopes reduces risk if credentials are exposed.",
    "source": "security_github_token_permissions"
  },
  {
    "id": "ga_038",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "What security restriction is automatically applied to pull requests from forks in GitHub Actions, and what is the rationale?",
    "ground_truth": "Pull requests from forks do not have access to repository secrets by default, only public environment variables. This prevents malicious fork PRs from exfiltrating secrets, as fork contributors could modify workflow files to output secret values.",
    "source": "security_fork_pr_restrictions"
  },
  {
    "id": "ga_039",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "Why is pinning actions to a commit SHA considered a security best practice, and what are the trade-offs versus using semantic versioning tags?",
    "ground_truth": "Pinning to SHA ensures the exact action version is used, preventing supply-chain attacks from tag reassignment or compromised releases. Tags are easier to maintain and auto-update, but are mutable and could point to malicious code if the tag is reassigned.",
    "source": "security_action_pinning"
  },
  {
    "id": "ga_040",
    "domain": "github_actions_advanced",
    "difficulty": "medium",
    "question": "In the context of self-hosted runners, what security considerations must you account for regarding GitHub Actions contexts and secrets exposure?",
    "ground_truth": "Self-hosted runners execute untrusted workflow code and can access the runner's environment. You must restrict secrets access, isolate runners per trust boundary, use environment variables cautiously, and consider that contexts like github.token could be exposed through compromised workflows.",
    "source": "security_self_hosted_runners"
  },
  {
    "id": "ga_041",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "When nesting reusable workflows up to 10 levels deep, what is the critical limitation regarding secret inheritance, and how does it affect downstream workflows that require third-party API credentials?",
    "ground_truth": "Secrets are not automatically inherited through nested workflow calls; each level must explicitly pass secrets via the `secrets:` keyword using either `secrets: inherit` or by mapping individual secrets. Without explicit pass-through, nested workflows cannot access parent secrets, breaking credential chains in deeply nested CI/CD pipelines.",
    "source": "reusable_workflows_nesting"
  },
  {
    "id": "ga_042",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "In a matrix strategy with dynamic matrix generation from a repository file, what happens to job outputs and artifact uploads when using `fail-fast: true` and one matrix combination fails\u2014and how can you ensure dependent jobs still receive partial results?",
    "ground_truth": "With `fail-fast: true`, GitHub cancels all other in-progress matrix jobs immediately when one fails, preventing their outputs and artifacts from being generated. To capture partial results, set `fail-fast: false` and implement conditional job dependencies using `if: always()` or `if: success() || failure()` with explicit artifact download steps.",
    "source": "matrix_strategies_fail_fast"
  },
  {
    "id": "ga_043",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "When using OIDC authentication with AWS STS AssumeRoleWithWebIdentity, what specific JWT claims must be included in the custom `sub` claim configuration to prevent overly permissive role assumption, and what is the security risk of using only the `repo` claim?",
    "ground_truth": "The `sub` claim should include a combination of `repo`, `ref` (branch/tag), and optionally `actor` to restrict role assumption to specific repositories, branches, and sometimes users. Using only `repo` allows any workflow in that repository\u2014including pull requests from forks\u2014to assume the role, creating a supply-chain attack vector if fork workflows are malicious.",
    "source": "oidc_authentication_custom_claims"
  },
  {
    "id": "ga_044",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "A composite action uses multiple run steps with shell commands. If one step exports an environment variable using `echo 'VAR=value' >> $GITHUB_ENV`, explain why this persists across steps within the same composite action but fails to persist into the calling workflow, and how to fix it.",
    "ground_truth": "Environment variables set via `$GITHUB_ENV` persist within the composite action's step context but not to the parent workflow because they are scoped to the composite action's job step. To pass data to the calling workflow, use `outputs` in `action.yml` and reference the composite action's step outputs via `steps.<composite-step-id>.outputs.<output-name>`.",
    "source": "composite_actions_outputs"
  },
  {
    "id": "ga_045",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "Explain the security implications of using `actions/cache@v3` with a cache key that includes user input (e.g., branch names from pull requests), and what attack vector this creates in a multi-tenant CI/CD environment.",
    "ground_truth": "Including untrusted user input in cache keys allows attackers to craft malicious cache entries (e.g., compromised dependencies) and inject them into other workflows by manipulating branch names or pull request titles. This enables cache poisoning attacks where malicious code cached under an attacker-controlled key is retrieved by legitimate workflows. Use only repository-controlled identifiers (commit SHA, repo owner) in cache keys.",
    "source": "caching_security"
  },
  {
    "id": "ga_046",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "When configuring environment protection rules with required reviewers for a production deployment environment, what happens if a workflow run is queued for 72 hours (GitHub's timeout) waiting for approval, and how does concurrency control interact with this timeout?",
    "ground_truth": "After 72 hours, the workflow run expires and the deployment is cancelled automatically, releasing any concurrency group locks. If a `concurrency` group is used with the same environment, subsequent workflow runs will execute immediately rather than wait, potentially causing race conditions. You must implement manual approval timeout handling and ensure concurrency groups align with environment protection scope.",
    "source": "environments_protection_rules"
  },
  {
    "id": "ga_047",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "A self-hosted runner caches credentials in `~/.ssh` for Git operations. When running untrusted code (e.g., from a fork PR), what GitHub Actions feature prevents this credential leak, and what are the limitations of this protection?",
    "ground_truth": "The `GITHUB_TOKEN` permissions model and fork PR restrictions (preventing untrusted code from accessing secrets) limit exposure, but GitHub does not automatically sandbox self-hosted runners. The primary protection is the `pull_request_target` trigger's read-only token access when not explicitly granted permissions. However, a fork PR can still access the runner's file system, SSH keys, and environment if improperly configured, so repository rules enforcing approval before self-hosted execution are essential.",
    "source": "self_hosted_runners_security"
  },
  {
    "id": "ga_048",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "In a reusable workflow with `inputs` and `outputs`, if an output is generated conditionally (e.g., only when a specific input flag is true), how must you handle the case where the output is undefined to prevent downstream workflow failures?",
    "ground_truth": "Outputs that are conditionally generated must either: (1) always be set (even to an empty string or default value) in all code paths, or (2) be documented as optional and the calling workflow must use conditional job steps with `if: needs.<job-id>.outputs.<output-name> != ''` to handle undefined outputs. Failure to do so results in workflow failures when the output is referenced but not set.",
    "source": "reusable_workflows_outputs"
  },
  {
    "id": "ga_049",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "When pinning GitHub Actions to a commit SHA (e.g., `actions/checkout@abc123def456`), what is the security gap if the original tag is later deleted and reapplied to a different commit, and how does GitHub prevent tag manipulation attacks?",
    "ground_truth": "Pinning to a commit SHA provides immutability\u2014the specific commit cannot change. However, if a maintainer deletes a tag and reapplies it to a malicious commit, workflows that reference the tag (not SHA) become vulnerable. GitHub does not inherently prevent tag reassignment; security relies on maintainer integrity and repository branch protection rules. Using SHA pinning entirely eliminates this vector, but requires automation (Dependabot) to track upstream updates.",
    "source": "action_pinning_security"
  },
  {
    "id": "ga_050",
    "domain": "github_actions_advanced",
    "difficulty": "hard",
    "question": "A workflow uses `actions/upload-artifact@v3` with `retention-days: 5` and `actions/download-artifact@v3` in a separate workflow. If the download workflow is scheduled 6 days later, what happens, and how would you design a fallback to rebuild artifacts if they expire?",
    "ground_truth": "The download step fails because the artifact is automatically deleted after 5 days, causing the workflow to error unless you handle the failure. Design a fallback by wrapping the download in a conditional job with `continue-on-error: true`, then trigger a rebuild job (e.g., call a reusable workflow that rebuilds artifacts) using `if: failure()` in a subsequent job. Alternatively, extend retention-days to match your longest-running dependent workflows or store artifacts in external storage (S3, GCS).",
    "source": "artifacts_retention"
  }
]
