[
  {
    "id": "ra_001",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What is the primary purpose of the `async` keyword in Rust?",
    "ground_truth": "The `async` keyword transforms a function into an asynchronous function that returns a Future. It allows non-blocking execution by enabling the function to be paused and resumed at await points.",
    "source": "async_await_syntax"
  },
  {
    "id": "ra_002",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What does the `await` keyword do in an async context?",
    "ground_truth": "The `await` keyword polls a Future and suspends execution until the Future is ready. It can only be used inside async functions or blocks and is the primary mechanism for waiting on async operations.",
    "source": "async_await_syntax"
  },
  {
    "id": "ra_003",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "Name the Rust runtime most commonly used for production async applications.",
    "ground_truth": "Tokio is the most widely-used async runtime in Rust for production applications. It provides task scheduling, I/O multiplexing, timer utilities, and synchronization primitives.",
    "source": "tokio_runtime"
  },
  {
    "id": "ra_004",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What does `tokio::spawn` do?",
    "ground_truth": "`tokio::spawn` spawns a new asynchronous task on the Tokio runtime. The task runs concurrently with other tasks and returns a JoinHandle that can be awaited to get the task's result.",
    "source": "tokio_spawn"
  },
  {
    "id": "ra_005",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What is the `Pin` type used for in async Rust?",
    "ground_truth": "`Pin` is a wrapper type that guarantees a value will not be moved in memory. It is essential for self-referential structs and Futures because moving a Future can invalidate internal pointers used during polling.",
    "source": "pin_unpin"
  },
  {
    "id": "ra_006",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What does the `Unpin` marker trait indicate?",
    "ground_truth": "`Unpin` is a marker trait indicating that a type can be safely moved even when wrapped in `Pin`. Most types implement `Unpin` by default unless they contain self-referential data.",
    "source": "pin_unpin"
  },
  {
    "id": "ra_007",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What are the two key methods of the `Future` trait?",
    "ground_truth": "The `Future` trait has two key methods: `poll()` which attempts to advance the Future toward completion, and `poll()` returns `Poll<Self::Output>` (either `Ready(output)` or `Pending`).",
    "source": "future_trait"
  },
  {
    "id": "ra_008",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What is the difference between `Send` and `Sync` marker traits?",
    "ground_truth": "`Send` indicates a type can be safely transferred between threads, while `Sync` indicates a type can be safely shared between threads via immutable references. Both are auto-traits in Rust.",
    "source": "send_sync"
  },
  {
    "id": "ra_009",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What does `tokio::sync::mpsc` provide?",
    "ground_truth": "`tokio::sync::mpsc` (multi-producer, single-consumer) provides an async channel for sending messages from multiple tasks to a single receiver. It includes bounded and unbounded variants.",
    "source": "tokio_sync_mpsc"
  },
  {
    "id": "ra_010",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What is the purpose of `tokio::select!`?",
    "ground_truth": "`tokio::select!` is a macro that waits for multiple async operations and executes the first one to complete. It is useful for handling multiple concurrent futures and choosing based on which finishes first.",
    "source": "tokio_select"
  },
  {
    "id": "ra_011",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What does `tokio::sync::Mutex` provide compared to `std::sync::Mutex`?",
    "ground_truth": "`tokio::sync::Mutex` is an async-aware mutual exclusion lock that can be awaited and does not block the async runtime. `std::sync::Mutex` blocks threads and should not be used in async code.",
    "source": "tokio_sync_mutex"
  },
  {
    "id": "ra_012",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What is a `Waker` in Rust's async model?",
    "ground_truth": "A `Waker` is a handle that notifies the async runtime that a Future is ready to be polled again. It is passed to the `poll()` method via a `Context` and allows the runtime to efficiently schedule tasks.",
    "source": "waker_task_wakeup"
  },
  {
    "id": "ra_013",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What does `tokio::sync::oneshot` channel do?",
    "ground_truth": "`tokio::sync::oneshot` provides a single-use channel for sending exactly one message from a sender to a receiver. Once the message is sent or the channel is dropped, no further communication is possible.",
    "source": "tokio_sync_oneshot"
  },
  {
    "id": "ra_014",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What is the purpose of `tokio::sync::broadcast`?",
    "ground_truth": "`tokio::sync::broadcast` provides a multi-producer, multi-consumer channel where all receivers get a copy of each message. It is useful for fan-out patterns where one message needs to be delivered to multiple subscribers.",
    "source": "tokio_sync_broadcast"
  },
  {
    "id": "ra_015",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What does `AsyncRead` and `AsyncWrite` enable?",
    "ground_truth": "`AsyncRead` and `AsyncWrite` are traits that provide non-blocking read and write operations returning Futures. They enable asynchronous I/O operations on types like network sockets and file handles.",
    "source": "async_read_write"
  },
  {
    "id": "ra_016",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "Name two utility functions provided by `tokio::time`.",
    "ground_truth": "`tokio::time::sleep()` pauses execution for a duration and `tokio::time::timeout()` limits how long an operation can take. Both are commonly used for delays and deadline management in async code.",
    "source": "tokio_time"
  },
  {
    "id": "ra_017",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What is the purpose of `tokio::sync::watch`?",
    "ground_truth": "`tokio::sync::watch` provides a single-producer, multi-consumer channel for broadcasting state changes. It is useful for scenarios where many tasks need to be notified of state updates.",
    "source": "tokio_sync_watch"
  },
  {
    "id": "ra_018",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "How do you safely call a blocking function from async code?",
    "ground_truth": "Use `tokio::task::block_in_place()` or `tokio::task::spawn_blocking()` to run blocking code in a separate thread pool without blocking the async runtime.",
    "source": "sync_async_bridge"
  },
  {
    "id": "ra_019",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What is error handling pattern commonly used with async operations?",
    "ground_truth": "Async operations typically use `Result<T, E>` type and `?` operator for propagating errors, or `.await?` when awaiting a Future that returns a Result.",
    "source": "error_handling_async"
  },
  {
    "id": "ra_020",
    "domain": "rust_async_expert",
    "difficulty": "easy",
    "question": "What does `#[async_trait]` macro enable?",
    "ground_truth": "The `#[async_trait]` macro from the `async_trait` crate enables defining trait methods that return Futures, allowing async methods in trait definitions.",
    "source": "async_traits"
  },
  {
    "id": "ra_021",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "Why must a Future be pinned before being polled, and what does Pin prevent?",
    "ground_truth": "Pin prevents moving a Future in memory after polling has begun, which is necessary because a Future may contain self-referential data (e.g., pointers to its own fields). Without Pin, the compiler cannot guarantee that an address captured in one poll remains valid in the next poll.",
    "source": "Pin and Unpin mechanics"
  },
  {
    "id": "ra_022",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "What is the difference between tokio::spawn and block_on in terms of thread scheduling and when should each be used?",
    "ground_truth": "tokio::spawn schedules a task on the Tokio runtime's thread pool and returns a JoinHandle immediately without blocking; block_on blocks the current thread until a Future completes. Use spawn for concurrent tasks within an async context, and block_on to bridge sync code to async.",
    "source": "Tokio runtime task spawning"
  },
  {
    "id": "ra_023",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "Explain what happens when you call .await on a Future that is not Send, and why the compiler rejects it in a tokio::spawn context.",
    "ground_truth": "If a Future is not Send, it cannot be moved across thread boundaries. tokio::spawn requires Send because the task may be polled by different worker threads; a non-Send Future could violate thread safety. The compiler rejects this to prevent data races.",
    "source": "Send/Sync marker traits"
  },
  {
    "id": "ra_024",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "What does the Waker type do, and how does it differ from a callback in traditional async systems?",
    "ground_truth": "A Waker notifies the runtime that a task is ready to progress by queuing it for re-polling. Unlike callbacks which execute immediately, a Waker enqueues the task and lets the scheduler decide when to poll it next, enabling efficient batching and avoiding stack overflow.",
    "source": "Waker and task wakeups"
  },
  {
    "id": "ra_025",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "What is the primary trade-off between using tokio::sync::Mutex and parking_lot::Mutex in async code?",
    "ground_truth": "tokio::sync::Mutex is async-aware and yields the task on contention, allowing other tasks to run; parking_lot::Mutex is synchronous and may block the entire thread. Use tokio::sync::Mutex in async code to avoid starving other tasks, but it has slightly higher overhead.",
    "source": "tokio::sync primitives"
  },
  {
    "id": "ra_026",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "How does tokio::select! determine which branch to execute when multiple Futures are ready simultaneously?",
    "ground_truth": "tokio::select! polls branches in order and executes the first one that is ready (returns Poll::Ready). If multiple branches are ready, the first in the macro definition wins; this is not guaranteed to be fair, so fairness modules or random selection can be used to prevent starvation.",
    "source": "select!"
  },
  {
    "id": "ra_027",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "Describe the difference between mpsc::channel and mpsc::unbounded_channel, and when backpressure matters.",
    "ground_truth": "mpsc::channel has a bounded capacity and send() returns a Future that blocks when full, applying backpressure to senders. mpsc::unbounded_channel has no limit and send() never fails. Use bounded channels for rate control and to prevent memory bloat; use unbounded only when the sender rate is guaranteed to match receiver rate.",
    "source": "tokio::sync mpsc channels"
  },
  {
    "id": "ra_028",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "What problem does tokio::sync::oneshot solve, and why is it preferable to mpsc for request-response patterns?",
    "ground_truth": "oneshot ensures exactly one value is sent and received, with efficient cleanup if sender or receiver is dropped. It is simpler and more explicit than mpsc for request-response because it prevents accidental multiple sends and avoids the overhead of a multi-producer channel.",
    "source": "tokio::sync oneshot"
  },
  {
    "id": "ra_029",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "How does the broadcast channel differ from mpsc, and what guarantees does it provide about message ordering?",
    "ground_truth": "broadcast allows multiple subscribers (receivers) to receive the same message; mpsc has one receiver. broadcast maintains FIFO order per subscriber and discards old messages if subscribers lag, while mpsc guarantees delivery. Use broadcast for pub-sub and multicast patterns.",
    "source": "tokio::sync broadcast"
  },
  {
    "id": "ra_030",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "When implementing an async trait method, what constraint must be satisfied if the method returns a Future that needs to be sent across await points in tokio::spawn?",
    "ground_truth": "The returned Future must be Send. If the async trait uses impl Future (not async fn), the implementer must ensure all captured types are Send. Using async fn in traits (with #![feature(async_fn_in_trait)]) simplifies this by letting the compiler auto-derive bounds.",
    "source": "async traits"
  },
  {
    "id": "ra_031",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "What is the role of the Context parameter in the poll method, and why must you call Waker::wake on the correct Waker?",
    "ground_truth": "Context provides the Waker needed to notify the executor when the Future becomes ready. Calling wake on the correct Waker ensures the runtime re-polls this specific task; using the wrong Waker may wake an unrelated task or cause the task to never be re-polled.",
    "source": "Future trait and polling"
  },
  {
    "id": "ra_032",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "Explain how tokio::time::sleep handles timeouts internally and why it does not block a thread.",
    "ground_truth": "tokio::time::sleep returns a Future that completes after a duration without blocking. The runtime manages a timer heap; when polled, the Future registers with this heap and yields. The runtime's thread wakes the task via Waker when the timer fires, using efficient OS primitives.",
    "source": "tokio::time utilities"
  },
  {
    "id": "ra_033",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "What happens when you call a blocking operation (like std::thread::sleep) inside an async function, and what is the recommended solution?",
    "ground_truth": "Calling a blocking operation stalls the entire worker thread, starving other tasks. Use tokio::task::block_in_place to run the blocking code on a dedicated blocking thread pool, or use tokio::spawn_blocking to offload it. Alternatively, use async equivalents like tokio::time::sleep.",
    "source": "bridging sync and async code"
  },
  {
    "id": "ra_034",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "How does error propagation with ? operator differ in async functions compared to sync functions, and are there any special considerations?",
    "ground_truth": "The ? operator works identically in async functions, converting errors via From. However, error types must implement Send/Sync if the Future is sent across threads (tokio::spawn). Additionally, errors in tasks spawned with tokio::spawn are not automatically propagated; use JoinHandle::await to retrieve them.",
    "source": "error handling in async contexts"
  },
  {
    "id": "ra_035",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "What is the purpose of AsyncRead and AsyncWrite traits, and how do they differ from their std counterparts?",
    "ground_truth": "AsyncRead and AsyncWrite return Futures instead of blocking, allowing non-blocking I/O composition. read() and write() return futures that poll the underlying resource; this integrates seamlessly with async/await and Tokio's scheduler, whereas std Read/Write block the thread.",
    "source": "AsyncRead/AsyncWrite"
  },
  {
    "id": "ra_036",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "Describe the watch channel's use case and explain why it is more efficient than broadcast for state sharing.",
    "ground_truth": "watch is designed for sharing a single latest value with multiple watchers; it only stores the most recent value and drops older ones. It is more efficient than broadcast for state sharing because it uses less memory and does not maintain a message queue; watchers always get the latest state.",
    "source": "tokio::sync watch"
  },
  {
    "id": "ra_037",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "What does it mean for a type to be Unpin, and why are most types automatically Unpin?",
    "ground_truth": "Unpin indicates that the type can be safely moved in memory even after polling. Most types are Unpin because they contain no self-referential pointers. A type is !Unpin only if it has self-references, such as certain futures created with pin-project or generators.",
    "source": "Pin and Unpin mechanics"
  },
  {
    "id": "ra_038",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "Explain the difference between a stream and a future in Tokio, and describe how you would implement a simple custom stream.",
    "ground_truth": "A Future resolves to a single value; a Stream yields multiple values over time (similar to an Iterator). Implement a custom stream by implementing the Stream trait with poll_next, which returns Poll<Option<Item>>. Use tokio_stream or manually poll sources like channels.",
    "source": "Tokio streams"
  },
  {
    "id": "ra_039",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "What is a common pitfall when sharing mutable state across multiple spawned tasks, and how does Arc<tokio::sync::Mutex<T>> solve it?",
    "ground_truth": "Sharing &mut T across tasks violates Rust's borrow rules. Arc<tokio::sync::Mutex<T>> provides shared ownership (Arc) and async-safe mutual exclusion (Mutex), allowing multiple tasks to safely acquire exclusive access to T. Each task clones the Arc and locks independently.",
    "source": "Tokio shared state"
  },
  {
    "id": "ra_040",
    "domain": "rust_async_expert",
    "difficulty": "medium",
    "question": "How does the Tokio runtime's work-stealing scheduler improve performance, and what implications does this have for task locality?",
    "ground_truth": "The work-stealing scheduler allows idle worker threads to steal tasks from busy threads, improving load balancing and CPU utilization. However, this reduces task locality (a task may run on different threads), so you cannot rely on thread-local storage; use task-local storage (tokio::task_local) instead.",
    "source": "Tokio runtime"
  },
  {
    "id": "ra_041",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "Explain why calling `.await` on a Future that hasn't been polled yet may cause a deadlock when using tokio::sync::Mutex, and describe the correct pattern to avoid this using tokio::task::spawn_blocking.",
    "ground_truth": "Holding a tokio::sync::Mutex guard across an `.await` point can deadlock because the Mutex is not Send-safe for async contexts; if a task holding the lock yields, another task may try to acquire it and block the runtime thread. Use spawn_blocking for sync code holding locks, or refactor to avoid holding locks across await boundaries by using scoped critical sections.",
    "source": "tokio_sync_mutex_async_safety"
  },
  {
    "id": "ra_042",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "When using tokio::select! with multiple branches that involve channels, what is the fairness guarantee, and how can spurious wakeups affect branch selection in high-contention scenarios?",
    "ground_truth": "tokio::select! provides no fairness guarantee and randomly selects among ready branches; spurious wakeups can cause branches to be polled even when not ready, and in high contention the OS scheduler may not fairly distribute wakeups, so applications requiring fairness must implement explicit round-robin or priority queuing.",
    "source": "select_fairness_and_wakeups"
  },
  {
    "id": "ra_043",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "Describe the interaction between Pin, self-referential structs, and the safety invariants required for custom Future implementations. Why does moving a pinned Future violate memory safety?",
    "ground_truth": "Pin prevents moving a value in memory; self-referential futures contain pointers to their own fields, and moving them invalidates those pointers, causing use-after-free. A Future implementing Pin::project() correctly exposes only the fields that are safe to move, ensuring internal pointers remain valid across moves within the pinned region.",
    "source": "pin_self_referential_futures"
  },
  {
    "id": "ra_044",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "What are the performance implications of using tokio::sync::broadcast vs tokio::sync::watch for distributing state changes to many subscribers, and when should you prefer one over the other?",
    "ground_truth": "broadcast queues all messages and requires subscribers to keep up (older messages are dropped), suitable for high-throughput event streams; watch only stores the latest value and subscribers always see current state, better for state synchronization with slow consumers. Choose broadcast for total ordering guarantees, watch for memory efficiency and eventual consistency.",
    "source": "broadcast_vs_watch_tradeoffs"
  },
  {
    "id": "ra_045",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "Explain how the Waker::wake() mechanism interacts with executor task scheduling, and why calling wake() on a Waker from a different runtime (e.g., a different Tokio instance) is undefined behavior.",
    "ground_truth": "Each Waker is bound to a specific executor; calling wake() notifies that executor to re-poll the associated task. Calling wake() from a different runtime's context violates the executor's invariants and can cause data races or panics because the executor may not properly handle task wakeups from foreign sources.",
    "source": "waker_executor_binding"
  },
  {
    "id": "ra_046",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "How does tokio::time::sleep interact with task preemption, and what happens if you spawn many sleep tasks that all wake at the same deadline?",
    "ground_truth": "tokio::time::sleep registers with the timer heap; many tasks waking simultaneously causes a thundering herd on the executor, potentially causing scheduling latency spikes. The executor batches timer wakeups but cannot guarantee fairness; use backpressure mechanisms or stagger deadlines to avoid overwhelming the runtime.",
    "source": "timer_thundering_herd"
  },
  {
    "id": "ra_047",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "Describe a scenario where an async trait with a non-Send Future return type causes compilation failure in a multithreaded Tokio runtime, and explain the workaround.",
    "ground_truth": "An async trait returning a Future that contains !Send types (e.g., Rc<T>) cannot be spawned on tokio::spawn(), which requires Send. Workarounds include: (1) making the trait object-safe and using Box<dyn Future>, (2) using a custom runtime that doesn't require Send, or (3) refactoring to eliminate !Send types from the Future.",
    "source": "async_trait_send_requirements"
  },
  {
    "id": "ra_048",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "What are the semantics of tokio::sync::oneshot and why is it critical to handle both sender-dropped and receiver-dropped scenarios? How does this differ from std::sync::mpsc::channel?",
    "ground_truth": "oneshot allows exactly one message; if sender drops before sending, receiver gets Err(RecvError::Closed). Unlike std::sync::mpsc, oneshot is async-aware and integrates with the Waker system. Proper error handling distinguishes between 'sender lost' and 'message received', preventing silent failures in distributed workflows.",
    "source": "oneshot_semantics"
  },
  {
    "id": "ra_049",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "Explain the performance and correctness trade-offs when using tokio::sync::RwLock vs tokio::sync::Mutex for protecting shared state in a read-heavy async workload. Include considerations for fairness and starvation.",
    "ground_truth": "RwLock allows concurrent readers but incurs higher overhead per lock acquisition; in read-heavy workloads it reduces contention but can starve writers if readers continuously hold locks. Mutex is simpler and fairer; choose RwLock only when contention is demonstrable and reader-to-writer ratio justifies the complexity.",
    "source": "rwlock_vs_mutex_tradeoffs"
  },
  {
    "id": "ra_050",
    "domain": "rust_async_expert",
    "difficulty": "hard",
    "question": "When bridging sync and async code using tokio::task::block_in_place, what happens if you use it inside a tokio::spawn_blocking task, and why is this problematic?",
    "ground_truth": "block_in_place blocks the current async task's thread; calling it inside spawn_blocking (which already runs in a blocking thread pool) causes that blocking task to block its worker thread unnecessarily, reducing the pool's capacity. This is wasteful and can lead to thread starvation if many nested blocking operations occur.",
    "source": "block_in_place_nesting"
  }
]
