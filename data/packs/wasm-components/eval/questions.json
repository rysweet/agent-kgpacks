[
  {
    "id": "wc_001",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What does WIT stand for in the context of WebAssembly Components?",
    "ground_truth": "WIT stands for WebAssembly Interface Types. It is a language used to define interfaces and function signatures that components expose and consume.",
    "source": "WIT_language"
  },
  {
    "id": "wc_002",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "In the WebAssembly Component Model, what is a 'world' in a WIT file?",
    "ground_truth": "A world is a WIT construct that defines the complete interface contract of a component, specifying what it exports (provides) and what it imports (requires) from its environment.",
    "source": "WIT_worlds"
  },
  {
    "id": "wc_003",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "Name three WASI Preview 2 interfaces and their primary purposes.",
    "ground_truth": "wasi:io provides I/O primitives (streams and poll), wasi:http enables HTTP client/server functionality, wasi:cli supports command-line argument and environment access, and wasi:filesystem provides file system operations.",
    "source": "WASI_Preview2"
  },
  {
    "id": "wc_004",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What is wit-bindgen and what does it do?",
    "ground_truth": "wit-bindgen is a code generation tool that generates guest-language bindings from WIT files, allowing developers to call imported interfaces and implement exported interfaces in languages like Rust, Python, and JavaScript.",
    "source": "wit_bindgen"
  },
  {
    "id": "wc_005",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "In the wasmtime embedding API, what is the primary purpose of the 'Engine' struct?",
    "ground_truth": "The Engine is a shared, reusable container for WebAssembly compilation settings and optimizations. It manages compilation state and is typically created once and reused across multiple Store instances.",
    "source": "wasmtime_engine"
  },
  {
    "id": "wc_006",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What does the 'Store' type represent in wasmtime's Component API?",
    "ground_truth": "A Store is an execution context that holds runtime state for a component instance, including memory, tables, and imported/exported functions. Each component instance requires a Store.",
    "source": "wasmtime_store"
  },
  {
    "id": "wc_007",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What is the primary function of a 'Linker' in the wasmtime Component API?",
    "ground_truth": "The Linker associates host functions and interfaces with imported names, allowing a component to resolve its import dependencies and instantiate successfully.",
    "source": "wasmtime_linker"
  },
  {
    "id": "wc_008",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What is WasiCtx in wasmtime and why is it important?",
    "ground_truth": "WasiCtx is a configuration object that sets up the WASI environment for a component, including file descriptors, environment variables, and system call implementations. It bridges the guest component to the host system.",
    "source": "WasiCtx"
  },
  {
    "id": "wc_009",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "In the WebAssembly Component Model, what is a resource type?",
    "ground_truth": "A resource type is an opaque handle to host-managed state that a component can pass around and manipulate. Resources are defined in WIT interfaces and ensure safe, type-checked access to host objects.",
    "source": "resource_types"
  },
  {
    "id": "wc_010",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What is the Canonical ABI in the context of WebAssembly Components?",
    "ground_truth": "The Canonical ABI is the standard calling convention that specifies how data is encoded, passed, and returned between the host and guest when crossing component boundaries.",
    "source": "canonical_abi"
  },
  {
    "id": "wc_011",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What is an adapter module in WebAssembly Components?",
    "ground_truth": "An adapter module is a small component that translates between different interface versions or implementations, allowing older and newer components to interoperate despite interface changes.",
    "source": "adapter_modules"
  },
  {
    "id": "wc_012",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What tool is commonly used to compose multiple components into a single composite component?",
    "ground_truth": "wasm-tools is a command-line utility suite that includes component composition tools, allowing developers to merge multiple WebAssembly components and resolve their dependencies.",
    "source": "wasm_tools"
  },
  {
    "id": "wc_013",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "In WIT, how do you define that a component imports an interface?",
    "ground_truth": "You use the 'import' keyword in a world definition, followed by the namespace and interface name (e.g., 'import wasi:io/poll'). This declares that the component requires that interface from its host.",
    "source": "WIT_imports"
  },
  {
    "id": "wc_014",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "In WIT, how do you specify that a component exports a custom interface?",
    "ground_truth": "You use the 'export' keyword in a world definition, followed by the interface name and optional namespace (e.g., 'export my-interface'). This makes the interface available for the host or other components to call.",
    "source": "WIT_exports"
  },
  {
    "id": "wc_015",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What is wasmCloud and how does it relate to WebAssembly Components?",
    "ground_truth": "wasmCloud is a distributed application platform built on WebAssembly Components and WASI Preview 2, providing orchestration, capability security, and composition of distributed microservices as components.",
    "source": "wasmCloud_ecosystem"
  },
  {
    "id": "wc_016",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What is Fermyon Spin and what is its primary use case?",
    "ground_truth": "Fermyon Spin is a serverless application framework for building and deploying WebAssembly Components, focusing on fast startup and low resource overhead for event-driven workloads like HTTP requests.",
    "source": "Fermyon_Spin"
  },
  {
    "id": "wc_017",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What is the host/guest interface pattern in WebAssembly Components?",
    "ground_truth": "The host/guest pattern describes the separation of concerns where the guest (component) runs in a sandbox and calls host-provided functions through defined interfaces, while the host retains control over system resources and security policies.",
    "source": "host_guest_pattern"
  },
  {
    "id": "wc_018",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "In WIT, what does the 'use' keyword allow you to do?",
    "ground_truth": "The 'use' keyword in WIT allows you to reference types and interfaces from other packages or namespaces, reducing naming verbosity and organizing code hierarchically.",
    "source": "WIT_use_keyword"
  },
  {
    "id": "wc_019",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "What is the purpose of the wasi:cli interface in WASI Preview 2?",
    "ground_truth": "The wasi:cli interface provides access to command-line arguments and environment variables, allowing components to read startup parameters and configuration from their execution context.",
    "source": "WASI_cli"
  },
  {
    "id": "wc_020",
    "domain": "wasm_components",
    "difficulty": "easy",
    "question": "In wasmtime, how do you instantiate a component from a compiled Component module?",
    "ground_truth": "You call the 'instantiate' method on a Linker with a Store and the compiled Component, passing the Linker's configured imports and dependencies to create a running component instance.",
    "source": "wasmtime_instantiate"
  },
  {
    "id": "wc_021",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "When defining a resource type in WIT, what is the relationship between the resource declaration and how it appears in the canonical ABI, and why can't resources be directly passed by value across component boundaries?",
    "ground_truth": "Resources are opaque handles in WIT that become 32-bit indices in the canonical ABI. They cannot be passed by value because components may not share memory; the canonical ABI uses handle indirection to allow the host to maintain ownership and lifecycle of the actual resource data while the guest holds only an opaque reference.",
    "source": "resource_types"
  },
  {
    "id": "wc_022",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "In the wasmtime embedding API, what is the difference between using `Linker::instantiate` and manually calling `Component::new` followed by `Linker::instantiate`, and when would you choose one approach over the other?",
    "ground_truth": "`Linker::instantiate` is a convenience method that does both component compilation and instantiation in one call. Manually using `Component::new` first allows you to reuse the compiled component for multiple instantiations with different linkers or stores, improving performance when creating many instances of the same component.",
    "source": "wasmtime_embedding_api"
  },
  {
    "id": "wc_023",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "How does WasiCtx configuration in wasmtime differ from traditional WASI, and what capabilities does WASI Preview 2 grant that depend on proper WasiCtx setup?",
    "ground_truth": "WasiCtx in wasmtime uses the preview2-command or preview2-reactor adapter to bridge WASI Preview 2 with the component model. It provides sandboxed access to filesystem, stdio, environment, and clocks based on configured permissions. Proper WasiCtx setup determines whether a component can access files, call http, read environment variables, or interact with the CLI.",
    "source": "WasiCtx_configuration"
  },
  {
    "id": "wc_024",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "Explain the role of adapter modules in component composition and describe a scenario where you would need an adapter module rather than direct component linking.",
    "ground_truth": "Adapter modules convert between different interfaces or versions, acting as shims between incompatible components. You would use an adapter when composing a component targeting an older WASI interface with a newer host runtime, or when bridging a custom interface to a standard one like wasi:http without recompiling the original component.",
    "source": "adapter_modules"
  },
  {
    "id": "wc_025",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "In WIT, what is the semantic difference between defining a function as `import` versus `export`, and how does this affect component instantiation in wasmtime?",
    "ground_truth": "Imports are interfaces the component requires from the host; exports are interfaces the component provides to the host. During wasmtime instantiation, the Linker must satisfy all imports before the component can be instantiated, while exports become available after successful instantiation for the host to call.",
    "source": "host_guest_interface_patterns"
  },
  {
    "id": "wc_026",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "How does wit-bindgen handle the canonical ABI translation for string parameters when generating guest-side bindings, and what efficiency implications does this have?",
    "ground_truth": "wit-bindgen generates code that converts native language strings to UTF-8 bytes in linear memory, passing pointers and lengths according to the canonical ABI. This avoids allocating strings on the host side but requires the guest to manage memory encoding/decoding, which can be optimized by batching operations to reduce allocation overhead.",
    "source": "wit_bindgen_code_generation"
  },
  {
    "id": "wc_027",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "Describe the difference between wasi:io/streams and wasi:http in WASI Preview 2, and explain why an HTTP component might need to implement or compose with both.",
    "ground_truth": "wasi:io/streams provides low-level async I/O primitives (input-stream, output-stream, poll), while wasi:http provides high-level HTTP client/server abstractions. An HTTP component uses wasi:io/streams internally for I/O multiplexing and buffering, while exposing wasi:http interfaces to higher-level application code.",
    "source": "WASI_Preview_2"
  },
  {
    "id": "wc_028",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "When using wasm-tools to compose components, what does the `wasm-tools compose` command do with imports and exports that share the same interface name, and what validation occurs?",
    "ground_truth": "`wasm-tools compose` connects provider component exports to consumer component imports by matching interface names and ensuring type compatibility. It validates that exported types exactly match imported types and that there are no circular dependencies or unresolved imports in the final composed component.",
    "source": "component_composition_wasm_tools"
  },
  {
    "id": "wc_029",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "In wasmcloud, how do the component model and WIT interfaces enable loose coupling between actors and capability providers?",
    "ground_truth": "Actors define capability imports in WIT without knowing the specific provider implementation. wasmcloud routes calls through a standard interface contract, allowing providers to be replaced or upgraded independently as long as they maintain the same WIT interface, enabling dynamic binding and service discovery.",
    "source": "wasmcloud_ecosystem"
  },
  {
    "id": "wc_030",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "Explain how Fermyon Spin uses the component model to structure serverless functions, and what advantage this provides over traditional WebAssembly modules.",
    "ground_truth": "Spin packages functions as components with defined WIT interfaces for triggers and capabilities. This allows Spin to compose routing logic, middleware, and I/O abstractions as reusable components, and enables multiple language function runtimes to coexist with standardized interfaces for database, HTTP, and messaging access.",
    "source": "Fermyon_Spin_ecosystem"
  },
  {
    "id": "wc_031",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "What is the purpose of the `world` construct in WIT, and how does it relate to component instantiation constraints in wasmtime?",
    "ground_truth": "A world in WIT defines the complete set of imports and exports required for a component, acting as a contract specification. wasmtime uses the world to validate that the Linker has provided all required imports and to type-check host code that accesses exported functions, preventing runtime instantiation errors.",
    "source": "WIT_worlds"
  },
  {
    "id": "wc_032",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "When generating host-side bindings with wit-bindgen for Rust, what is the difference in how the generated code handles sync versus async function calls to imported interfaces?",
    "ground_truth": "wit-bindgen generates synchronous wrapper functions for synchronous WIT function signatures and returns `Future` types for async signatures. Async binding calls are mapped to the host's async runtime (e.g., tokio), while sync calls execute directly, with the wasmtime engine determining whether the guest can be suspended.",
    "source": "wit_bindgen_code_generation"
  },
  {
    "id": "wc_033",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "Explain what the canonical ABI means by 'lifting' and 'lowering,' and why both operations are necessary for host-guest interaction.",
    "ground_truth": "Lowering converts high-level language values (host side) to canonical ABI representation (linear memory pointers, integers). Lifting converts canonical ABI values back to high-level types (guest side). Both are necessary because the component model requires language-agnostic, linearized representations that can be marshalled across the Wasm boundary.",
    "source": "canonical_ABI"
  },
  {
    "id": "wc_034",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "In a WIT interface, what are the constraints on variant types, and how does this affect their representation in the canonical ABI?",
    "ground_truth": "WIT variant types must have disjoint cases with optional associated data. In the canonical ABI, variants are encoded as a discriminant (tag) followed by optional payload, with size determined by the largest case. This allows efficient pattern matching across language boundaries.",
    "source": "WIT_interface_types"
  },
  {
    "id": "wc_035",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "How does wasi:cli/main differ from other WASI Preview 2 interfaces, and what constraint does it place on component structure?",
    "ground_truth": "wasi:cli/main is an export interface that the host calls to start command execution, requiring the component to export a `main` function. Only one component can export wasi:cli/main in a composition, making it the entry point, while other WASI interfaces are typically imported capability providers.",
    "source": "WASI_Preview_2"
  },
  {
    "id": "wc_036",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "When using the wasmtime `Store` type with components, what is the relationship between Store instance state and component instantiation, and why would you reuse a Store across multiple component instances?",
    "ground_truth": "A Store holds instance data and state; each component instantiation creates a new logical instance within the Store. Reusing a Store allows instances to efficiently share data and reduces memory overhead, but you must manage potential data visibility and state isolation between instances in the same Store.",
    "source": "wasmtime_embedding_api"
  },
  {
    "id": "wc_037",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "Describe how wasi:filesystem in WASI Preview 2 uses descriptor-based access and why this is safer than traditional file path APIs.",
    "ground_truth": "wasi:filesystem operates on opaque descriptor handles obtained from preopened directories, preventing directory traversal attacks via `../` sequences. The host validates descriptor validity and permissions, confining guest access to pre-authorized paths, whereas path-based APIs could be exploited through symlinks or permission race conditions.",
    "source": "WASI_Preview_2"
  },
  {
    "id": "wc_038",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "In component composition with wasm-tools, what happens when two components export the same interface with different type definitions, and how should this conflict be resolved?",
    "ground_truth": "wasm-tools will reject composition if exported types from different components don't match exactly. Resolution requires creating an adapter module that translates between the type definitions or refactoring components to use a shared WIT interface definition as a canonical contract.",
    "source": "component_composition_wasm_tools"
  },
  {
    "id": "wc_039",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "What role do `use` statements serve in WIT, and how do they affect namespace resolution and type sharing across interfaces?",
    "ground_truth": "`use` statements import type definitions and function signatures from other WIT packages or interface definitions, allowing components to reference common types without duplication. They create an implicit dependency and ensure that all components share the same type definitions for interoperability.",
    "source": "WIT_interface_types"
  },
  {
    "id": "wc_040",
    "domain": "wasm_components",
    "difficulty": "medium",
    "question": "Explain how wasmcloud's lattice communication pattern differs from direct component linking, and what advantages it provides for distributed component architectures.",
    "ground_truth": "The lattice uses asynchronous message passing and capability invocation across network boundaries, allowing components to be decoupled geographically and deployed independently. Direct linking is synchronous and local, while the lattice enables dynamic service discovery, load balancing, and resilience through provider abstraction.",
    "source": "wasmcloud_ecosystem"
  },
  {
    "id": "wc_041",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "When composing multiple components using wasm-tools compose, explain why directly linking resource handles across component boundaries without adapter modules can cause canonical ABI violations, and describe the correct pattern for resource ownership transfer.",
    "ground_truth": "Resources in the Component Model are opaque handles managed by the canonical ABI; direct cross-component linking breaks the invariant that each component maintains its own resource namespace. Adapter modules or explicit resource wrapping via imported interfaces are required to translate handle representations and maintain capability-based security boundaries between components.",
    "source": "component_composition_resources"
  },
  {
    "id": "wc_042",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "In wasmtime's Component API, describe the memory model implications of calling guest functions that return large list<u8> structures, and explain how the canonical ABI's guest-controlled linear memory allocation affects performance and stack overflow risk in embedded scenarios.",
    "ground_truth": "The canonical ABI allocates and writes list data into the guest's linear memory during return, meaning large lists require proportional guest memory. The guest's allocator is called reentrant-safely; undersized memory or inefficient allocators can cause stack corruption or OOM. Performance degrades with list size due to memcpy overhead; streaming patterns via poll-based I/O interfaces (wasi:io) are preferred.",
    "source": "canonical_abi_memory_performance"
  },
  {
    "id": "wc_043",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "Explain the security implications of improperly configuring WasiCtx's filesystem sandbox when hosting untrusted components. What specific preopens and capabilities must be withheld, and why does WASI Preview 2's capability model differ from POSIX in preventing symlink-based escape attacks?",
    "ground_truth": "WasiCtx must explicitly preopen only whitelisted directories; granting access to '/' or parent directories enables directory traversal and symlink attacks. WASI Preview 2 uses path-relative file descriptors and rejects absolute paths, preventing symlink-based escape by design. Improperly configured descriptors or enabling allow_insecure_preopen bypasses capability isolation.",
    "source": "wasi_filesystem_security_capabilities"
  },
  {
    "id": "wc_044",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "When using wit-bindgen to generate bindings for a guest component that implements async stream-based I/O (wasi:io streams), explain why the generated code must handle the guest's linear memory layout for partially-written buffers, and describe potential data corruption scenarios if async cancellation occurs mid-write.",
    "ground_truth": "wit-bindgen generates code that pins guest memory regions during async operations; if a stream write is cancelled while the guest's buffer pointer is mid-operation, the canonical ABI's split between guest-side buffer management and host-side I/O state can leave partial writes in the guest's memory untracked. Proper patterns require explicit flush semantics and idempotent write boundaries defined in WIT.",
    "source": "wit_bindgen_async_stream_safety"
  },
  {
    "id": "wc_045",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "In a wasmCloud actor model deployment, explain why a component cannot directly invoke another component's exported functions across network boundaries, and describe the role of interface contracts, link definitions, and the message broker in enforcing capability-based routing.",
    "ground_truth": "wasmCloud enforces location-transparent, capability-based invocation through the message broker; components expose interfaces (via WIT contracts) but cannot call other components directly. Link definitions establish scoped capabilities (e.g., 'actor A can call HTTP provider interface'). This pattern enables dynamic lattice reconfiguration and prevents unauthorized function invocation across trust domains.",
    "source": "wasmcloud_capability_routing"
  },
  {
    "id": "wc_046",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "Describe the toolchain interaction required to adapt a WASI Preview 1 component (using old wasi:filesystem) to operate within a Preview 2 host that only supports wasi:io and wasi:filesystem. What role does adapter.wasm play, and why cannot a simple ABI shim suffice?",
    "ground_truth": "An adapter module (adapter.wasm) wraps the Preview 1 component and translates its imported interface calls to Preview 2 equivalents, handling differences in file descriptor semantics, stream-based I/O, and error representations. A shim is insufficient because Preview 1 assumes blocking I/O and direct file metadata access, while Preview 2 uses non-blocking streams; the adapter must desugar Preview 1 syscall semantics into Preview 2 composition patterns.",
    "source": "adapter_modules_abi_translation"
  },
  {
    "id": "wc_047",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "In Fermyon Spin, explain why a component using wasi:http to call back to the host's trigger (e.g., HTTP trigger handler) can create deadlock, and describe the execution model constraint that prevents re-entrant host calls in the Spin runtime.",
    "ground_truth": "Spin's component execution uses a single-threaded async runtime per store instance; if a guest component makes an outbound wasi:http call that routes back to the host trigger, the trigger handler would need to await the component completion, creating a cycle. Spin prevents this by isolating trigger execution and outbound I/O contexts, rejecting recursive host-to-guest transitions.",
    "source": "spin_reentrancy_constraints"
  },
  {
    "id": "wc_048",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "Explain how the Linker's type-checking in wasmtime's Component API ensures that mismatched WIT interface versions between host and guest cannot be silently ignored. What happens if a guest expecting wasi:io v0.2.0 is linked against a host providing v0.1.0, and why does semantic versioning alone not solve this?",
    "ground_truth": "The Linker validates that all imported function signatures and resource type definitions match byte-for-byte during linking; version mismatches in WIT produce different canonical ABIs (different memory layouts, function arity). Semantic versioning is a convention; only runtime type checking by the Linker prevents incompatible ABIs from being bound, causing runtime panics or memory safety violations.",
    "source": "linker_type_checking_versioning"
  },
  {
    "id": "wc_049",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "Describe a scenario where using resource types with explicit destructors (drop semantics) in WIT can introduce a TOCTOU (time-of-check-time-of-use) vulnerability in a multi-component system, and explain how to mitigate it with interface design.",
    "ground_truth": "If a resource handle is obtained, checked for validity, then used across an async boundary or after an intervening component call, the resource may be dropped by another component or invalidated by the host, causing use-after-free. Mitigation requires either atomic check-and-use operations defined in WIT, or scoped resource borrowing patterns (e.g., passing resources as function parameters rather than storing handles).",
    "source": "resource_toctou_vulnerability"
  },
  {
    "id": "wc_050",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "When implementing a custom WasiCtx with non-standard filesystem mounts, explain why directly exposing mutable state (e.g., &mut Arc<DashMap>) to multiple component Store instances can violate the canonical ABI's assumptions about linear memory isolation, and describe the correct pattern for shared mutable host state.",
    "ground_truth": "Each Store has its own linear memory and component instance; direct sharing of mutable host state via Arc<Mutex<T>> requires careful synchronization across Store boundaries. The canonical ABI assumes host functions execute atomically with respect to guest memory; concurrent mutation of shared state during a guest function call can corrupt invariants. Correct pattern: use message passing or explicit callback interfaces to avoid shared mutable state visible to components.",
    "source": "wasi_ctx_concurrency_safety"
  },
  {
    "id": "wc_051",
    "domain": "wasm_components",
    "difficulty": "hard",
    "question": "Given a WIT interface that exports a resource type with methods, explain why the wit-bindgen-generated guest code cannot safely implement the Drop trait on the resource wrapper type, and describe the correct pattern for ensuring resource cleanup in guest code before the component terminates.",
    "ground_truth": "Resources are managed by the Component Model runtime; Drop on the guest side would attempt to deallocate memory for an opaque handle, not the underlying resource. The host owns resource lifecycle. Correct pattern: explicitly call destructor methods defined in WIT (e.g., 'drop' or 'close'), or rely on the host's garbage collection of leaked handles post-component termination.",
    "source": "wit_bindgen_resource_lifetime"
  }
]
