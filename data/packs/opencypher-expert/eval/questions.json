[
  {
    "id": "oe_001",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is the primary purpose of the MATCH clause in OpenCypher queries executed against Kuzu?",
    "ground_truth": "The MATCH clause is used to search for and retrieve patterns in the graph database. It specifies the nodes, relationships, and patterns to find, returning all matching results that satisfy the pattern definition.",
    "source": "MATCH_clause"
  },
  {
    "id": "oe_002",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "In Kuzu, what does the RETURN clause do in an OpenCypher query?",
    "ground_truth": "The RETURN clause specifies which properties, nodes, relationships, or computed values should be included in the query result set. It defines the output format and content of the query response.",
    "source": "RETURN_clause"
  },
  {
    "id": "oe_003",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is the purpose of the WHERE clause in a Kuzu OpenCypher query?",
    "ground_truth": "The WHERE clause filters results by applying conditions to nodes, relationships, or properties. It allows you to restrict the matched patterns to only those that satisfy specified logical expressions.",
    "source": "WHERE_clause"
  },
  {
    "id": "oe_004",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What does the LIMIT clause do in an OpenCypher query for Kuzu?",
    "ground_truth": "The LIMIT clause restricts the number of results returned by a query to a specified maximum count. It is commonly used for pagination and reducing output size.",
    "source": "LIMIT_clause"
  },
  {
    "id": "oe_005",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "In Kuzu, what does the SKIP clause accomplish in an OpenCypher query?",
    "ground_truth": "The SKIP clause omits the first N results from a query result set, allowing you to implement pagination by skipping past previously returned rows.",
    "source": "SKIP_clause"
  },
  {
    "id": "oe_006",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is the syntax for declaring a variable-length path pattern in Kuzu OpenCypher?",
    "ground_truth": "Variable-length paths are declared using the syntax (node)-[rel*min..max]->(target), where min and max specify the minimum and maximum number of hops. If omitted, the default is min=1 and max=unbounded.",
    "source": "variable_length_paths"
  },
  {
    "id": "oe_007",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What does the CREATE NODE TABLE statement do in Kuzu?",
    "ground_truth": "CREATE NODE TABLE defines a new node table schema in the Kuzu database, specifying the node type name and the properties (columns) that nodes of that type will contain.",
    "source": "CREATE_NODE_TABLE"
  },
  {
    "id": "oe_008",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is the purpose of the CREATE REL TABLE statement in Kuzu?",
    "ground_truth": "CREATE REL TABLE defines a new relationship table schema, specifying the relationship type name, the source and target node tables it connects, and any properties the relationships will contain.",
    "source": "CREATE_REL_TABLE"
  },
  {
    "id": "oe_009",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What does the DETACH DELETE clause do in Kuzu OpenCypher?",
    "ground_truth": "DETACH DELETE removes a node and all relationships connected to it in a single operation. This avoids integrity constraint violations that would occur if deleting the node before removing its incident relationships.",
    "source": "DETACH_DELETE"
  },
  {
    "id": "oe_010",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is the SERIAL data type used for in Kuzu?",
    "ground_truth": "The SERIAL data type automatically generates sequential integer values for nodes or records, typically used for auto-incrementing primary keys or unique identifiers.",
    "source": "SERIAL_datatype"
  },
  {
    "id": "oe_011",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "In Kuzu, what does the COUNT aggregation function return?",
    "ground_truth": "COUNT returns the number of non-null values in a result set or group. It is commonly used with implicit GROUP BY to count occurrences of specific patterns or properties.",
    "source": "COUNT_aggregation"
  },
  {
    "id": "oe_012",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is the purpose of the WITH clause in Kuzu OpenCypher queries?",
    "ground_truth": "The WITH clause acts as an intermediate result set operator that allows you to chain multiple query segments together, breaking down complex queries into more manageable steps and passing results forward.",
    "source": "WITH_clause"
  },
  {
    "id": "oe_013",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What does the ORDER BY clause do in a Kuzu OpenCypher query?",
    "ground_truth": "ORDER BY sorts the query results by one or more properties or expressions in ascending (default) or descending order, controlling the sequence in which results are returned.",
    "source": "ORDER_BY_clause"
  },
  {
    "id": "oe_014",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is the UNWIND clause used for in Kuzu OpenCypher?",
    "ground_truth": "UNWIND expands a list or array into individual rows, transforming a single row with a list property into multiple rows with one element each. This is useful for flattening nested data.",
    "source": "UNWIND_clause"
  },
  {
    "id": "oe_015",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What does the COPY FROM statement do in Kuzu?",
    "ground_truth": "COPY FROM imports data into a Kuzu table from external files such as CSV or Parquet, populating nodes or relationships from bulk data sources.",
    "source": "COPY_FROM_import"
  },
  {
    "id": "oe_016",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is the HNSW index extension used for in Kuzu?",
    "ground_truth": "The HNSW (Hierarchical Navigable Small World) index extension enables approximate nearest neighbor vector search on graph data, allowing efficient similarity queries on vector properties.",
    "source": "HNSW_vector_search"
  },
  {
    "id": "oe_017",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What does the PROFILE keyword do when executing a Kuzu OpenCypher query?",
    "ground_truth": "PROFILE executes a query and returns execution statistics, including runtime, cardinality estimates, and operator details, enabling query optimization and performance analysis.",
    "source": "PROFILE_optimization"
  },
  {
    "id": "oe_018",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is the primary benefit of using parameterized queries in Kuzu?",
    "ground_truth": "Parameterized queries improve security by preventing injection attacks and enhance performance through query plan caching, as the same compiled query can be reused with different parameter values.",
    "source": "parameterized_queries"
  },
  {
    "id": "oe_019",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "In Kuzu, what does the MERGE clause do in an OpenCypher query?",
    "ground_truth": "MERGE combines CREATE and MATCH operations: it finds matching nodes or relationships, and if they don't exist, it creates them. This ensures idempotent operations without duplicates.",
    "source": "MERGE_clause"
  },
  {
    "id": "oe_020",
    "domain": "opencypher_expert",
    "difficulty": "easy",
    "question": "What is implicit GROUP BY behavior in Kuzu OpenCypher?",
    "ground_truth": "Implicit GROUP BY automatically groups results when aggregation functions are used without an explicit GROUP BY clause, grouping by all non-aggregated properties in the RETURN statement.",
    "source": "implicit_GROUP_BY"
  },
  {
    "id": "oe_021",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "When using variable-length paths in Kuzu (e.g., (a)-[r*1..3]->(b)), what is the semantic difference between WALK, TRAIL, and ACYCLIC path modes, and when would you choose ACYCLIC over WALK?",
    "ground_truth": "WALK allows repeated nodes and edges (least restrictive), TRAIL allows repeated nodes but not edges, and ACYCLIC forbids both repeated nodes and edges. Use ACYCLIC when you need to find paths without cycles, such as hierarchical structures or DAG traversals, to avoid exponential result explosion in cyclic graphs.",
    "source": "path_semantics"
  },
  {
    "id": "oe_022",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "In Kuzu, how does the implicit GROUP BY behavior differ when you use aggregation functions like COUNT or SUM in a RETURN clause without an explicit GROUP BY, and what columns are implicitly grouped?",
    "ground_truth": "Kuzu implicitly groups by all non-aggregated columns in the RETURN clause. If you return only aggregates without grouping columns, results are aggregated across the entire result set. All columns that appear in RETURN without aggregation functions become implicit grouping keys.",
    "source": "implicit_group_by"
  },
  {
    "id": "oe_023",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "When defining a node table in Kuzu with CREATE NODE TABLE, what is the purpose of the PRIMARY KEY constraint, and how does it affect the ability to perform MERGE operations?",
    "ground_truth": "The PRIMARY KEY uniquely identifies each node and is required for MERGE operations to determine if a node already exists. MERGE uses the PRIMARY KEY to check existence and decide whether to create a new node or match an existing one; without a PRIMARY KEY, MERGE behavior is undefined.",
    "source": "data_definition"
  },
  {
    "id": "oe_024",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "Explain the difference between DETACH DELETE and DELETE in Kuzu when removing nodes, and describe a scenario where using DELETE without DETACH would cause an error.",
    "ground_truth": "DELETE removes a node only if it has no incoming or outgoing relationships, while DETACH DELETE removes all relationships first then deletes the node. Using DELETE on a node with relationships will raise an error; DETACH DELETE is required when you want to remove a node regardless of its relationships.",
    "source": "data_manipulation"
  },
  {
    "id": "oe_025",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "When importing data into Kuzu using COPY FROM with CSV files, how should you structure your query to handle multiple CSV files that need to be loaded into a single node table, and what optimization considerations apply?",
    "ground_truth": "You can issue multiple COPY FROM statements sequentially, each pointing to different CSV files, or use a wildcard pattern (e.g., 'data/*.csv') to load all matching files in a single statement. Kuzu will parallelize the import; using wildcards is more efficient than multiple statements as it reduces parsing overhead.",
    "source": "import_export"
  },
  {
    "id": "oe_026",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "In Kuzu, how do HNSW vector indexes improve query performance for vector search, and what tradeoffs exist between index recall, memory consumption, and query latency?",
    "ground_truth": "HNSW indexes use hierarchical navigable small-world graphs for approximate nearest neighbor search, trading exact recall for speed. Higher ef_construction and max_m parameters improve recall but increase memory and construction time; larger ef_search parameters during queries improve recall at the cost of latency.",
    "source": "vector_search_hnsw"
  },
  {
    "id": "oe_027",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "Describe how you would use the WITH clause to break down a complex multi-step graph query in Kuzu, and explain why this approach is preferable to nested subqueries for query optimization.",
    "ground_truth": "WITH allows you to materialize intermediate results and pass them to subsequent query clauses, acting as a pipeline. This is preferable to subqueries because WITH preserves variable scope, enables query optimizer to see the full pipeline structure, and allows you to debug intermediate results; subqueries are harder for the optimizer to parallelize.",
    "source": "query_optimization"
  },
  {
    "id": "oe_028",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "When using the COLLECT aggregate function in Kuzu, what data structure is returned, and how would you combine COLLECT with UNWIND to transform nested results back into individual rows?",
    "ground_truth": "COLLECT returns a LIST containing all values from the aggregation group. Use UNWIND on the collected list in a subsequent WITH or RETURN clause to expand the list back into individual rows, effectively reversing the aggregation; this is useful for post-processing or reformatting grouped results.",
    "source": "aggregation_functions"
  },
  {
    "id": "oe_029",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "Explain the difference between creating a relationship table with a MULTI relationship and a single relationship in Kuzu, and when you would use each.",
    "ground_truth": "MULTI relationships allow multiple edges between the same pair of nodes with potentially different properties, while single relationships enforce at most one edge per node pair. Use MULTI for scenarios like social networks with multiple relationship types or time-stamped interactions; use single relationships for constraints like unique parent-child hierarchies.",
    "source": "data_definition"
  },
  {
    "id": "oe_030",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "In a Kuzu query using MATCH with multiple relationship patterns, what is a cartesian product and why is it a performance problem? How would you restructure your query to avoid it?",
    "ground_truth": "A cartesian product occurs when two independent MATCH clauses without shared variables create all possible combinations of results, multiplying result size unnecessarily. Avoid it by ensuring MATCH clauses share variables (connect through nodes/relationships) or use WHERE clauses to filter early; use PROFILE to detect cartesian products.",
    "source": "query_optimization"
  },
  {
    "id": "oe_031",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "Describe how the SERIAL data type works in Kuzu for auto-incrementing values, and what limitations or considerations exist when using SERIAL in distributed or concurrent scenarios.",
    "ground_truth": "SERIAL automatically generates sequential integer values for new records. In Kuzu's embedded context, SERIAL is single-threaded and maintains sequence integrity within a database instance; be cautious when re-exporting and re-importing data as SERIAL values may conflict unless handled with OFFSET or remapped.",
    "source": "data_types"
  },
  {
    "id": "oe_032",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "When using prepared statements in Kuzu Python API, how do parameters improve security and performance compared to string interpolation, and provide a code pattern example.",
    "ground_truth": "Prepared statements prevent SQL injection by separating query structure from data, and allow query plan caching for repeated execution with different parameters. Pattern: `conn.execute('MATCH (n:Person) WHERE n.age > $age RETURN n', {'age': param_value})`; the query is parsed once and executed multiple times with different parameters.",
    "source": "prepared_statements"
  },
  {
    "id": "oe_033",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "In Kuzu, how do you create and use a full-text search index with BM25, and what types of queries benefit from this index compared to exact string matching?",
    "ground_truth": "Create a full-text index using CREATE FULLTEXT INDEX on text columns; query using FULLTEXT MATCH or FTS functions. BM25 indexes accelerate relevance-ranked text searches (useful for document retrieval) and fuzzy matching better than exact string matching (LIKE), especially on large text fields with variable document lengths.",
    "source": "full_text_search_bm25"
  },
  {
    "id": "oe_034",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "Explain the difference between shortest path algorithms (single, all, weighted) in Kuzu, and describe a real-world use case for each.",
    "ground_truth": "Single shortest path returns one optimal path; all shortest paths returns all paths tied for shortest length; weighted considers edge weights for total cost. Use cases: single for GPS navigation (one route), all for analyzing multiple trade routes, weighted for minimum-cost network routing or transaction fee minimization.",
    "source": "shortest_path_algorithms"
  },
  {
    "id": "oe_035",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "When using UNION in a Kuzu Cypher query, what are the key differences between UNION and UNION ALL, and how does column ordering affect results?",
    "ground_truth": "UNION removes duplicate rows from combined result sets, while UNION ALL keeps all rows including duplicates. Column positions must match across queries being unioned; columns are matched by position, not name. UNION requires matching data types and counts on both sides.",
    "source": "cypher_clauses"
  },
  {
    "id": "oe_036",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "Describe how the STRUCT data type in Kuzu allows you to model complex properties, and provide an example of when you would use STRUCT instead of separate node tables.",
    "ground_truth": "STRUCT groups related properties into a single typed container (e.g., address with street, city, zip). Use STRUCT for tightly coupled properties that are always accessed together and don't need independent relationships, such as physical addresses or contact info; use separate tables when properties need individual relationships or querying.",
    "source": "data_types"
  },
  {
    "id": "oe_037",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "In Kuzu, how does the PROFILE command help with query optimization, and what metrics should you examine to identify performance bottlenecks?",
    "ground_truth": "PROFILE executes a query and returns execution plan details including operator costs, cardinality estimates, and actual execution times. Examine high-cost operators, cardinality mismatches (estimated vs. actual), and scan/join operators; these reveal if indexes are unused, plans are inefficient, or data statistics are stale.",
    "source": "query_optimization"
  },
  {
    "id": "oe_038",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "When modeling a property graph in Kuzu, what are the tradeoffs between storing information as node properties versus as separate nodes with relationships?",
    "ground_truth": "Node properties (STRUCT or simple types) are faster to query for single lookups and consume less memory; separate nodes enable querying across common values, support complex relationships, and improve query flexibility. Use properties for simple immutable data; use relationships when values appear in multiple contexts or need independent querying.",
    "source": "data_modeling"
  },
  {
    "id": "oe_039",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "Explain how the EXISTS subquery works in Kuzu Cypher for existence checking, and provide an example where EXISTS in a WHERE clause improves query efficiency over COUNT.",
    "ground_truth": "EXISTS returns true if a subquery produces any results, without materializing all rows. Use EXISTS in WHERE clauses for existence checks (e.g., `WHERE EXISTS { MATCH (n)-[r]->(m) }`); it's more efficient than COUNT > 0 because it can short-circuit once any result is found, avoiding full scan.",
    "source": "subqueries"
  },
  {
    "id": "oe_040",
    "domain": "opencypher_expert",
    "difficulty": "medium",
    "question": "In Kuzu, how do you use SKIP and LIMIT in combination with ORDER BY for pagination, and what performance considerations should you account for when paginating large result sets?",
    "ground_truth": "Combine ORDER BY with SKIP and LIMIT to implement pagination: `ORDER BY column SKIP offset LIMIT pageSize`. Performance issue: SKIP still processes all skipped rows before returning results; for large offsets, this is slow. Optimize using keyset pagination (filter by last seen value) or indexed ORDER BY columns to enable early termination.",
    "source": "cypher_clauses"
  },
  {
    "id": "oe_041",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "When using variable-length paths with the syntax MATCH (a)-[r*2..5]->(b) in Kuzu, explain why a WALK semantics differs from TRAIL semantics in terms of memory consumption and query result cardinality, and when would you choose one over the other?",
    "ground_truth": "WALK allows repeated nodes and edges, potentially resulting in exponentially larger result sets and higher memory usage, while TRAIL prevents edge repetition but allows node repetition. WALK is necessary when exploring all possible multi-hop paths regardless of cycles; TRAIL is preferred for discovering distinct relationship chains efficiently. Choose WALK for path enumeration tasks and TRAIL when analyzing connectivity patterns to avoid combinatorial explosion.",
    "source": "variable_length_paths_semantics"
  },
  {
    "id": "oe_042",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "In Kuzu, when writing a query with multiple MATCH clauses followed by an implicit GROUP BY, what is the critical difference in behavior between using a WITH clause versus directly returning aggregations, and how does this impact Cartesian product formation?",
    "ground_truth": "Multiple MATCH clauses without an intervening WITH clause can create implicit Cartesian products because all matches are evaluated in the same scope before aggregation. Using WITH after the first pattern match forces aggregation of that pattern's results before the next MATCH, breaking the Cartesian product chain and significantly improving performance. The implicit GROUP BY applies to the final RETURN, so WITH is essential for controlling aggregation scope and join semantics.",
    "source": "implicit_group_by_with_clause"
  },
  {
    "id": "oe_043",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "Explain how the Kuzu embedded graph database handles prepared statements differently from traditional SQL databases, including security implications and performance characteristics when executing parameterized queries through the Python API.",
    "ground_truth": "Kuzu's Python API supports parameterized queries which prevent Cypher injection attacks by separating query structure from parameter values at the driver level. Prepared statements in Kuzu benefit from query plan caching across multiple executions with different parameters, improving performance for repeated queries. Unlike server-based databases, Kuzu's embedded nature means parameter binding occurs in-process, eliminating network serialization overhead but requiring careful handling of complex types like STRUCT and LIST.",
    "source": "prepared_statements_python_api"
  },
  {
    "id": "oe_044",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "When designing a property graph schema in Kuzu, discuss the trade-offs between using STRUCT data types for nested attributes versus creating separate node tables with relationships, including implications for query complexity, index efficiency, and traversal performance.",
    "ground_truth": "STRUCT types provide faster attribute access with no join overhead and are more memory-efficient for immutable nested data, but cannot be indexed individually and restrict queries to exact value matching. Separate node tables enable relationship-based queries, support full-text search and vector indexes, and allow hierarchical traversals, but increase query complexity and require explicit joins. Use STRUCTs for fixed metadata (e.g., address components); use separate nodes for dynamic, queryable, or interconnected entities (e.g., users, documents).",
    "source": "schema_design_struct_vs_nodes"
  },
  {
    "id": "oe_045",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "Describe how Kuzu's shortest path algorithms (single vs. all) behave differently when weighted edges contain NULL values, and what query patterns should be used to handle such cases without introducing silent correctness errors.",
    "ground_truth": "Kuzu's weighted shortest path algorithms treat NULL weights as invalid edge weights and exclude those edges from path consideration; this differs from typical default weights and can produce unexpected results if NULL handling is not explicit. The ALL_SHORTEST_PATHS function returns all paths with equal minimum weight, potentially producing exponentially many results. Always validate weight distributions using PROFILE and explicitly filter or coalesce NULL weights before shortest path queries to avoid incomplete or misleading results.",
    "source": "shortest_path_null_weights"
  },
  {
    "id": "oe_046",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "When importing large CSV files using COPY FROM in Kuzu, explain how data type inference interacts with the SERIAL and UUID column types, and what happens when the CSV contains NULL or out-of-range values for these auto-generated types.",
    "ground_truth": "COPY FROM respects explicit schema definitions and will not auto-generate SERIAL or UUID values if the CSV provides explicit values; however, if a SERIAL column is populated from CSV, Kuzu updates the internal sequence counter. NULL values in SERIAL columns are invalid and cause import failure unless a DEFAULT is specified. UUID columns must contain valid UUID strings in the CSV or be explicitly NULL to trigger default generation; malformed UUIDs cause parse errors that require handling via transaction rollback and data cleaning.",
    "source": "copy_from_serial_uuid"
  },
  {
    "id": "oe_047",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "Explain the interaction between full-text search indexes (BM25) and graph traversals in Kuzu: can full-text search results be used directly in downstream MATCH clauses, and what are the performance implications of combining FTS filters with complex relationship patterns?",
    "ground_truth": "Full-text search results are returned as scored node identifiers and can be passed to subsequent MATCH clauses via WITH, but BM25 scoring is independent of graph topology. Combining FTS with complex relationship patterns requires careful query structure: filter text results first, then traverse relationships using those node identifiers to avoid scanning the entire graph. Performance depends on FTS result set size relative to full node count; if BM25 returns few candidates, downstream traversals are fast, but loose coupling between text relevance and graph structure can produce large intermediate result sets.",
    "source": "full_text_search_graph_integration"
  },
  {
    "id": "oe_048",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "In Kuzu, when using UNWIND to expand LIST or ARRAY columns into separate rows, explain how the semantics change when combined with aggregation functions in a subsequent RETURN clause, and when does implicit GROUP BY apply?",
    "ground_truth": "UNWIND creates a one-to-many row expansion, and if a subsequent aggregation function (COUNT, COLLECT, SUM, etc.) is used in RETURN without explicit GROUP BY, Kuzu applies implicit GROUP BY on all non-aggregated columns visible after UNWIND. This means if you UNWIND and then aggregate, grouping occurs at the row level after expansion, not at the original pre-UNWIND granularity. To control aggregation scope, use WITH after UNWIND to explicitly specify GROUP BY dimensions, otherwise results reflect the expanded cardinality.",
    "source": "unwind_implicit_group_by"
  },
  {
    "id": "oe_049",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "Discuss how HNSW vector indexes in Kuzu impact query planning and execution when combined with graph traversal predicates in a WHERE clause. What are the limitations when filtering vectors before or after traversal, and how should you structure such queries for optimal performance?",
    "ground_truth": "HNSW indexes enable approximate nearest-neighbor search but cannot be used to filter during relationship traversal\u2014vector similarity must be computed post-traversal or applied independently. Kuzu does not support pushdown of vector distance predicates into the traversal engine, so queries like MATCH (a)-[*]->(b) WHERE distance(a.embedding, query_vector) < threshold require fetching all path nodes first. Optimal structure: first match the graph pattern, then apply HNSW-indexed vector filters using WITH, or reverse the order (vector filter first, then traversal from result nodes) to minimize intermediate result sets and avoid Cartesian products.",
    "source": "hnsw_index_traversal_integration"
  },
  {
    "id": "oe_050",
    "domain": "opencypher_expert",
    "difficulty": "hard",
    "question": "When using ALTER TABLE to modify a node or relationship table schema in Kuzu (e.g., adding or removing columns), explain what happens to existing queries, indexes, and prepared statements, and whether query recompilation is necessary or automatic.",
    "ground_truth": "ALTER TABLE in Kuzu updates the schema metadata immediately, and prepared statements' cached query plans become stale if the altered table is referenced. Subsequent executions of prepared statements may fail or behave unexpectedly if they reference dropped columns or assume outdated column types. Indexes on altered columns are invalidated and must be manually dropped and recreated; Kuzu does not automatically recompile or update indexes. Best practice: avoid ALTER TABLE on frequently-queried tables in production; instead, create new tables and migrate data, or re-prepare statements after schema changes to force recompilation.",
    "source": "alter_table_prepared_statement_invalidation"
  }
]
