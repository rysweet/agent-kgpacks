{"id": "bi_001", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What is the primary file extension used for Azure Bicep files?", "ground_truth": "Azure Bicep files use the .bicep file extension. This distinguishes them from Azure Resource Manager (ARM) JSON templates and allows development tools to provide syntax highlighting and validation.", "source": "bicep_file_structure"}
{"id": "bi_002", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "How do you reference a local Bicep module within the same directory structure?", "ground_truth": "You use the 'module' keyword followed by a symbolic name and the relative file path using the @-symbol syntax, for example: module storageModule './storage.bicep'. The path is relative to the current file.", "source": "local_modules"}
{"id": "bi_003", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What command is used to preview deployment changes without actually deploying resources in Azure?", "ground_truth": "The 'what-if' operation is used to preview deployment changes. In Azure CLI, this is executed using 'az deployment group what-if' and in PowerShell using '-WhatIf' parameter with deployment cmdlets.", "source": "what_if_operations"}
{"id": "bi_004", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What is the purpose of the bicepconfig.json file in a Bicep project?", "ground_truth": "The bicepconfig.json file configures Bicep linter rules, module source definitions, and analyzer settings. It allows you to customize which linting rules are enabled, set their severity levels, and define module registry sources.", "source": "bicepconfig_linter"}
{"id": "bi_005", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "How do you declare a parameter in a Bicep file?", "ground_truth": "Parameters are declared using the 'param' keyword followed by the parameter name, data type, and optional default value, for example: param location string = 'eastus'. Parameters can include decorators for validation and metadata.", "source": "bicep_syntax"}
{"id": "bi_006", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What Azure service can be used to host and manage private Bicep modules?", "ground_truth": "Azure Container Registry (ACR) is used to host and manage private Bicep modules. Modules are published as OCI artifacts to ACR and referenced using the 'br:' (Bicep Registry) scheme.", "source": "private_module_registry"}
{"id": "bi_007", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What keyword is used to declare user-defined functions in Bicep?", "ground_truth": "The 'func' keyword is used to declare user-defined functions in Bicep. Functions allow you to create reusable logic within your Bicep files to avoid repetition and improve maintainability.", "source": "user_defined_functions"}
{"id": "bi_008", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "How do you conditionally deploy a resource in Bicep?", "ground_truth": "You use the 'condition' property on a resource declaration to control whether it is deployed, for example: resource storageAccount 'Microsoft.Storage/storageAccounts@2021-06-01' = if (deployStorage) { ... }. The condition evaluates to true or false.", "source": "conditional_deployment"}
{"id": "bi_009", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What is a deployment stack in Azure Bicep and what is its primary benefit?", "ground_truth": "A deployment stack is a resource that manages a collection of resources deployed from a Bicep template as a single unit. Its primary benefit is built-in lifecycle management, allowing you to easily update or delete all resources together while respecting dependencies.", "source": "deployment_stacks"}
{"id": "bi_010", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "How do you iterate over an array or count in Bicep?", "ground_truth": "You use the 'for' keyword with array syntax or the 'range()' function for loops. For example: resource storageAccounts 'Microsoft.Storage/storageAccounts@2021-06-01' = [for i in range(0, 3): {...}] creates multiple instances.", "source": "loops"}
{"id": "bi_011", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What is the syntax for referencing a secret from Azure Key Vault in a Bicep parameter file?", "ground_truth": "In a parameters file, use the '@Microsoft.KeyVault(vault name, secret name)' syntax to reference Key Vault secrets. For example: 'value': '@Microsoft.KeyVault(vault=/subscriptions/{id}/resourceGroups/{rg}/providers/Microsoft.KeyVault/vaults/{vaultName}, secret=secretName)'", "source": "keyvault_references"}
{"id": "bi_012", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What is the primary advantage of using template specs for Bicep templates?", "ground_truth": "Template specs allow you to package and version Bicep templates as resources in Azure, enabling centralized management and role-based access control. They simplify sharing and reusing templates across teams and subscriptions.", "source": "template_specs"}
{"id": "bi_013", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "How do you deploy a Bicep file using the Azure CLI?", "ground_truth": "Use the 'az deployment group create --resource-group <rg-name> --template-file <bicep-file>' command to deploy a Bicep file. You can also specify parameters using the '--parameters' flag for additional configuration.", "source": "deployment_patterns_cli"}
{"id": "bi_014", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What is the purpose of user-defined data types in Bicep?", "ground_truth": "User-defined data types in Bicep allow you to create custom type definitions to ensure consistency and reusability across your templates. They are declared using the '@export() metadata' decorator and the 'type' keyword for complex object structures.", "source": "user_defined_types"}
{"id": "bi_015", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What is Azure Verified Modules (AVM) and why is it important for Bicep development?", "ground_truth": "Azure Verified Modules are Microsoft-validated, production-ready Bicep modules available in the public registry. They provide best practices, consistent naming conventions, and comprehensive testing, reducing development time and improving infrastructure reliability.", "source": "azure_verified_modules"}
{"id": "bi_016", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "How do you reference a module from the Azure Bicep Registry?", "ground_truth": "You use the 'br:' (Bicep Registry) scheme to reference public modules, for example: module storageModule 'br/public:avm/res/storage/storage-account:1.0.0'. The syntax includes the registry, namespace, module path, and version.", "source": "registry_modules"}
{"id": "bi_017", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What is the purpose of deployment scripts in Bicep?", "ground_truth": "Deployment scripts allow you to execute PowerShell or Azure CLI scripts as part of your infrastructure deployment. They enable custom provisioning logic, data queries, or configuration tasks that cannot be performed by standard Azure Resource Manager operations.", "source": "deployment_scripts"}
{"id": "bi_018", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What are Azure Landing Zones and how does Bicep support them?", "ground_truth": "Azure Landing Zones are pre-built, opinionated architectures for establishing secure, scalable Azure environments. Bicep supports ALZ through modular templates that implement governance, networking, and identity patterns, simplifying enterprise-scale deployments.", "source": "azure_landing_zones"}
{"id": "bi_019", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "How do you deploy a Bicep template using GitHub Actions?", "ground_truth": "You use the 'Azure/arm-deploy' GitHub Action or 'Azure/CLI' action in a workflow file. The workflow authenticates to Azure using a service principal, then runs 'az deployment group create' or similar commands to deploy the Bicep template.", "source": "deployment_patterns_github"}
{"id": "bi_020", "domain": "bicep_infrastructure", "difficulty": "easy", "question": "What is the difference between variables and parameters in Bicep?", "ground_truth": "Parameters are inputs defined with the 'param' keyword and accepted at deployment time from users or parameter files. Variables are defined with the 'var' keyword and are computed values set within the template for internal use only, not user-configurable.", "source": "bicep_syntax"}
{"id": "bi_021", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "When deploying a Bicep file using the Azure CLI, what is the purpose of the --what-if parameter and what does it show without making actual changes?", "ground_truth": "The --what-if parameter performs a preview deployment showing what resources would be created, updated, or deleted without actually applying changes. It uses change analysis to display the impact of deployment, helping validate changes before committing them.", "source": "what_if_operations"}
{"id": "bi_022", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "Explain the difference between local modules and registry modules in Bicep, and describe when you would use each approach.", "ground_truth": "Local modules are stored in the same repository and referenced with relative paths, suitable for organization-specific infrastructure. Registry modules are published to Azure Container Registry or Bicep Registry and referenced by path, ideal for reusable components across multiple projects or teams.", "source": "modules_local_and_registry"}
{"id": "bi_023", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "What is the primary function of a bicepconfig.json file, and how does it influence Bicep file compilation and validation?", "ground_truth": "bicepconfig.json configures linter rules, module path aliases, and analyzer settings for a Bicep project. It controls which linter rules are enabled/disabled, severity levels, and module resolution behavior, ensuring consistent code quality across the team.", "source": "linter_rules_and_bicepconfig"}
{"id": "bi_024", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "How do deployment stacks in Azure provide lifecycle management benefits compared to traditional template deployments?", "ground_truth": "Deployment stacks manage the lifecycle of related resources as a single unit, supporting deny assignments to prevent deletion of protected resources and managing dependencies automatically. They enable safer updates and easier cleanup while preventing accidental resource removal.", "source": "deployment_stacks_with_lifecycle_management"}
{"id": "bi_025", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "Describe how user-defined data types in Bicep can improve code reusability and what syntax is used to declare them.", "ground_truth": "User-defined data types use the @type decorator to define custom object structures that can be reused across multiple parameters and outputs. They improve type safety and documentation by creating semantic types like 'VnetConfig' or 'SecurityConfig', reducing errors and enhancing readability.", "source": "user_defined_data_types_and_functions"}
{"id": "bi_026", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "What is the purpose of user-defined functions in Bicep, and provide an example of a scenario where they would be beneficial.", "ground_truth": "User-defined functions encapsulate reusable logic for transformations, calculations, or naming conventions across Bicep files. They reduce code duplication; for example, a function could standardize resource naming with environment and region prefixes, ensuring consistency across all deployments.", "source": "user_defined_data_types_and_functions"}
{"id": "bi_027", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "Explain how conditional deployment with the 'condition' property works in Bicep and provide a practical use case.", "ground_truth": "The 'condition' property on resources evaluates a boolean expression to determine if the resource should be deployed. A practical use case is conditionally deploying a production load balancer only when the environment parameter equals 'prod', allowing a single template to serve multiple environments.", "source": "conditional_deployment_and_loops"}
{"id": "bi_028", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "How do loops in Bicep (using 'copy' or 'for' syntax) improve infrastructure deployment efficiency, and what is a common use case?", "ground_truth": "Loops eliminate repetitive resource declarations by iterating over arrays or ranges to create multiple instances. A common use case is deploying multiple subnets or storage accounts with different names and properties from a single loop, reducing template complexity and maintenance burden.", "source": "conditional_deployment_and_loops"}
{"id": "bi_029", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "What are the security implications of using Key Vault parameter references in Bicep, and how does Azure handle these references during deployment?", "ground_truth": "Key Vault references allow Bicep to securely pass secrets without storing them in templates or parameters files. Azure retrieves the secret value directly from Key Vault during deployment without logging or exposing the actual value, ensuring secrets remain protected throughout the deployment process.", "source": "keyvault_parameter_references"}
{"id": "bi_030", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "Explain the relationship between template specs and Bicep, and describe the advantages of using template specs for deployment packaging.", "ground_truth": "Template specs are Azure resources that store and version Bicep templates, enabling RBAC-controlled access and centralized template management. They provide advantages like versioning, reusability across teams, and the ability to control who can deploy specific templates without sharing raw files.", "source": "template_specs"}
{"id": "bi_031", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "What is the purpose of deployment scripts in Bicep templates, and provide an example of when you would use one instead of native Azure resources.", "ground_truth": "Deployment scripts execute custom PowerShell or Bash code during template deployment to perform actions not supported by Azure resources. Examples include configuring application settings after deployment, calling external APIs, or integrating with on-premises systems.", "source": "deployment_scripts"}
{"id": "bi_032", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "How do Azure Verified Modules (AVM) differ from custom modules, and what governance benefits do they provide for enterprise deployments?", "ground_truth": "AVM are Microsoft-validated, production-ready modules following strict standards for security, testing, and documentation. They provide governance benefits including compliance assurance, consistent quality, regular updates, and support, reducing organizations' maintenance burden compared to custom modules.", "source": "azure_verified_modules"}
{"id": "bi_033", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "Describe how Azure Landing Zones leverage Bicep for infrastructure-as-code, and what is the advantage of this approach for enterprise cloud adoption?", "ground_truth": "Azure Landing Zones use Bicep to codify proven patterns for governance, security, and compliance across subscriptions and management groups. This approach enables repeatable, auditable, and maintainable infrastructure deployments at scale, ensuring consistency and reducing manual configuration errors.", "source": "azure_landing_zones_with_bicep"}
{"id": "bi_034", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "How does the private module registry (using Azure Container Registry) improve module management, and what authentication method is typically required?", "ground_truth": "A private module registry in ACR stores and versions organization-specific modules with role-based access control. Authentication typically uses managed identity or service principals, allowing secure retrieval of modules during deployments without exposing credentials in connection strings.", "source": "private_module_registry"}
{"id": "bi_035", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "Compare the deployment approaches using Bicep with Azure CLI, PowerShell, and GitHub Actions, highlighting trade-offs and suitable scenarios for each.", "ground_truth": "Azure CLI is lightweight and scriptable for simple deployments; PowerShell excels in enterprise environments with complex logic; GitHub Actions integrates CI/CD for automated deployments. Trade-offs include simplicity vs. capability, with GitHub Actions offering best automation for GitOps workflows.", "source": "deployment_patterns_cli_powershell_github"}
{"id": "bi_036", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "What metadata and decorators should be included in a Bicep module to ensure clarity and governance when shared in a private registry?", "ground_truth": "Include @description decorators for all parameters and outputs, @export decorator for module visibility, @metadata for additional details, and comments documenting version requirements and dependencies. This ensures other teams understand usage, constraints, and supported scenarios without ambiguity.", "source": "modules_local_and_registry"}
{"id": "bi_037", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "How can linter rules in bicepconfig.json be customized to enforce organizational naming conventions, and what is the impact on CI/CD pipelines?", "ground_truth": "Linter rules can be customized by setting rule IDs to warn or error levels in bicepconfig.json, and custom rules can be added using analyzers. This enforces naming standards in CI/CD, preventing non-compliant code from being merged and ensuring consistency across all deployments.", "source": "linter_rules_and_bicepconfig"}
{"id": "bi_038", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "Explain how outputs from one Bicep module can be used as inputs to another module, and what design pattern does this support.", "ground_truth": "Module outputs expose values that subsequent modules or templates can reference through variable assignment. This supports the composition pattern, allowing modules to be chained together to create complex infrastructure where each module depends on previous outputs, enabling clean separation of concerns.", "source": "modules_local_and_registry"}
{"id": "bi_039", "domain": "bicep_infrastructure", "difficulty": "medium", "question": "What validation checks does the 'az bicep build' command perform, and how can you integrate these checks into a pre-commit or CI/CD workflow?", "ground_truth": "'az bicep build' checks syntax, references, and type correctness, converting Bicep to ARM templates. Integration involves running this command in pre-commit hooks or CI/CD pipeline stages (GitHub Actions, Azure Pipelines) to catch errors before deployment, ensuring code quality.", "source": "deployment_patterns_cli_powershell_github"}
{"id": "bi_040", "question": "When deploying resources across multiple Azure regions using Bicep, how can you manage region-specific configurations and maintain code reusability?", "ground_truth": "Use parameters to define region-specific properties (SKUs, availability zones, disaster recovery settings) and leverage user-defined types to standardize regional configurations. Template specs or modules can be versioned per region, or parameterized conditionals can handle region-specific logic within a single template.", "domain": "bicep_infrastructure", "difficulty": "medium", "source": "conditional_deployment_and_loops"}
{"id": "bi_041", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "When deploying a Bicep module from a private Azure Container Registry (ACR) using the registry-based syntax, what authentication mechanism is automatically used by the Bicep CLI, and what are the prerequisites that must be configured in advance?", "ground_truth": "The Bicep CLI uses Azure CLI's cached credentials and the user's Azure identity (managed via `az login`) to authenticate against ACR. Prerequisites include the ACR must be accessible from the deployment context, the user must have AcrPull permissions on the ACR, and the module reference must follow the format `br:acrname.azurecr.io/bicep/module:tag`. If using in CI/CD, service principal credentials or managed identity must be configured.", "source": "private_module_registry"}
{"id": "bi_042", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "Explain the key differences in lifecycle management and update behavior between Deployment Stacks and traditional ARM template deployments, particularly regarding retained resources and what happens to resources during a stack update.", "ground_truth": "Deployment Stacks provide managed lifecycle with explicit retain/delete policies per resource, tracking managed resources separately from unmanaged ones, and supporting update deferred mode for safer updates. Traditional ARM templates use implicit deletion on removal and don't track management boundaries. Stacks allow selective resource retention during updates and provide atomic consistency guarantees, preventing orphaned resources.", "source": "deployment_stacks_lifecycle"}
{"id": "bi_043", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "You encounter a linter rule violation for missing descriptions on parameters in your Bicep file. How would you configure bicepconfig.json to suppress this specific rule globally, and what are the performance or maintainability implications of doing so?", "ground_truth": "Add a `rules` section in bicepconfig.json with `\"no-unused-parameters\": {\"level\": \"off\"}` or set it to `\"warning\"`. Suppressing rules reduces code quality enforcement and makes code less maintainable; descriptions are crucial for module consumers. Best practice is to fix violations rather than suppress them, or use appropriate severity levels and target specific scenarios rather than blanket suppression.", "source": "linter_rules_bicepconfig"}
{"id": "bi_044", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "When using user-defined data types (UDT) in Bicep, describe how type validation occurs at compile-time versus runtime, and what happens if a parameter of a custom data type is passed a value that matches the shape but has extra properties not defined in the type.", "ground_truth": "Type validation occurs at compile-time for structural shape matching, but extra properties are allowed at runtime due to JSON's flexibility\u2014Bicep doesn't enforce strict property restrictions. The ARM template output will include extra properties unless explicitly filtered. Type safety is based on declared properties only; to enforce strict property validation, you must manually validate in the template using functions like `contains()` or define output filters.", "source": "user_defined_data_types"}
{"id": "bi_045", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "How does the what-if operation (`--what-if` flag) interact with conditional deployment using `condition` properties and loops in Bicep, and what are the limitations when previewing complex nested module deployments?", "ground_truth": "What-if evaluates conditions at preview time and shows what would be created/modified/deleted based on current template evaluation. It processes loops correctly and shows changes for each iteration. Limitations include: what-if cannot detect all side effects from deployment scripts, may not accurately show changes in nested modules if conditions depend on outputs from parent deployments, and doesn't preview actual validation errors that occur during deployment. Nested module changes are shown but context-dependent conditions may not evaluate correctly.", "source": "what_if_operations"}
{"id": "bi_046", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "In a multi-environment Azure Landing Zone deployment using Bicep, describe the recommended pattern for managing environment-specific Key Vault references across subscriptions, including how to handle cases where the Key Vault exists in a different tenant.", "ground_truth": "Use reference() function with the full Key Vault resource ID in cross-subscription scenarios: `reference(resourceId(subscriptionId, resourceGroup, 'Microsoft.KeyVault/vaults/secrets', kvName, secretName), apiVersion).value`. For cross-tenant scenarios, this approach fails; instead, use deployment scripts or service principal authentication to fetch secrets pre-deployment. Azure Landing Zones pattern recommends centralizing Key Vaults in management subscription and using role-based access. Avoid hardcoding secret URIs; use the reference() syntax with proper RBAC and managed identities.", "source": "keyvault_parameter_references"}
{"id": "bi_047", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "When authoring a module for Azure Verified Modules (AVM) compatibility, what specific requirements must your Bicep module meet regarding outputs, metadata, parameter naming conventions, and linter configuration to pass AVM validation?", "ground_truth": "AVM modules require: standardized output structure with explicit naming conventions (e.g., `resourceId`, `name`, `outputs`), complete metadata annotations including `@description`, `@minLength`, `@maxLength`, bicepconfig.json with strict linter rules enabled (no suppressed rules), parameter names following `resourceXxx` or `xxxSettings` patterns, comprehensive README with examples, and compatibility with both CLI and bicepparam files. All parameters must have descriptions, and modules must use `@export` decorator for public modules. Failure to meet any requirement prevents AVM certification.", "source": "azure_verified_modules"}
{"id": "bi_048", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "Explain how conditional deployment combined with loop syntax affects the reference() function's ability to resolve dependencies, and what issues may arise when a conditionally-deployed resource is referenced in a loop by another conditionally-deployed resource.", "ground_truth": "When a resource with `condition` is inside a loop and referenced by another conditional resource, ARM template resolution requires explicit `dependsOn` declarations because the reference doesn't automatically establish the dependency chain. If the first resource's condition is false, the reference fails at deployment time even if the dependent resource is also conditional. Solution: use `reference()` with conditional evaluation logic or explicit `dependsOn: [condition && resourceSymbolicName[index].id]` pattern. Avoid relying on implicit references across conditional loops.", "source": "conditional_deployment_loops"}
{"id": "bi_049", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "When deploying Bicep templates via GitHub Actions with managed identity authentication, what are the security implications of using OIDC federation versus stored credentials, and how should you configure role assignments for least-privilege access in a multi-tenant Azure Landing Zone scenario?", "ground_truth": "OIDC federation is more secure (no credential storage, short-lived tokens, revokable at source) versus stored credentials which pose compromise risks. For multi-tenant ALZ: configure federated identity with GitHub as the trusted issuer, create managed identity per deployment environment, assign only required permissions (e.g., `Contributor` scoped to resource group or subscription, not management group), use conditional access policies. Store only the client ID in secrets. Avoid using service principals with stored secrets; use `azure/login@v1` with OIDC configuration.", "source": "deployment_patterns_github_actions"}
{"id": "bi_050", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "You need to deploy a complex Bicep template that includes a deployment script requiring a managed identity, referencing secrets from Key Vault, and executing in a private subnet. Describe the prerequisites, networking requirements, and potential failure modes you must account for.", "ground_truth": "Prerequisites: managed identity with Contributor role on the container instance resource group, Key Vault access policy or RBAC for the identity, private subnet with egress access to Azure Container Registry and Azure Storage (for script output). Networking: deployment script creates an ACI in a subnet; requires NSG rules allowing egress to ACR and Storage, or service endpoints configured. Failure modes: identity lacks Key Vault permissions (access denied), NSG blocks registry/storage access (timeout), managed identity scope too narrow, or script container image not accessible. Solution: use managed identity with proper RBAC, configure service endpoints/private endpoints, test identity permissions beforehand.", "source": "deployment_scripts"}
{"id": "bi_051", "domain": "bicep_infrastructure", "difficulty": "hard", "question": "In the context of Azure Landing Zone deployments using Bicep, explain how template specs provide advantages over direct Bicep registry deployments for governance, versioning, and cross-tenant scenarios, and identify any performance trade-offs.", "ground_truth": "Template specs provide: centralized governance (stored in a designated management subscription with access control), immutable versioning for compliance auditing, resource-level RBAC for template access, metadata and descriptions stored with the spec, and cross-tenant sharing via service principal authentication. Advantages over registry modules: templates are not re-compiled on each deployment, version rollback is explicit, and discovery is centralized. Trade-offs: additional storage cost, requires explicit versioning discipline, slightly higher deployment latency due to retrieval, and less suitable for rapid development iteration. Recommended for enforced ALZ patterns and multi-tenant governance.", "source": "template_specs"}
