{"id": "ke_001", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is the K2 compiler in Kotlin 2.x and what is one of its main advantages over the previous compiler?", "ground_truth": "The K2 compiler is Kotlin's new compiler architecture introduced in Kotlin 2.x. Its main advantages include faster compilation times, improved error messages, and better support for new language features like context receivers.", "source": "K2_compiler"}
{"id": "ke_002", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is a suspend function in Kotlin coroutines and what keyword is used to declare it?", "ground_truth": "A suspend function is a function that can be paused and resumed without blocking threads. It is declared using the 'suspend' keyword before the fun keyword, for example: suspend fun fetchData(): String.", "source": "suspend_functions"}
{"id": "ke_003", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is Kotlin Multiplatform (KMP) and name one platform it supports?", "ground_truth": "Kotlin Multiplatform (KMP) is a feature that allows writing code once and sharing it across multiple platforms. It supports Android, iOS, JVM, JavaScript (JS), WebAssembly (Wasm), and native targets via Kotlin/Native.", "source": "KMP_basics"}
{"id": "ke_004", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is a sealed class in Kotlin and what is its primary use case?", "ground_truth": "A sealed class is a class that can only be subclassed by classes defined within the same file or package. Its primary use is to represent restricted class hierarchies, enabling exhaustive when expressions for type-safe pattern matching.", "source": "sealed_classes"}
{"id": "ke_005", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is a data class in Kotlin and what three functions does the compiler automatically generate for it?", "ground_truth": "A data class is a class primarily designed to hold data. The compiler automatically generates equals(), hashCode(), and toString() functions, plus a copy() function and componentN() functions for destructuring.", "source": "data_classes"}
{"id": "ke_006", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is null safety in Kotlin and how does the question mark operator (?) help achieve it?", "ground_truth": "Null safety is Kotlin's type system feature that distinguishes nullable types from non-nullable types at compile time. The question mark operator (?) marks a type as nullable (e.g., String?), preventing null pointer exceptions at runtime.", "source": "null_safety"}
{"id": "ke_007", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is an extension function in Kotlin and how is it declared?", "ground_truth": "An extension function is a function added to an existing class without inheritance. It is declared by prefixing the function name with the receiver type, for example: fun String.isLongerThan(length: Int) = this.length > length.", "source": "extension_functions"}
{"id": "ke_008", "domain": "kotlin_expert", "difficulty": "easy", "question": "Name three scope functions in Kotlin and what they have in common.", "ground_truth": "Three scope functions are: let, apply, and run. They all execute a block of code within the context of an object, with 'let' and 'run' returning the block result, and 'apply' returning the object itself.", "source": "scope_functions"}
{"id": "ke_009", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is delegation in Kotlin and what keyword is used to delegate an interface implementation?", "ground_truth": "Delegation is a design pattern where an object forwards method calls to a helper object. In Kotlin, the 'by' keyword is used to delegate interface implementation, for example: class MyClass(helper: Helper) : MyInterface by helper.", "source": "delegation"}
{"id": "ke_010", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is variance in Kotlin generics and what are the two types of variance?", "ground_truth": "Variance in generics determines whether a generic type can accept subtypes or supertypes. Covariance (out) allows only reading values, and contravariance (in) allows only writing values.", "source": "generics_variance"}
{"id": "ke_011", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is an inline function in Kotlin and what is one main benefit of using inline functions?", "ground_truth": "An inline function is a function declared with the 'inline' keyword whose code is inserted at the call site instead of being called normally. A main benefit is eliminating function call overhead and enabling non-local returns from lambdas.", "source": "inline_functions"}
{"id": "ke_012", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is Flow in Kotlin coroutines and what does it represent?", "ground_truth": "Flow is a cold asynchronous data stream type in Kotlin coroutines. It represents a sequence of values computed asynchronously and is only executed when collected, making it lazy and memory-efficient.", "source": "flow"}
{"id": "ke_013", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is a Channel in Kotlin coroutines and how does it differ from Flow?", "ground_truth": "A Channel is a hot communication primitive that sends and receives values between coroutines. Unlike Flow (which is cold), Channel maintains a buffer and values are produced regardless of whether they are collected.", "source": "channels"}
{"id": "ke_014", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is structured concurrency in Kotlin coroutines and why is it important?", "ground_truth": "Structured concurrency ensures that coroutines are launched within a scope and all child coroutines complete before the scope exits. It is important because it prevents resource leaks, simplifies error handling, and ensures predictable lifecycle management.", "source": "structured_concurrency"}
{"id": "ke_015", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is a coroutine context in Kotlin and what are two main components it contains?", "ground_truth": "A coroutine context is a set of elements that define the behavior of a coroutine. Two main components are the dispatcher (which determines the thread), and the Job (which tracks the coroutine's lifecycle).", "source": "coroutine_context"}
{"id": "ke_016", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is StateFlow in Kotlin coroutines and what is its primary use case?", "ground_truth": "StateFlow is a hot Flow that always has a current value and emits only new values when they change. Its primary use case is managing and observing state changes in applications, especially in UI layer with MVVM architecture.", "source": "StateFlow"}
{"id": "ke_017", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is Compose Multiplatform and on which platforms can it be used?", "ground_truth": "Compose Multiplatform is JetBrains' declarative UI framework based on Jetpack Compose. It can be used to build UIs on Android, iOS, Desktop (Windows, macOS, Linux), and Web platforms from a single codebase.", "source": "Compose_Multiplatform"}
{"id": "ke_018", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is Kotlin/Native and what is its primary purpose?", "ground_truth": "Kotlin/Native is a technology that compiles Kotlin code to native binaries without requiring a JVM. Its primary purpose is enabling Kotlin development for iOS, macOS, Linux, Windows, and other native platforms.", "source": "Kotlin_Native"}
{"id": "ke_019", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is a context receiver in Kotlin 2.x and what problem does it solve?", "ground_truth": "A context receiver is a language feature that allows declaring implicit context parameters for functions using the 'context' keyword. It solves the problem of passing implicit context objects without cluttering function signatures with explicit parameters.", "source": "context_receivers"}
{"id": "ke_020", "domain": "kotlin_expert", "difficulty": "easy", "question": "What is Kotlin/Wasm and what is its primary advantage compared to Kotlin/JS?", "ground_truth": "Kotlin/Wasm is a compiler target that compiles Kotlin to WebAssembly (Wasm) for browser execution. Its primary advantage over Kotlin/JS is better performance due to Wasm's native bytecode format and closer proximity to machine code.", "source": "Kotlin_Wasm"}
{"id": "ke_021", "domain": "kotlin_expert", "difficulty": "medium", "question": "When migrating from K1 to K2 compiler, what is the primary compilation strategy change and what build.gradle.kts property enables K2?", "ground_truth": "K2 uses a single-pass compilation strategy instead of K1's multi-pass approach, improving performance. Enable it via `kotlin.experimental.tryK2 = true` in gradle.properties or `compilerOptions { languageVersion = LanguageVersion.KOTLIN_2_0 }` in build.gradle.kts.", "source": "K2_compiler_migration"}
{"id": "ke_022", "domain": "kotlin_expert", "difficulty": "medium", "question": "Explain the difference between StateFlow and SharedFlow in terms of state management and explain when you would use each in a ViewModel.", "ground_truth": "StateFlow is a state holder that always has a current value and emits only when state changes; use it for UI state in ViewModels. SharedFlow is a general-purpose flow for broadcasting events without state retention; use it for one-time events or multiple subscribers needing the same event stream.", "source": "flow_state_management"}
{"id": "ke_023", "domain": "kotlin_expert", "difficulty": "medium", "question": "What are context receivers in Kotlin 2.x and how do they differ from extension functions in terms of implicit scope?", "ground_truth": "Context receivers allow implicit parameters to be passed to functions without explicit receiver syntax. Unlike extension functions which require a specific receiver type as the implicit this, context receivers can declare multiple contexts that must be available in scope but don't determine which object the function is called on.", "source": "context_receivers"}
{"id": "ke_024", "domain": "kotlin_expert", "difficulty": "medium", "question": "In Kotlin coroutines, what is the relationship between a coroutine's Job and its parent scope, and what happens to child coroutines when a parent job is cancelled?", "ground_truth": "A Job is part of a CoroutineContext and forms a parent-child hierarchy within a scope. When a parent Job is cancelled, all child jobs are automatically cancelled through the structured concurrency principle, ensuring resources are properly cleaned up.", "source": "structured_concurrency"}
{"id": "ke_025", "domain": "kotlin_expert", "difficulty": "medium", "question": "Describe how sealed classes and data classes work together to create type-safe result wrappers, and what advantages this provides over using exceptions.", "ground_truth": "Sealed classes restrict inheritance to known subclasses, allowing exhaustive when expressions. Combined with data classes, they create type-safe algebraic data types (e.g., Result<T>). This provides compile-time exhaustiveness checking, makes success and error cases explicit in signatures, and enables pattern matching without try-catch overhead.", "source": "sealed_data_classes"}
{"id": "ke_026", "domain": "kotlin_expert", "difficulty": "medium", "question": "What is the purpose of the suspend keyword in Kotlin coroutines and why can't suspend functions be called from regular functions?", "ground_truth": "The suspend keyword marks a function as a suspension point that can be paused and resumed without blocking threads. Suspend functions can't be called from regular functions because they require a CoroutineContext to manage their lifecycle; they can only be called from other suspend functions or within a coroutine scope.", "source": "suspend_functions"}
{"id": "ke_027", "domain": "kotlin_expert", "difficulty": "medium", "question": "Explain the role of Dispatchers in coroutines and the trade-offs between Dispatchers.Main, Dispatchers.IO, and Dispatchers.Default.", "ground_truth": "Dispatchers determine which thread pool executes coroutine code. Dispatchers.Main runs on the UI thread (limited); Dispatchers.IO has unlimited threads optimized for blocking I/O (e.g., database, network); Dispatchers.Default has limited threads (CPU count) for CPU-intensive work. Misuse can cause ANRs or performance degradation.", "source": "coroutine_dispatchers"}
{"id": "ke_028", "domain": "kotlin_expert", "difficulty": "medium", "question": "What is variance in Kotlin generics and explain the difference between declaration-site variance (out/in) and use-site variance.", "ground_truth": "Variance describes subtype relationships for generic types. Declaration-site variance (out for covariance, in for contravariance) is specified in the type parameter definition; use-site variance (wildcards) is specified at the usage point. Declaration-site is more concise for APIs that consistently produce (out) or consume (in) values.", "source": "generics_variance"}
{"id": "ke_029", "domain": "kotlin_expert", "difficulty": "medium", "question": "In Kotlin Multiplatform, what is the role of expect/actual declarations and how do they facilitate code sharing?", "ground_truth": "expect declarations define platform-independent APIs in commonMain; actual declarations provide platform-specific implementations in platform-specific source sets (androidMain, iosMain, etc.). This allows shared business logic while accommodating platform differences without conditional compilation.", "source": "kotlin_multiplatform"}
{"id": "ke_030", "domain": "kotlin_expert", "difficulty": "medium", "question": "What are inline functions in Kotlin and what is the primary performance and type-safety benefit of using reified type parameters with them?", "ground_truth": "Inline functions copy their bytecode to call sites, avoiding function call overhead. Reified type parameters allow access to actual type information at runtime (normally erased for generics). This enables type-safe operations like `inline fun <reified T> fromJson(json: String): T` without passing Class<T> explicitly.", "source": "inline_functions"}
{"id": "ke_031", "domain": "kotlin_expert", "difficulty": "medium", "question": "Explain how scope functions (let, run, apply, also, with) differ in their return values and implicit this binding, and provide a use case for apply vs. run.", "ground_truth": "let/also return the lambda result; apply/with return the receiver. let receives the receiver as a parameter (it); others use implicit this. apply is ideal for object initialization (returns receiver); run is ideal for computing a value from an object (returns result). Example: `user.apply { age = 30 }.let { updateDatabase(it) }`.", "source": "scope_functions"}
{"id": "ke_032", "domain": "kotlin_expert", "difficulty": "medium", "question": "How does Kotlin's null safety system work with nullable types, and what is the difference between the safe call operator (?.) and the not-null assertion operator (!!).", "ground_truth": "Nullable types (Type?) distinguish null from non-null at compile time. The safe call operator (?.) returns null if the receiver is null, otherwise executes the call; it prevents NPEs. The not-null assertion operator (!!) throws NPE if the receiver is null; use it only when you're certain a value is non-null.", "source": "null_safety"}
{"id": "ke_033", "domain": "kotlin_expert", "difficulty": "medium", "question": "In Compose Multiplatform, what is the difference between expect/actual composables and conditional compilation, and when would you use each approach?", "ground_truth": "expect/actual composables use Kotlin's multiplatform mechanism for platform-specific UI implementations with a common interface. Conditional compilation uses platform-specific dependencies and source sets. Use expect/actual for significant platform differences; use conditionals for minor variations or dependencies.", "source": "compose_multiplatform"}
{"id": "ke_034", "domain": "kotlin_expert", "difficulty": "medium", "question": "Explain how delegation in Kotlin works and provide an example of when delegated properties are preferable to traditional getters/setters.", "ground_truth": "Delegation allows a property to delegate its getter/setter logic to another object via the `by` keyword. Delegated properties are preferable for lazy initialization (`by lazy`), observable properties (`observable`), or map-backed properties (`by map`) to avoid boilerplate and centralize reusable property logic.", "source": "delegation"}
{"id": "ke_035", "domain": "kotlin_expert", "difficulty": "medium", "question": "What are Kotlin channels and how do they differ from flows in terms of backpressure handling and cold vs. hot nature?", "ground_truth": "Channels are hot, point-to-point communication primitives that buffer values; they apply backpressure via configurable buffer strategies (rendezvous, buffered, unlimited). Flows are cold, multicast streams that are lazy and suspend collectors on demand. Channels suit actor patterns; flows suit reactive pipelines.", "source": "channels_communication"}
{"id": "ke_036", "domain": "kotlin_expert", "difficulty": "medium", "question": "How does extension function resolution work in Kotlin when there are both member functions and extension functions with the same signature?", "ground_truth": "Member functions always take precedence over extension functions during resolution. If a class has a member function, extension functions with the same signature are not called. This principle ensures encapsulation and prevents accidental shadowing of class behavior.", "source": "extension_functions"}
{"id": "ke_037", "domain": "kotlin_expert", "difficulty": "medium", "question": "In Kotlin/Native, what is the significance of garbage collection and memory management differences compared to the JVM, and how does this affect coroutine design?", "ground_truth": "Kotlin/Native uses reference counting instead of GC, making memory management more deterministic but requiring careful handling of circular references. Coroutines must avoid long-lived references that create reference cycles; use WeakReference or proper cancellation to prevent memory leaks.", "source": "kotlin_native"}
{"id": "ke_038", "domain": "kotlin_expert", "difficulty": "medium", "question": "What are the key differences between Kotlin/JS and Kotlin/JVM in terms of runtime capabilities, and what libraries require expect/actual implementations when targeting both?", "ground_truth": "Kotlin/JS runs on JavaScript engines with no native threading or file I/O; Kotlin/JVM has full threading and system access. Libraries like coroutines, serialization, and date-time often need expect/actual implementations because JavaScript has fundamentally different capabilities (single-threaded, async-only).", "source": "kotlin_js"}
{"id": "ke_039", "domain": "kotlin_expert", "difficulty": "medium", "question": "Explain the Gradle DSL property `kotlin.target.js.browser.webpackTask` and when you would configure it for KMP projects targeting browsers.", "ground_truth": "This Gradle DSL property configures webpack integration for Kotlin/JS browser targets in KMP projects. Configure it to customize webpack bundling, set dev-server options, or disable webpack when using alternative bundlers. It's essential for development (hot reload) and production builds.", "source": "gradle_dsl_js"}
{"id": "ke_040", "domain": "kotlin_expert", "difficulty": "medium", "question": "In Kotlin/Wasm, what are the primary advantages over Kotlin/JS, and what are the current limitations regarding coroutines and threading?", "ground_truth": "Kotlin/Wasm offers better performance and closer alignment with JVM semantics compared to Kotlin/JS. However, Wasm runs in a single-threaded sandbox with limited concurrency support; coroutines work but true parallelism and system threading are unavailable, requiring async/await patterns for I/O.", "source": "kotlin_wasm"}
{"id": "ke_041", "domain": "kotlin_expert", "difficulty": "hard", "question": "In Kotlin 2.x with the K2 compiler, what are the key differences in how context receivers interact with extension functions compared to the old compiler, and what performance implications does this have for high-frequency calls?", "ground_truth": "K2 compiler provides better inference and resolution of context receivers at compile time, reducing runtime overhead. Context receivers are now resolved during compilation rather than at dispatch time, eliminating the need for implicit parameter passing in extension functions. This means fewer allocations and faster call sites compared to the old compiler's deferred resolution strategy.", "source": "K2_compiler_context_receivers"}
{"id": "ke_042", "domain": "kotlin_expert", "difficulty": "hard", "question": "When migrating a large codebase to use Kotlin/Wasm, what are the critical considerations regarding coroutine context preservation and the limitations of structured concurrency in the Wasm runtime environment?", "ground_truth": "Kotlin/Wasm does not support true multithreading due to WebAssembly's single-threaded nature, requiring all coroutines to run on a single event loop. Structured concurrency works but context propagation must respect Wasm's synchronous execution model; tasks cannot be truly suspended across I/O boundaries like on JVM. This necessitates careful use of callbacks or JavaScript promises integration rather than traditional suspend functions.", "source": "Kotlin_Wasm_concurrency_constraints"}
{"id": "ke_043", "domain": "kotlin_expert", "difficulty": "hard", "question": "Explain the memory leak risks when using StateFlow in Android with a long-lived ViewModel, particularly in the context of scope functions and how to properly implement collection strategies to prevent them.", "ground_truth": "StateFlow holds a strong reference to its collectors. If you collect StateFlow directly in a lifecycle-aware scope (like lifecycleScope.launch) without proper cancellation, the collector remains alive even if the UI is destroyed, keeping the ViewModel and its StateFlow alive indefinitely. Use repeatOnLifecycle() or flowWithLifecycle() to ensure collection stops when the lifecycle is destroyed, properly releasing references.", "source": "StateFlow_lifecycle_memory_management"}
{"id": "ke_044", "domain": "kotlin_expert", "difficulty": "hard", "question": "In Compose Multiplatform, when using sealed classes to represent UI state with data class variants, what are the performance implications of pattern matching across different platforms, and how does the K2 compiler optimize these exhaustive when expressions?", "ground_truth": "K2 compiler generates optimized bytecode for sealed class pattern matching by creating jump tables instead of sequential if-else chains when possible. On Native/Wasm, this translates to direct branch prediction; on JS, sealed class hierarchies may require additional runtime checks. Exhaustive when expressions are verified at compile time, eliminating runtime overhead but performance depends on the target platform's compilation strategy.", "source": "sealed_class_pattern_matching_optimization"}
{"id": "ke_045", "domain": "kotlin_expert", "difficulty": "hard", "question": "What are the subtle differences in how variance modifiers (in/out) interact with inline reified type parameters in generic functions, and what compilation errors can arise from improper variance with reification?", "ground_truth": "Reified type parameters cannot have variance modifiers because reification requires the actual type to be known at runtime. Declaring `inline fun <reified out T>` is a compile error. Variance applies to use-site (declaration-site in classes) and affects type substitution; reified parameters bypass erasure but must be invariant. If you need variance, use non-reified parameters with appropriate bounds or separate the reified logic into overloads.", "source": "variance_reified_generics_interaction"}
{"id": "ke_046", "domain": "kotlin_expert", "difficulty": "hard", "question": "When using Kotlin/Native with delegation and inline functions, explain the memory layout implications and why delegated properties cannot always be inlined, and what workarounds exist for performance-critical code.", "ground_truth": "Delegated properties are implemented via KProperty objects, preventing inlining because the delegate needs a reference to the property metadata. In Kotlin/Native, this creates additional heap allocations. Workarounds include using inline value classes as delegates (avoiding property objects), using inline get/set without delegation, or using compiler intrinsics like @InlineOnly. The K2 compiler may optimize some patterns but full inlining of delegated properties remains impossible due to semantic requirements.", "source": "Native_delegation_inline_constraints"}
{"id": "ke_047", "domain": "kotlin_expert", "difficulty": "hard", "question": "In structured concurrency with coroutine channels, what are the deadlock risks when using rendezvous channels (capacity 0) with nested coroutine scopes, and how should you design your architecture to avoid them?", "ground_truth": "Rendezvous channels require both sender and receiver to be active simultaneously. If a child coroutine sends to a rendezvous channel while the parent waits on another operation, a deadlock occurs because the channel send suspends indefinitely. Prevent this by ensuring all channel operations happen in the same scope level, using buffered channels for cross-scope communication, or making channels non-blocking with tryReceive/trySend for timeout scenarios.", "source": "channel_deadlock_structured_concurrency"}
{"id": "ke_048", "domain": "kotlin_expert", "difficulty": "hard", "question": "How does the Gradle DSL for Kotlin Multiplatform projects handle transitive dependency resolution differently for Kotlin/JS and Kotlin/Native targets, and what edge cases can cause dependency hell?", "ground_truth": "Kotlin/JS uses npm-based resolution while Kotlin/Native uses Maven coordinates, creating separate dependency trees. A single Gradle dependency may resolve differently per target; Kotlin/JS may pull ES modules while Kotlin/Native pulls JVM jars for shared code. Edge cases include conflicting versions across targets, platform-specific artifacts with identical group:artifact, and metadata publication mismatches. Use dependencyResolution { } blocks to enforce consistent versions across targets.", "source": "KMP_gradle_transitive_dependencies"}
{"id": "ke_049", "domain": "kotlin_expert", "difficulty": "hard", "question": "Explain the interaction between coroutine dispatchers and Kotlin/Native's reference counting memory model, particularly how switching dispatchers can affect object lifetimes and garbage collection behavior.", "ground_truth": "Kotlin/Native uses reference counting (not GC), and switching dispatchers via withContext() may move coroutine execution to a different thread/worker. If a dispatcher change causes an object to outlive its owning scope, its reference count may never reach zero on the original thread, preventing immediate deallocation. Proper thread-local cleanup and avoiding cross-thread references are critical; use freezing to safely share objects between workers or keep objects bound to their original dispatcher thread.", "source": "Native_dispatcher_refcounting_interaction"}
{"id": "ke_050", "domain": "kotlin_expert", "difficulty": "hard", "question": "In Kotlin 2.x, how do data classes interact with null safety when implementing custom equals/hashCode via delegation, and what are the potential security and correctness implications for use as HashMap keys?", "ground_truth": "Data classes auto-generate equals/hashCode based on properties, but delegated properties may hide null values or produce inconsistent hashes if the delegate's getValue() behavior changes. If a data class property is nullable but the delegate can return different values on successive calls, hashCode consistency breaks, corrupting HashMap integrity. Always ensure delegated properties are immutable or use @Transient/@Suppress to exclude them; validate that nullable delegated properties maintain hash stability across mutations.", "source": "data_class_delegation_null_safety_security"}
{"id": "ke_051", "domain": "kotlin_expert", "difficulty": "hard", "question": "When implementing Flow operators with inline functions for backpressure-sensitive scenarios, what are the implications of using suspend functions inside inline lambdas, and how does this interact with the K2 compiler's inlining heuristics?", "ground_truth": "Suspend functions inside inline lambdas cannot be inlined because inlining a suspend function requires state machine generation per call site. K2 compiler will generate state machines for each inline lambda containing suspends, potentially bloating code. The tradeoff is: suspends in inline lambdas lose the inlining benefit but gain clarity; for backpressure, this is acceptable since collect() is already suspension-aware. Use non-inline higher-order functions for complex suspend logic to reduce bytecode bloat.", "source": "Flow_inline_suspend_K2_heuristics"}
