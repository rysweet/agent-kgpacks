{"id": "cs_001", "domain": "csharp", "difficulty": "easy", "question": "What are the main differences between value types and reference types in C#?", "ground_truth": "Value types store data directly in the variable (stack allocation), include struct, enum, and primitive types. Reference types store a reference to data (heap allocation), include class, interface, delegate, and string. Value types are copied by value, reference types by reference.", "source": "csharp_fundamentals"}
{"id": "cs_002", "domain": "csharp", "difficulty": "easy", "question": "What is the purpose of the async and await keywords in C#?", "ground_truth": "async marks a method as asynchronous, allowing it to use await. await suspends method execution until the awaited Task completes, freeing the thread for other work. This enables non-blocking I/O and responsive UIs without explicit thread management.", "source": "async_programming"}
{"id": "cs_003", "domain": "csharp", "difficulty": "easy", "question": "Explain the concept of nullable reference types introduced in C# 8.0.", "ground_truth": "Nullable reference types allow compile-time null-safety checks. By default, reference types become non-nullable. Use Type? to declare nullable references. Compiler warns about potential null dereferences, reducing NullReferenceException risks.", "source": "nullable_types"}
{"id": "cs_004", "domain": "csharp", "difficulty": "easy", "question": "What is the difference between IEnumerable and IQueryable?", "ground_truth": "IEnumerable executes queries in-memory using LINQ to Objects. IQueryable builds expression trees for provider interpretation, enabling database query translation. IQueryable inherits from IEnumerable and supports deferred execution with remote query optimization.", "source": "linq"}
{"id": "cs_005", "domain": "csharp", "difficulty": "easy", "question": "What are records in C# and when should you use them?", "ground_truth": "Records are reference types optimized for immutable data with value-based equality. Use for DTOs, value objects, and immutable models. They provide concise syntax for property initialization, with expressions, and built-in value equality.", "source": "records"}
{"id": "cs_006", "domain": "csharp", "difficulty": "easy", "question": "Explain the using statement and IDisposable pattern.", "ground_truth": "using ensures IDisposable objects are disposed at scope exit, releasing unmanaged resources. Implements try-finally pattern automatically. Objects implementing IDisposable (file handles, database connections) should be used in using statements or declaration patterns.", "source": "resource_management"}
{"id": "cs_007", "domain": "csharp", "difficulty": "easy", "question": "What is the difference between const and readonly?", "ground_truth": "const is compile-time constant, must be initialized at declaration, implicitly static. readonly is runtime constant, can be initialized in constructor, can be instance or static. const is for compile-time known values, readonly for runtime-determined values.", "source": "constants"}
{"id": "cs_008", "domain": "csharp", "difficulty": "easy", "question": "What are delegates and how do they relate to events?", "ground_truth": "Delegates are type-safe function pointers representing method signatures. Events are delegate wrappers providing publish-subscribe pattern with encapsulation. Events restrict external invocation and assignment, allowing only += and -= operations.", "source": "delegates_events"}
{"id": "cs_009", "domain": "csharp", "difficulty": "easy", "question": "Explain LINQ and its benefits.", "ground_truth": "LINQ (Language-Integrated Query) provides SQL-like syntax for querying collections. Benefits: type-safe queries, IntelliSense support, unified syntax across data sources, deferred execution, readable code. Works with IEnumerable, IQueryable, XML, and datasets.", "source": "linq"}
{"id": "cs_010", "domain": "csharp", "difficulty": "easy", "question": "What is the purpose of the yield keyword?", "ground_truth": "yield enables iterator implementation with deferred execution. yield return produces sequence elements one at a time. yield break ends iteration. Compiler generates state machine for efficient lazy evaluation without explicit IEnumerator implementation.", "source": "iterators"}
{"id": "cs_011", "domain": "csharp", "difficulty": "medium", "question": "How does the garbage collector work in .NET and what are the different generations?", "ground_truth": "GC uses generational algorithm: Gen 0 (short-lived objects, frequent collection), Gen 1 (buffer between short and long-lived), Gen 2 (long-lived objects, infrequent collection). Mark-and-sweep algorithm traces reachable objects, compacts memory. LOH (Large Object Heap) for objects >85KB.", "source": "garbage_collection"}
{"id": "cs_012", "domain": "csharp", "difficulty": "medium", "question": "Explain covariance and contravariance in C# with examples.", "ground_truth": "Covariance (out): allows derived types as output (IEnumerable<Derived> to IEnumerable<Base>). Contravariance (in): allows base types as input (Action<Base> to Action<Derived>). Used in generic interfaces and delegates for type flexibility while maintaining type safety.", "source": "variance"}
{"id": "cs_013", "domain": "csharp", "difficulty": "medium", "question": "What are expression trees and when would you use them?", "ground_truth": "Expression trees represent code as data structures (Abstract Syntax Trees). Used by IQueryable for query translation to SQL, by serializers, and for runtime code generation. Enable runtime code analysis and transformation. Created using lambda expressions or factory methods.", "source": "expression_trees"}
{"id": "cs_014", "domain": "csharp", "difficulty": "medium", "question": "Explain the Task Parallel Library (TPL) and its core concepts.", "ground_truth": "TPL provides Task-based asynchronous pattern, Parallel class for data/task parallelism, and PLINQ. Task represents async operation with cancellation and continuation support. TaskScheduler manages task execution. Supports async/await pattern, ConfigureAwait, and synchronization context.", "source": "tpl"}
{"id": "cs_015", "domain": "csharp", "difficulty": "medium", "question": "What are the different ways to create immutable objects in C#?", "ground_truth": "1) readonly fields with constructor initialization, 2) init-only properties (C# 9), 3) record types, 4) ImmutableCollection types, 5) with expressions for non-destructive mutation. Combine with private setters and defensive copying for true immutability.", "source": "immutability"}
{"id": "cs_016", "domain": "csharp", "difficulty": "medium", "question": "How do you implement proper async/await exception handling?", "ground_truth": "Use try-catch around await calls. Task exceptions are wrapped in AggregateException but await unwraps them. Use Task.WhenAll for multiple tasks and handle AggregateException.InnerExceptions. Consider cancellation tokens, timeouts, and ConfigureAwait(false) for library code.", "source": "async_exception_handling"}
{"id": "cs_017", "domain": "csharp", "difficulty": "medium", "question": "Explain pattern matching features in modern C#.", "ground_truth": "Pattern matching includes: type patterns, constant patterns, var patterns, property patterns, tuple patterns, positional patterns, and recursive patterns. Use with switch expressions, is expressions, and switch statements. Supports when guards and pattern combinators (and, or, not).", "source": "pattern_matching"}
{"id": "cs_018", "domain": "csharp", "difficulty": "medium", "question": "What are the best practices for using async/await with ConfigureAwait?", "ground_truth": "Use ConfigureAwait(false) in library code to avoid capturing synchronization context, improving performance and avoiding deadlocks. Use ConfigureAwait(true) or default in UI/ASP.NET code when context is needed. For ASP.NET Core, context capture is optimized, making ConfigureAwait less critical.", "source": "configureawait"}
{"id": "cs_019", "domain": "csharp", "difficulty": "medium", "question": "How do you implement the dispose pattern correctly?", "ground_truth": "Implement IDisposable with public Dispose() calling protected Dispose(bool disposing). Use disposing parameter to distinguish managed/unmanaged cleanup. Implement finalizer only if unmanaged resources exist. Call GC.SuppressFinalize in Dispose(). Follow CA1816 and CA1063 FxCop rules.", "source": "dispose_pattern"}
{"id": "cs_020", "domain": "csharp", "difficulty": "medium", "question": "Explain Span<T> and Memory<T> and their performance benefits.", "ground_truth": "Span<T> is stack-only ref struct for contiguous memory access without allocation. Memory<T> is heap-compatible alternative. Enable zero-copy slicing, stack/heap/native memory access. Avoid allocations in hot paths, improve cache locality. Used with stackalloc, ArrayPool, and string manipulation.", "source": "span_memory"}
{"id": "cs_021", "domain": "csharp", "difficulty": "hard", "question": "How does method dispatch work for virtual, abstract, and interface methods?", "ground_truth": "Virtual dispatch uses v-table lookup at runtime. Abstract methods require override in derived class. Interface methods use interface dispatch table. Default interface methods (C# 8) enable interface evolution. Explicit interface implementation avoids naming conflicts. Performance: direct call > virtual call > interface call.", "source": "method_dispatch"}
{"id": "cs_022", "domain": "csharp", "difficulty": "hard", "question": "Explain the differences between Task.Run, Task.Factory.StartNew, and creating Tasks manually.", "ground_truth": "Task.Run uses default scheduler for short CPU-bound work. Task.Factory.StartNew offers more control (TaskCreationOptions, scheduler) but requires unwrapping nested tasks. Manual Task creation with TaskCompletionSource for custom async operations. Prefer Task.Run for most cases; use StartNew for long-running with LongRunning option.", "source": "task_creation"}
{"id": "cs_023", "domain": "csharp", "difficulty": "hard", "question": "How do you prevent deadlocks when using async/await?", "ground_truth": "Avoid .Result/.Wait() which block synchronously. Use ConfigureAwait(false) in library code. Don't mix sync and async code. Use Task.WhenAny/WhenAll instead of waiting. Understand synchronization context in UI/ASP.NET. Use async all the way. Consider using AsyncLocal for context flow.", "source": "async_deadlocks"}
{"id": "cs_024", "domain": "csharp", "difficulty": "hard", "question": "Explain the C# compiler's lowering of async methods.", "ground_truth": "Compiler generates state machine (IAsyncStateMachine) with states for each await. MoveNext() method executes between awaits. Local variables become fields. try-catch blocks map to state transitions. Builder (AsyncTaskMethodBuilder) manages Task creation and completion. SetResult/SetException handle outcomes.", "source": "async_lowering"}
{"id": "cs_025", "domain": "csharp", "difficulty": "hard", "question": "What are the performance implications of closures and how can you optimize them?", "ground_truth": "Closures capture variables causing heap allocation of display class. Each unique capture creates new class. Minimize captured variables. Avoid capturing this or large contexts. Use static lambdas (C# 9) when possible. Consider manual parameter passing. Profile with BenchmarkDotNet to measure allocation impact.", "source": "closures_performance"}
{"id": "cs_026", "domain": "csharp", "difficulty": "hard", "question": "How does reflection impact performance and what are alternatives?", "ground_truth": "Reflection is slow due to metadata lookup, type checking, and boxing. Alternatives: 1) Source generators for compile-time code generation, 2) Expression trees compiled to delegates, 3) FastMember library, 4) IL generation with DynamicMethod, 5) Activator.CreateInstance caching. Consider AOT constraints.", "source": "reflection_performance"}
{"id": "cs_027", "domain": "csharp", "difficulty": "hard", "question": "Explain the differences between Monitor, Mutex, Semaphore, and lock in thread synchronization.", "ground_truth": "lock is syntactic sugar for Monitor (managed, thread-affinity, reentrant). Mutex is OS-level, cross-process, no thread-affinity. Semaphore limits concurrent access count. SemaphoreSlim is lightweight alternative. Monitor provides TryEnter/Wait/Pulse. lock generates try-finally with Monitor.Enter/Exit. ReaderWriterLockSlim for read-heavy scenarios.", "source": "synchronization"}
{"id": "cs_028", "domain": "csharp", "difficulty": "hard", "question": "What are the C# 11 and 12 required members and how do they improve type safety?", "ground_truth": "required modifier on properties/fields enforces initialization at object creation. Works with init-only properties. Compiler error if not set in object initializer or constructor. Improves null-safety for non-nullable reference types. Alternative to constructor parameters for large DTOs.", "source": "required_members"}
{"id": "cs_029", "domain": "csharp", "difficulty": "hard", "question": "How do you implement high-performance string manipulation in C#?", "ground_truth": "Use StringBuilder for multiple concatenations. Span<char> for stack allocation. string.Create for custom initialization. ArrayPool<char> for large buffers. StringBuilderCache for reuse. Avoid string.Substring (allocates). Use Memory<char> for pipelines. Consider source generators for compile-time strings.", "source": "string_performance"}
{"id": "cs_030", "domain": "csharp", "difficulty": "hard", "question": "Explain source generators and their use cases.", "ground_truth": "Source generators run during compilation, analyze code, generate additional C# files. Use cases: serialization without reflection, logging, INotifyPropertyChanged, regex, JSON parsing. Improve AOT compatibility. Implement ISourceGenerator or IIncrementalGenerator. Use Roslyn APIs for syntax analysis. Enable with <EnumerateItemsForPublish>true</EnumerateItemsForPublish>.", "source": "source_generators"}
{"id": "aspnet_001", "domain": "aspnet", "difficulty": "easy", "question": "What are the benefits of Minimal APIs in ASP.NET Core?", "ground_truth": "Minimal APIs reduce ceremony for simple APIs. Benefits: less boilerplate, faster startup, reduced memory footprint, easier learning curve. Use MapGet/MapPost/etc. for routing. Support filters, validation, OpenAPI. Best for microservices and simple APIs. Controllers better for complex scenarios.", "source": "minimal_apis"}
{"id": "aspnet_002", "domain": "aspnet", "difficulty": "easy", "question": "Explain dependency injection in ASP.NET Core.", "ground_truth": "ASP.NET Core has built-in DI container. Register services in Program.cs using AddSingleton (one instance), AddScoped (per request), AddTransient (per injection). Constructor injection preferred. Supports keyed services (C# 12). Use IServiceCollection for registration, IServiceProvider for resolution.", "source": "dependency_injection"}
{"id": "aspnet_003", "domain": "aspnet", "difficulty": "easy", "question": "What is middleware in ASP.NET Core and how does it work?", "ground_truth": "Middleware components form request pipeline. Each component can process request, call next middleware, or short-circuit. Configured in Program.cs using Use*/Map*/Run. Order matters. Built-in middleware: authentication, routing, static files, CORS. Custom middleware implements InvokeAsync.", "source": "middleware"}
{"id": "aspnet_004", "domain": "aspnet", "difficulty": "easy", "question": "What are the differences between Razor Pages and MVC?", "ground_truth": "Razor Pages: page-focused model, simpler for form-based UIs, one file per page (cshtml + PageModel). MVC: separation of concerns with controllers/views/models, better for complex routing, API endpoints. Both share routing, validation, Razor syntax. Choose based on application complexity.", "source": "razor_vs_mvc"}
{"id": "aspnet_005", "domain": "aspnet", "difficulty": "easy", "question": "How does routing work in ASP.NET Core?", "ground_truth": "Endpoint routing separates route matching from execution. UseRouting matches URLs to endpoints, UseEndpoints executes handlers. Convention-based (MVC) or attribute routing. Route templates use {parameter} syntax. Constraints validate parameters. Route precedence by specificity. Support for catch-all and optional parameters.", "source": "routing"}
{"id": "aspnet_006", "domain": "aspnet", "difficulty": "easy", "question": "What is the purpose of appsettings.json and how is configuration managed?", "ground_truth": "appsettings.json stores configuration hierarchically. Configuration sources: JSON files, environment variables, command-line args, user secrets. IConfiguration injected for access. Bind to POCO with IOptions pattern. Environment-specific files (appsettings.Development.json) override base. Use IOptionsSnapshot for reloading.", "source": "configuration"}
{"id": "aspnet_007", "domain": "aspnet", "difficulty": "easy", "question": "Explain the difference between authorization and authentication in ASP.NET Core.", "ground_truth": "Authentication verifies identity (who you are) using schemes like JWT, cookies, OAuth. Authorization determines access rights (what you can do) using policies, roles, claims. [Authorize] attribute enforces authorization. AddAuthentication/AddAuthorization configure services. Authentication must occur before authorization.", "source": "auth_vs_authz"}
{"id": "aspnet_008", "domain": "aspnet", "difficulty": "easy", "question": "What are hosted services and background workers in ASP.NET Core?", "ground_truth": "IHostedService enables background tasks in ASP.NET Core. BackgroundService base class simplifies implementation with ExecuteAsync. Registered with AddHostedService. Use cases: queue processing, scheduled tasks, cache refresh. Supports graceful shutdown with cancellation tokens. Runs independently of HTTP requests.", "source": "hosted_services"}
{"id": "aspnet_009", "domain": "aspnet", "difficulty": "easy", "question": "What is the purpose of Kestrel web server?", "ground_truth": "Kestrel is cross-platform, async web server for ASP.NET Core. Built on libuv/sockets. Production-ready, supports HTTP/1.1, HTTP/2, HTTP/3, WebSockets. Can run standalone or behind reverse proxy (IIS, nginx, Apache). Configured in Program.cs. Supports HTTPS, request limits, timeouts.", "source": "kestrel"}
{"id": "aspnet_010", "domain": "aspnet", "difficulty": "easy", "question": "How do you implement logging in ASP.NET Core?", "ground_truth": "ASP.NET Core uses ILogger interface with built-in providers (Console, Debug, EventSource). Configure in appsettings.json with LogLevel. Inject ILogger<T> for category logging. Support for structured logging. Third-party: Serilog, NLog. Use log scopes for correlation. Configure providers in Program.cs.", "source": "logging"}
{"id": "aspnet_011", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement response caching and output caching in ASP.NET Core?", "ground_truth": "Response caching: [ResponseCache] attribute or middleware, client-side caching via HTTP headers. Output caching (ASP.NET Core 7+): server-side caching of entire response, configured with AddOutputCache, UseOutputCaching. Supports vary-by headers, query strings. Distributed caching with Redis/SQL Server.", "source": "caching"}
{"id": "aspnet_012", "domain": "aspnet", "difficulty": "medium", "question": "Explain SignalR and its transport mechanisms.", "ground_truth": "SignalR enables real-time bi-directional communication. Hubs provide RPC-style API. Transport fallback: WebSockets (best), Server-Sent Events, Long Polling. Supports groups, strongly-typed hubs, streaming. Scale-out with Azure SignalR, Redis backplane. Use IHubContext for server-to-client messaging outside hubs.", "source": "signalr"}
{"id": "aspnet_013", "domain": "aspnet", "difficulty": "medium", "question": "What are action filters and how do you implement custom filters?", "ground_truth": "Filters execute code before/after action execution. Types: Authorization, Resource, Action, Exception, Result. Implement IActionFilter/IAsyncActionFilter. Attribute-based or global registration. Execution order: Authorization > Resource > Action > Exception > Result. Use for logging, validation, caching, transaction management.", "source": "action_filters"}
{"id": "aspnet_014", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement rate limiting in ASP.NET Core 7+?", "ground_truth": "Use built-in rate limiting middleware (ASP.NET Core 7+). Configure with AddRateLimiter, UseRateLimiter. Algorithms: fixed window, sliding window, token bucket, concurrency. Support for keyed limits (per user, IP). Apply via [EnableRateLimiting] attribute or policy. Customize with RateLimiterOptions for reject responses.", "source": "rate_limiting"}
{"id": "aspnet_015", "domain": "aspnet", "difficulty": "medium", "question": "What are the best practices for API versioning in ASP.NET Core?", "ground_truth": "Use Asp.Versioning.Mvc package. Strategies: URL path (/v1/api), query string (?api-version=1.0), header (api-version), media type. Configure with AddApiVersioning. Use [ApiVersion] attribute. Support version ranges, deprecated versions. Document with Swagger/OpenAPI. Sunset header for deprecation.", "source": "api_versioning"}
{"id": "aspnet_016", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement health checks in ASP.NET Core?", "ground_truth": "Use Microsoft.Extensions.Diagnostics.HealthChecks. Register with AddHealthChecks, map endpoint with MapHealthChecks. Built-in checks for SQL, Redis, Azure services. Custom checks implement IHealthCheck. Support for liveness, readiness, startup probes. Integration with Kubernetes, load balancers. UI with AspNetCore.HealthChecks.UI.", "source": "health_checks"}
{"id": "aspnet_017", "domain": "aspnet", "difficulty": "medium", "question": "Explain the request processing pipeline in detail.", "ground_truth": "Request flows through middleware pipeline: 1) Server (Kestrel) receives HTTP, 2) UseRouting matches endpoint, 3) Middleware executes (auth, CORS, etc.), 4) UseEndpoints executes matched endpoint, 5) Response middleware processes output, 6) Server sends response. Short-circuiting possible. Ordering critical for correctness.", "source": "request_pipeline"}
{"id": "aspnet_018", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement custom model binding in ASP.NET Core?", "ground_truth": "Implement IModelBinder interface with BindModelAsync method. Register with [ModelBinder] attribute or ModelBinderProviders. Access binding context for values. Support for complex types, collections. Use for custom types, format conversion. Alternative: use TypeConverter or JsonConverter for simpler scenarios.", "source": "model_binding"}
{"id": "aspnet_019", "domain": "aspnet", "difficulty": "medium", "question": "What are the security best practices for ASP.NET Core APIs?", "ground_truth": "Use HTTPS, validate input, prevent CSRF (antiforgery tokens), enable CORS selectively, implement authentication/authorization, use data protection APIs, secret management (user secrets, Azure Key Vault), rate limiting, security headers (CSP, HSTS), logging/monitoring, dependency scanning, SQL injection prevention with parameterized queries.", "source": "api_security"}
{"id": "aspnet_020", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement custom authentication schemes in ASP.NET Core?", "ground_truth": "Implement AuthenticationHandler<TOptions> extending AuthenticationHandler base class. Override HandleAuthenticateAsync to validate credentials and create ClaimsPrincipal. Register with AddAuthentication(scheme).AddScheme<TOptions, THandler>(). Configure default scheme. Support for challenges, forbid actions. Use for API keys, custom tokens, legacy systems.", "source": "custom_auth"}
{"id": "aspnet_021", "domain": "aspnet", "difficulty": "hard", "question": "How do you implement high-performance ASP.NET Core APIs with minimal allocations?", "ground_truth": "Use ValueTask over Task, Span<T>/Memory<T> for buffers, ArrayPool for pooling, PipeReader/PipeWriter for I/O, System.Text.Json with source generators, object pooling (ObjectPool), avoid LINQ in hot paths, use struct for small DTOs, async all the way, response compression, HTTP/2. Profile with BenchmarkDotNet, analyze allocations.", "source": "high_performance_apis"}
{"id": "aspnet_022", "domain": "aspnet", "difficulty": "hard", "question": "Explain gRPC in ASP.NET Core and when to use it over REST.", "ground_truth": "gRPC uses HTTP/2, Protocol Buffers, contract-first design. Benefits: performance (binary serialization), streaming (client/server/bidirectional), strong typing, code generation. Use for: microservices, real-time, polyglot systems, high-throughput. REST better for: browser clients, public APIs, flexibility. ASP.NET Core supports both.", "source": "grpc"}
{"id": "aspnet_023", "domain": "aspnet", "difficulty": "hard", "question": "How do you implement distributed tracing with OpenTelemetry in ASP.NET Core?", "ground_truth": "Use OpenTelemetry.Instrumentation.AspNetCore package. Configure with AddOpenTelemetry, instrument dependencies (HTTP, SQL, gRPC). Export to Jaeger, Zipkin, Azure Monitor, OTLP. Automatic context propagation with W3C Trace Context. Custom spans with Activity API. Correlate logs, metrics, traces with TraceId.", "source": "distributed_tracing"}
{"id": "aspnet_024", "domain": "aspnet", "difficulty": "hard", "question": "What are the strategies for deploying ASP.NET Core apps at scale?", "ground_truth": "Container-based deployment (Docker, Kubernetes), serverless (Azure Functions, AWS Lambda), load balancing (Azure Load Balancer, nginx), auto-scaling (KEDA, HPA), blue-green deployments, canary releases, health checks, circuit breakers (Polly), distributed caching (Redis), CDN for static content, database connection pooling, monitoring (Application Insights, Prometheus).", "source": "deployment_scale"}
{"id": "aspnet_025", "domain": "aspnet", "difficulty": "hard", "question": "How do you implement content negotiation and custom formatters in ASP.NET Core?", "ground_truth": "Content negotiation uses Accept header to select response format. Configure with AddControllers().AddXmlSerializerFormatters(). Custom formatters implement InputFormatter/OutputFormatter with ReadRequestBodyAsync/WriteResponseBodyAsync. Register in MvcOptions.InputFormatters/OutputFormatters. Support for XML, JSON, CSV, protobuf. Use MediaTypeHeaderValue for matching.", "source": "content_negotiation"}
{"id": "ef_001", "domain": "entity_framework", "difficulty": "easy", "question": "What are the different ways to load related data in Entity Framework Core?", "ground_truth": "Eager loading: .Include()/.ThenInclude() loads related entities in single query. Lazy loading: navigation properties loaded on access (requires proxies or lazy loading). Explicit loading: .Entry().Collection()/Reference().Load() manually loads. Split queries: separate related data queries. Choose based on N+1 query trade-offs.", "source": "loading_data"}
{"id": "ef_002", "domain": "entity_framework", "difficulty": "easy", "question": "Explain the difference between DbContext and DbSet in EF Core.", "ground_truth": "DbContext represents database session, manages entity lifecycle, tracks changes, executes queries, saves changes. DbSet<T> is collection-like property for entity type T, provides LINQ query interface. DbContext contains DbSet properties. Configure in OnModelCreating. Use DbContext for transactions, DbSet for querying.", "source": "dbcontext_dbset"}
{"id": "ef_003", "domain": "entity_framework", "difficulty": "easy", "question": "What is the purpose of migrations in EF Core?", "ground_truth": "Migrations manage database schema evolution. Create with Add-Migration, apply with Update-Database. Generate SQL with Script-Migration. Track schema changes in version control. Support for up/down migrations, custom SQL, seed data. Enable incremental database updates synchronized with model changes.", "source": "migrations"}
{"id": "ef_004", "domain": "entity_framework", "difficulty": "easy", "question": "How do you configure relationships in EF Core?", "ground_truth": "Convention-based: navigation properties auto-detected. Fluent API: HasOne/HasMany/WithOne/WithMany. Data annotations: [ForeignKey], [InverseProperty]. Configure cascade delete, required/optional, principal/dependent. Use shadow properties for foreign keys. Support for one-to-one, one-to-many, many-to-many relationships.", "source": "relationships"}
{"id": "ef_005", "domain": "entity_framework", "difficulty": "easy", "question": "What are the benefits of using AsNoTracking in EF Core?", "ground_truth": "AsNoTracking disables change tracking for read-only queries. Benefits: better performance, reduced memory usage, no identity resolution. Use for queries where entities won't be modified. Tracking useful for updates but has overhead. Global tracking behavior configurable in DbContext.", "source": "no_tracking"}
{"id": "ef_006", "domain": "entity_framework", "difficulty": "easy", "question": "How do you implement soft delete in EF Core?", "ground_truth": "Add IsDeleted bool property to entities. Configure query filter in OnModelCreating with HasQueryFilter(e => !e.IsDeleted). Override SaveChanges to set IsDeleted instead of removing. Explicit IgnoreQueryFilters() to query deleted entities. Alternative: DeletedAt timestamp for audit trail.", "source": "soft_delete"}
{"id": "ef_007", "domain": "entity_framework", "difficulty": "easy", "question": "What is the difference between Add and Attach in EF Core?", "ground_truth": "Add marks entity as Added (generates INSERT). Attach marks as Unchanged (no operation unless modified). Update marks as Modified (generates UPDATE for all properties). Use Add for new entities, Attach for existing entities without changes, Update for modified entities. Entry().State provides fine-grained control.", "source": "add_attach"}
{"id": "ef_008", "domain": "entity_framework", "difficulty": "easy", "question": "How do you execute raw SQL queries in EF Core?", "ground_truth": "FromSqlRaw/FromSqlInterpolated for queries returning entities. ExecuteSqlRaw/ExecuteSqlInterpolated for non-query commands (UPDATE, DELETE). Use parameterized queries to prevent SQL injection. Result entities must be part of model. Use SqlQuery for non-entity results (EF Core 8+).", "source": "raw_sql"}
{"id": "ef_009", "domain": "entity_framework", "difficulty": "medium", "question": "Explain the unit of work pattern as implemented in EF Core.", "ground_truth": "DbContext implements unit of work pattern, tracking all changes within a transaction boundary. SaveChanges commits changes atomically. ChangeTracker manages entity states. Automatic transaction management unless explicit BeginTransaction. Dispose context after unit of work completes. Supports rollback on exception.", "source": "unit_of_work"}
{"id": "ef_010", "domain": "entity_framework", "difficulty": "medium", "question": "How do you optimize EF Core queries for performance?", "ground_truth": "Use AsNoTracking for read-only, project with Select to load needed columns, split large queries, pagination with Skip/Take, indexes on frequent query columns, compiled queries for hot paths, avoid N+1 with Include, use AsSplitQuery for cartesian explosion, batch operations with EFCore.BulkExtensions, query plan caching.", "source": "query_optimization"}
{"id": "ef_011", "domain": "entity_framework", "difficulty": "medium", "question": "What are owned entity types in EF Core and when should you use them?", "ground_truth": "Owned entities are value objects without identity, always accessed through owner. Configure with OwnsOne/OwnsMany. Share table with owner (table splitting) or separate table. Use for DDD value objects, complex types. Can't be queried independently. Better encapsulation than primitive properties.", "source": "owned_entities"}
{"id": "ef_012", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement global query filters in EF Core?", "ground_truth": "Configure in OnModelCreating with HasQueryFilter. Automatically applied to all queries for entity type. Use cases: soft delete, multi-tenancy, active/inactive filtering. Access via IgnoreQueryFilters() when needed. Can reference DbContext properties for dynamic filtering. One filter per entity type.", "source": "query_filters"}
{"id": "ef_013", "domain": "entity_framework", "difficulty": "medium", "question": "Explain the different concurrency control strategies in EF Core.", "ground_truth": "Optimistic concurrency: timestamp/rowversion column or IsConcurrencyToken. Throws DbUpdateConcurrencyException on conflict. Pessimistic concurrency: database locks (SELECT FOR UPDATE) via raw SQL. Configure with [Timestamp] or IsRowVersion(). Handle conflicts by reloading, overwriting, or merging changes.", "source": "concurrency"}
{"id": "ef_014", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement table-per-hierarchy, table-per-type, and table-per-concrete type inheritance in EF Core?", "ground_truth": "TPH (default): single table with discriminator column. TPT: separate tables joined on primary key (UseTptMappingStrategy). TPC: separate tables with all properties (UseTpcMappingStrategy). TPH best performance, TPC most normalized. Configure discriminator with HasDiscriminator. EF Core 7+ supports TPC.", "source": "inheritance"}
{"id": "ef_015", "domain": "entity_framework", "difficulty": "medium", "question": "What are compiled queries and when should you use them?", "ground_truth": "Compiled queries cache expression tree translation for reuse. Use EF.CompileQuery/EF.CompileAsyncQuery. Benefit: skip query translation overhead on subsequent calls. Best for frequently executed queries with parameters. Limited value with query plan caching. Consider for hot paths with measurable impact.", "source": "compiled_queries"}
{"id": "ef_016", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement complex many-to-many relationships with payload in EF Core?", "ground_truth": "Create explicit join entity with additional properties. Configure with HasMany().WithMany() or explicit entity relationships. Access payload via join entity. Query using Select with join entity. EF Core 5+ supports automatic many-to-many without join entity. Use explicit entity when metadata needed on relationship.", "source": "many_to_many_payload"}
{"id": "ef_017", "domain": "entity_framework", "difficulty": "hard", "question": "Explain the change tracking internals and how to optimize it.", "ground_truth": "ChangeTracker uses snapshot-based tracking (original vs current values). DetectChanges called automatically before SaveChanges. Disable with AutoDetectChangesEnabled = false for manual control. Use Entry().State for explicit tracking. TrackGraph for graphs. ChangeTracker.Entries() inspects tracked entities. High memory overhead for large result sets; use AsNoTracking.", "source": "change_tracking_internals"}
{"id": "ef_018", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement database sharding with EF Core?", "ground_truth": "Multiple DbContexts with different connection strings. Routing logic determines shard based on key (tenant, geographic, hash). Elastic database tools for Azure SQL. Consider: cross-shard queries complexity, distributed transactions (saga pattern), schema synchronization, data migration. Use horizontal partitioning when vertical scaling insufficient.", "source": "sharding"}
{"id": "ef_019", "domain": "entity_framework", "difficulty": "hard", "question": "What are the best practices for EF Core in high-traffic applications?", "ground_truth": "Connection pooling (DbContext pooling with AddDbContextPool), compiled queries, no tracking for reads, projection over full entities, async/await, pagination, proper indexes, query splitting for cartesian products, avoid lazy loading, batch operations, caching at application layer (Redis), monitor with query tags, use database read replicas.", "source": "high_traffic_practices"}
{"id": "ef_020", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement temporal tables (system-versioned tables) in EF Core 6+?", "ground_truth": "Configure with ToTable(tb => tb.IsTemporal()). EF Core generates period columns (start/end timestamps). Query historical data with TemporalAsOf/TemporalFromTo/TemporalBetween/TemporalContainedIn/TemporalAll. Automatically manages history table. Supports all CRUD operations. Use for audit trail, point-in-time queries, compliance.", "source": "temporal_tables"}
{"id": "aspire_001", "domain": "aspire", "difficulty": "easy", "question": "What is .NET Aspire and what problems does it solve?", "ground_truth": ".NET Aspire is cloud-native development stack providing orchestration, service discovery, telemetry, health checks, and configuration management. Solves: local development complexity, configuration sprawl, service dependencies, observability setup. Includes dashboard for monitoring. Supports containers, Azure services, messaging.", "source": "aspire_overview"}
{"id": "aspire_002", "domain": "aspire", "difficulty": "easy", "question": "What are the main components of an Aspire application?", "ground_truth": "AppHost: orchestration project defining resources and dependencies. ServiceDefaults: shared configuration for telemetry, health checks, service discovery. Components: NuGet packages for integrations (databases, messaging, caching). Dashboard: observability UI. Projects: actual application services registered in AppHost.", "source": "aspire_components"}
{"id": "aspire_003", "domain": "aspire", "difficulty": "easy", "question": "How do you add service discovery to an Aspire app?", "ground_truth": "AppHost automatically configures service discovery. Reference services with AddReference(). Projects receive endpoint configuration via environment variables. Use service name in HTTP clients (e.g., http://apiservice). Works with HttpClientFactory. Supports multiple endpoints per service.", "source": "service_discovery"}
{"id": "aspire_004", "domain": "aspire", "difficulty": "easy", "question": "What is the Aspire Dashboard and what does it provide?", "ground_truth": "Web-based observability dashboard showing logs, traces, metrics, environment variables. Launched with AppHost. Distributed tracing with OpenTelemetry. Real-time log streaming. Metrics visualization. Resource health. Accessible at https://localhost:15888 by default. Useful for local development debugging.", "source": "dashboard"}
{"id": "aspire_005", "domain": "aspire", "difficulty": "easy", "question": "How do you add a PostgreSQL database to an Aspire app?", "ground_truth": "In AppHost: builder.AddPostgres('postgres').AddDatabase('mydb'). Reference in service: WithReference(postgres). Use AddNpgsqlDbContext in service project. Connection string automatically configured. Supports pgAdmin, pgvector. Container or connection string mode.", "source": "postgres_integration"}
{"id": "aspire_006", "domain": "aspire", "difficulty": "medium", "question": "How does telemetry work in Aspire applications?", "ground_truth": "ServiceDefaults project adds OpenTelemetry for logs, traces, metrics. Automatic instrumentation for ASP.NET Core, HttpClient, SQL. Export to OTLP, console, dashboard. Context propagation with W3C Trace Context. Custom spans with Activity API. Configure exporters for production (Azure Monitor, Jaeger).", "source": "telemetry"}
{"id": "aspire_007", "domain": "aspire", "difficulty": "medium", "question": "How do you implement external parameters for deployment in Aspire?", "ground_truth": "Use AddParameter in AppHost for secrets, connection strings. Parameters become manifest variables. Supply at deployment via Azure Developer CLI (azd), environment variables. Supports secret parameter type. Reference with parameter.Resource. Enables separation of dev/prod configuration.", "source": "external_parameters"}
{"id": "aspire_008", "domain": "aspire", "difficulty": "medium", "question": "What are Aspire components and how do you use them?", "ground_truth": "NuGet packages providing integrations with services. Install component package (Aspire.Azure.Storage.Blobs), register in DI (AddAzureBlobClient). Configure via AppHost (AddAzureStorage) or configuration. Include health checks, telemetry, resilience. Available for Azure, AWS, databases, messaging, caching.", "source": "aspire_components_usage"}
{"id": "aspire_009", "domain": "aspire", "difficulty": "medium", "question": "How do you deploy Aspire apps to Azure Container Apps?", "ground_truth": "Generate manifest with dotnet publish. Use azd (Azure Developer CLI) or Azure.Provisioning. AppHost generates Bicep/ARM templates. azd up provisions infrastructure and deploys. Supports managed identities, Azure services, auto-scaling. Configure with aspire.yaml. Integrated with Azure Developer Portal.", "source": "azure_deployment"}
{"id": "aspire_010", "domain": "aspire", "difficulty": "medium", "question": "How do you persist data with volumes in Aspire?", "ground_truth": "Use AddParameter for volume paths. WithBindMount() attaches host directory to container. WithVolume() creates named volume. Useful for database persistence, file storage. Configure in AppHost. Volume lifecycle managed by container runtime. Production: use managed services instead of volumes.", "source": "data_persistence"}
{"id": "aspire_011", "domain": "aspire", "difficulty": "hard", "question": "How do you implement custom Aspire components?", "ground_truth": "Create library with extension methods on IResourceBuilder. Implement IDistributedApplicationResourceWithConnectionString for connection propagation. Use AddResource<TResource>. Include health checks (IHealthCheck). Add telemetry configuration. Publish as NuGet. Follow naming: Aspire.[Category].[Service].", "source": "custom_components"}
{"id": "aspire_012", "domain": "aspire", "difficulty": "hard", "question": "What are the networking considerations for Aspire apps in production?", "ground_truth": "Service discovery via environment variables in prod. Configure ingress/egress rules. Use managed identities instead of connection strings. VNet integration for Azure services. Private endpoints for security. Configure CORS for cross-origin. Health check endpoints for load balancers. Consider service mesh for advanced scenarios.", "source": "production_networking"}
{"id": "aspire_013", "domain": "aspire", "difficulty": "hard", "question": "How do you implement testing strategies for Aspire applications?", "ground_truth": "Use DistributedApplicationTestingBuilder for integration tests. Test AppHost configuration. Spin up dependencies with Testcontainers. Use WaitFor for startup orchestration. Test service communication. Unit test components separately. Use HttpClient with service discovery. Consider test doubles for external services.", "source": "testing_aspire"}
{"id": "patterns_001", "domain": "patterns", "difficulty": "easy", "question": "What is Clean Architecture and what are its main principles?", "ground_truth": "Onion architecture with dependency inversion. Core domain at center, dependencies point inward. Layers: Domain (entities, value objects), Application (use cases, interfaces), Infrastructure (data access, external services), Presentation (UI, API). Benefits: testability, maintainability, framework independence.", "source": "clean_architecture"}
{"id": "patterns_002", "domain": "patterns", "difficulty": "easy", "question": "Explain the Repository pattern and its benefits in .NET.", "ground_truth": "Abstracts data access behind interface. Benefits: testability (mock repository), separation of concerns, centralized query logic, technology independence. Generic repository anti-pattern for complex scenarios. Use with Unit of Work pattern. EF Core DbContext is repository; additional abstraction often unnecessary.", "source": "repository_pattern"}
{"id": "patterns_003", "domain": "patterns", "difficulty": "easy", "question": "What is Dependency Injection and why is it important?", "ground_truth": "Design pattern for loose coupling via constructor injection. Inversion of Control container manages lifetimes. Benefits: testability (mock dependencies), flexibility, maintainability. ASP.NET Core DI lifetimes: singleton, scoped, transient. Resolves dependencies at runtime. Enables SOLID principles.", "source": "dependency_injection_pattern"}
{"id": "patterns_004", "domain": "patterns", "difficulty": "easy", "question": "Explain the CQRS pattern and when to use it.", "ground_truth": "Command Query Responsibility Segregation separates reads and writes. Commands modify state, queries return data. Benefits: optimized read/write models, scalability, different consistency requirements. Use with event sourcing. Adds complexity; use when read/write asymmetry exists. MediatR library for implementation.", "source": "cqrs"}
{"id": "patterns_005", "domain": "patterns", "difficulty": "medium", "question": "What is the Specification pattern and how does it help with querying?", "ground_truth": "Encapsulates query logic in reusable specifications. Implements ISpecification with IsSatisfiedBy or ToExpression. Benefits: reusable query logic, testable, composable (AND/OR/NOT). Use with repository pattern. Alternative to query methods proliferation. Ardalis.Specification library.", "source": "specification_pattern"}
{"id": "patterns_006", "domain": "patterns", "difficulty": "medium", "question": "Explain Vertical Slice Architecture and how it differs from layered architecture.", "ground_truth": "Organize by features/use cases instead of technical layers. Each slice contains all layers for one feature. Benefits: cohesion, parallel development, easier to understand. Trade-off: potential code duplication vs shared code. Use with MediatR for handlers. Better for feature-rich applications than traditional layering.", "source": "vertical_slice"}
{"id": "patterns_007", "domain": "patterns", "difficulty": "medium", "question": "What is the Result pattern and how does it improve error handling?", "ground_truth": "Replace exceptions with Result<T> or Result<T, TError> for expected errors. Success/failure states. Benefits: explicit error handling, performance (no exception throwing), functional composition. Use for validation, business rule failures. Libraries: FluentResults, LanguageExt. Compose with Match, Bind, Map.", "source": "result_pattern"}
{"id": "patterns_008", "domain": "patterns", "difficulty": "medium", "question": "How do you implement the Outbox pattern for reliable messaging?", "ground_truth": "Store messages in database table within same transaction as business operation. Background process reads outbox and publishes to message broker. Ensures atomic operations and message delivery. Prevents dual-write problem. Use with EF Core SaveChangesInterceptor. MassTransit and NServiceBus provide built-in support.", "source": "outbox_pattern"}
{"id": "patterns_009", "domain": "patterns", "difficulty": "medium", "question": "Explain the Decorator pattern in ASP.NET Core.", "ground_truth": "Wraps service to add behavior without modifying original. Register with Scrutor library or manual DI. Use cases: logging, caching, validation, retry logic. Implements same interface as decorated service. Chain multiple decorators. Alternative: middleware pattern for HTTP pipeline. Maintains Open/Closed Principle.", "source": "decorator_pattern"}
{"id": "patterns_010", "domain": "patterns", "difficulty": "hard", "question": "What is Domain-Driven Design and how do you implement it in .NET?", "ground_truth": "Strategic design: bounded contexts, ubiquitous language, context mapping. Tactical patterns: entities (with identity), value objects (immutable, no identity), aggregates (consistency boundary), domain events, repositories, domain services. Use EF Core for persistence. Avoid anemic domain model. Enforce invariants in domain layer.", "source": "ddd"}
{"id": "patterns_011", "domain": "patterns", "difficulty": "hard", "question": "How do you implement event sourcing in .NET?", "ground_truth": "Store domain events as source of truth instead of current state. Rebuild state by replaying events. Benefits: complete audit trail, temporal queries, event replay. Challenges: versioning, eventual consistency. Event store: EventStoreDB, SQL with append-only table. Snapshots for performance. Use with CQRS. Marten library for .NET.", "source": "event_sourcing"}
{"id": "patterns_012", "domain": "patterns", "difficulty": "hard", "question": "What is the Saga pattern for distributed transactions?", "ground_truth": "Orchestrates distributed transaction as sequence of local transactions. Choreography: events coordinate services. Orchestration: central coordinator manages flow. Compensating transactions for rollback. Use for eventual consistency across microservices. NServiceBus, MassTransit provide saga support. Avoid distributed transactions (2PC) when possible.", "source": "saga_pattern"}
{"id": "patterns_013", "domain": "patterns", "difficulty": "hard", "question": "How do you implement the Strangler Fig pattern for legacy modernization?", "ground_truth": "Incrementally replace legacy system by routing requests to new system. Proxy/facade intercepts calls, routes to old or new implementation. Gradually migrate features. Benefits: low risk, continuous delivery, parallel run. Use reverse proxy (YARP, nginx) or API gateway. Maintain data consistency during transition.", "source": "strangler_fig"}
{"id": "patterns_014", "domain": "patterns", "difficulty": "hard", "question": "What are the patterns for implementing resilience in distributed systems?", "ground_truth": "Retry with exponential backoff (Polly). Circuit breaker (open/half-open/closed states). Timeout. Bulkhead (isolate resources). Fallback. Rate limiting. Use Polly library for .NET. Configure policies in DI. Health checks for dependencies. Correlation IDs for tracing. Idempotency for safe retries.", "source": "resilience_patterns"}
{"id": "patterns_015", "domain": "patterns", "difficulty": "hard", "question": "How do you implement a modular monolith architecture in .NET?", "ground_truth": "Single deployable with logical modules (bounded contexts). Module independence via explicit contracts. Communication: in-process (MediatR, events) or message bus. Shared kernel minimized. Benefits: simpler than microservices, module autonomy, migration path to microservices. Vertical slices within modules. Use solution folders, assemblies for module boundaries.", "source": "modular_monolith"}
{"id": "cs_031", "domain": "csharp", "difficulty": "easy", "question": "What is boxing and unboxing in C#?", "ground_truth": "Boxing converts value type to object (heap allocation). Unboxing extracts value type from object (type check + copy). Performance cost: allocation, garbage collection. Avoid in hot paths. Use generics to prevent boxing. Struct in collection causes boxing without generic collections.", "source": "boxing_unboxing"}
{"id": "cs_032", "domain": "csharp", "difficulty": "easy", "question": "What are extension methods and how do you create them?", "ground_truth": "Static methods that extend existing types without modification. First parameter with 'this' modifier. Must be in static class. Resolved at compile-time. Use for fluent APIs, LINQ-style operations. Don't abuse for type pollution. Can't override existing methods.", "source": "extension_methods"}
{"id": "cs_033", "domain": "csharp", "difficulty": "medium", "question": "How do you implement custom iterators with yield?", "ground_truth": "yield return produces sequence elements lazily. yield break terminates iteration. Compiler generates state machine (IEnumerable/IEnumerator). Deferred execution until enumeration. Use for large sequences, infinite streams, custom LINQ operators. Can't use in try-catch with yield return.", "source": "custom_iterators"}
{"id": "cs_034", "domain": "csharp", "difficulty": "medium", "question": "What are the differences between ref, out, and in parameters?", "ground_truth": "ref: pass by reference, must initialize before call. out: pass by reference, must assign in method, don't need to initialize. in: read-only ref, prevents copying large structs. All avoid copying value types. Use in for performance with large readonly structs.", "source": "ref_params"}
{"id": "cs_035", "domain": "csharp", "difficulty": "hard", "question": "How does the C# type system handle variance with interfaces?", "ground_truth": "Covariance (out T): interface produces T, allows derived type substitution. Contravariance (in T): interface consumes T, allows base type substitution. Only for interfaces and delegates. Array covariance is built-in but type-unsafe. Generic collections use variance correctly (IEnumerable<out T>, IComparer<in T>).", "source": "type_variance"}
{"id": "aspnet_026", "domain": "aspnet", "difficulty": "easy", "question": "What is CORS and how do you configure it in ASP.NET Core?", "ground_truth": "Cross-Origin Resource Sharing allows browser requests from different domains. Configure with AddCors, UseCors. Specify allowed origins, methods, headers. Use named policies or default policy. Order: before UseAuthorization. Can use [EnableCors] attribute per controller/action.", "source": "cors"}
{"id": "aspnet_027", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement custom validation attributes in ASP.NET Core?", "ground_truth": "Inherit from ValidationAttribute, override IsValid method. Access ValidationContext for service resolution. Return ValidationResult with error message. Register as attribute [MyCustomValidation]. Can use IValidatableObject for complex object validation. Client-side validation requires JavaScript implementation.", "source": "custom_validation"}
{"id": "aspnet_028", "domain": "aspnet", "difficulty": "medium", "question": "What is the Options pattern and how do you use it?", "ground_truth": "Strongly-typed configuration binding to POCO classes. IOptions<T> for singleton access, IOptionsSnapshot<T> for scoped reloading, IOptionsMonitor<T> for change notifications. Configure with services.Configure<T>(). Supports validation with IValidateOptions. Use for app settings, feature flags.", "source": "options_pattern"}
{"id": "aspnet_029", "domain": "aspnet", "difficulty": "hard", "question": "How do you implement custom endpoint routing in ASP.NET Core?", "ground_truth": "Create custom IEndpointRouteBuilder extension. Use RouteEndpoint with RequestDelegate. Configure metadata with endpoint builder. Support for route constraints, parameter transformers. Use for framework-level routing extensions. Consider middleware for simpler scenarios.", "source": "custom_routing"}
{"id": "aspnet_030", "domain": "aspnet", "difficulty": "hard", "question": "What are the strategies for implementing API gateway patterns in ASP.NET Core?", "ground_truth": "Use YARP (Yet Another Reverse Proxy) for lightweight gateway. Ocelot for feature-rich API gateway. Implement: routing, aggregation, authentication, rate limiting, caching, transformation. Service discovery integration. Load balancing. Consider Azure API Management or Kong for production.", "source": "api_gateway"}
{"id": "ef_021", "domain": "entity_framework", "difficulty": "easy", "question": "What is the difference between First and Single in EF Core?", "ground_truth": "First returns first element, throws if empty. FirstOrDefault returns first or default. Single returns element, throws if zero or multiple. SingleOrDefault throws if multiple, returns default if empty. Use First for known non-empty, Single when expecting exactly one result.", "source": "first_vs_single"}
{"id": "ef_022", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement database seeding in EF Core?", "ground_truth": "Use HasData in OnModelCreating for static data. Use custom code in migrations for complex seeding. Override OnModelCreating for default values. Use DbContext.Database.EnsureCreated for testing. Production: use migrations with custom SQL or separate seed scripts.", "source": "seeding"}
{"id": "ef_023", "domain": "entity_framework", "difficulty": "medium", "question": "What are shadow properties in EF Core?", "ground_truth": "Properties in model not in entity class. Configured with Fluent API. Access via ChangeTracker.Entries or Property method. Use for: audit fields (CreatedAt, UpdatedBy), foreign keys without navigation properties, multi-tenancy (TenantId). Not accessible in LINQ without Property().", "source": "shadow_properties"}
{"id": "ef_024", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement the Repository pattern with Unit of Work in EF Core?", "ground_truth": "DbContext is Unit of Work, DbSet is repository. Additional abstraction often over-engineering. If needed: generic repository interface, concrete implementations, unit of work coordinating repositories. Use for: complex domain logic, testing abstraction, technology independence. Trade-off: added complexity vs EF Core capabilities.", "source": "repository_uow"}
{"id": "aspire_014", "domain": "aspire", "difficulty": "medium", "question": "How do you add Redis caching to an Aspire application?", "ground_truth": "In AppHost: AddRedis('redis'). In service: WithReference(redis), use AddRedisClient. Aspire component includes health checks, telemetry. Supports Redis Stack, Redis Cloud. Connection string auto-configured. Use IDistributedCache or StackExchange.Redis directly.", "source": "redis_aspire"}
{"id": "aspire_015", "domain": "aspire", "difficulty": "hard", "question": "How do you implement custom resource types in Aspire?", "ground_truth": "Implement IResource interface or extend ContainerResource. Create extension methods on IDistributedApplicationBuilder. Use AddResource<TResource>. Implement connection string provider. Add health checks, environment variables. Publish as NuGet for reuse. Follow Aspire naming conventions.", "source": "custom_resources"}
{"id": "patterns_016", "domain": "patterns", "difficulty": "medium", "question": "What is the Mediator pattern and how does MediatR implement it?", "ground_truth": "Mediator decouples components via central mediator. MediatR library for .NET: IRequest/IRequestHandler for commands/queries, INotification/INotificationHandler for events. Pipeline behaviors for cross-cutting concerns. Use with CQRS. Benefits: loose coupling, testability, single responsibility.", "source": "mediator_pattern"}
{"id": "patterns_017", "domain": "patterns", "difficulty": "hard", "question": "How do you implement the API Gateway aggregation pattern?", "ground_truth": "Gateway combines multiple backend calls into single response. Implement with parallel async calls (Task.WhenAll), response mapping, error handling. Use BFF (Backend for Frontend) pattern for client-specific aggregation. Consider GraphQL for flexible aggregation. Cache aggregated responses. Handle partial failures gracefully.", "source": "gateway_aggregation"}
{"id": "cs_036", "domain": "csharp", "difficulty": "medium", "question": "What are indexers and how do you implement them?", "ground_truth": "Allow array-like access to objects using []. Syntax: public T this[int index] { get; set; }. Can have multiple parameters. Use for collections, dictionary-like access. Can be overloaded with different parameter types. Common in custom collection classes.", "source": "indexers"}
{"id": "cs_037", "domain": "csharp", "difficulty": "hard", "question": "How do you implement the builder pattern with fluent interfaces in C#?", "ground_truth": "Methods return 'this' for chaining. Immutable builders use 'with' expressions. Validate in Build() method. Use for complex object construction. Consider record types with init properties as alternative. Library example: StringBuilder, IQueryable operations.", "source": "builder_fluent"}
{"id": "aspnet_031", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement file uploads in ASP.NET Core?", "ground_truth": "Use IFormFile parameter. Stream large files with MultipartReader. Validate size, type, content. Use antiforgery tokens. Store in blob storage (Azure, AWS). Limit max request size in Kestrel, IIS. Consider IFormFileCollection for multiple files. Security: scan for malware, sanitize filenames.", "source": "file_uploads"}
{"id": "aspnet_032", "domain": "aspnet", "difficulty": "hard", "question": "What is the difference between synchronous and asynchronous middleware?", "ground_truth": "Async middleware uses async Task Invoke(HttpContext) with await. Sync uses void Invoke(HttpContext). Async preferred for I/O operations. Don't mix sync over async (.Result, .Wait) - causes deadlocks. Use async all the way through pipeline. Sync middleware blocks thread pool threads.", "source": "async_middleware"}
{"id": "ef_025", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement bulk operations in EF Core?", "ground_truth": "Use EFCore.BulkExtensions library for bulk insert, update, delete. ExecuteUpdate/ExecuteDelete (EF Core 7+) for set-based operations. For large datasets: disable change tracking, batch SaveChanges, use raw SQL. Consider database bulk copy utilities for massive inserts.", "source": "bulk_operations"}
{"id": "ef_026", "domain": "entity_framework", "difficulty": "hard", "question": "How do you handle database connection resilience in EF Core?", "ground_truth": "Use EnableRetryOnFailure with SQL Server. Configure max retry count, delay. Implement execution strategy for custom retry logic. Handle transient faults. Use with distributed transactions carefully. Configure timeout settings. Monitor with logging. Azure SQL has built-in retry logic.", "source": "connection_resilience"}
{"id": "aspire_016", "domain": "aspire", "difficulty": "medium", "question": "How do you configure health checks in Aspire applications?", "ground_truth": "ServiceDefaults includes health checks automatically. Add custom checks with AddHealthChecks(). Aspire dashboard displays health status. Configure readiness, liveness probes for Kubernetes. Use for: database, Redis, message queue health. HTTP endpoint at /health.", "source": "health_checks_aspire"}
{"id": "patterns_018", "domain": "patterns", "difficulty": "medium", "question": "What is the Unit of Work pattern and when is it necessary with EF Core?", "ground_truth": "Maintains list of affected objects, coordinates writing changes. DbContext implements UoW pattern inherently. Additional UoW abstraction usually unnecessary. Needed when: coordinating multiple DbContexts, adding custom logic around SaveChanges, abstracting EF Core completely.", "source": "unit_of_work"}
{"id": "cs_038", "domain": "csharp", "difficulty": "easy", "question": "What are tuples and when should you use them?", "ground_truth": "Lightweight data structures for grouping values. ValueTuple<T1, T2> (struct, C# 7+). Named tuples: (string Name, int Age). Use for: multiple return values, temporary grouping, internal methods. Don't use for public APIs (prefer classes/records). Deconstruction: (var name, var age) = GetPerson().", "source": "tuples"}
{"id": "cs_039", "domain": "csharp", "difficulty": "medium", "question": "How do you implement object pooling in .NET?", "ground_truth": "Use ObjectPool<T> from Microsoft.Extensions.ObjectPool. Reduce allocations for expensive objects. Create with ObjectPool.Create(new DefaultPooledObjectPolicy<T>()). Return to pool in finally block. Use for: HTTP clients, database connections, large buffers. Don't pool for small objects (GC handles efficiently).", "source": "object_pooling"}
{"id": "cs_040", "domain": "csharp", "difficulty": "hard", "question": "What is ref struct and when should you use it?", "ground_truth": "Stack-only type that cannot be boxed or stored on heap. Use for: high-performance scenarios, spans, stack-based buffers. Can't be fields in classes, can't implement interfaces, can't be async. Example: Span<T>, ReadOnlySpan<T>. Enables safe stack allocation without pointers.", "source": "ref_struct"}
{"id": "aspnet_033", "domain": "aspnet", "difficulty": "easy", "question": "What is model binding in ASP.NET Core?", "ground_truth": "Automatically maps HTTP request data to action parameters. Sources: route data, query string, form data, body (JSON/XML). Uses [FromQuery], [FromRoute], [FromBody], [FromForm], [FromHeader]. Complex types bind from body by default in APIs. Configure with ModelBinderProviders.", "source": "model_binding_basics"}
{"id": "aspnet_034", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement WebSocket support in ASP.NET Core?", "ground_truth": "Use WebSocketManager to accept WebSockets. Check if request is WebSocket with IsWebSocketRequest. Call AcceptWebSocketAsync(). Use async loops for send/receive. Handle connection lifecycle. Consider SignalR for easier real-time communication. Raw WebSockets for full control, custom protocols.", "source": "websockets"}
{"id": "aspnet_035", "domain": "aspnet", "difficulty": "hard", "question": "How do you implement API throttling at the application level?", "ground_truth": "Use Microsoft.AspNetCore.RateLimiting (ASP.NET Core 7+). Configure fixed window, sliding window, token bucket, concurrency limiters. Apply via [EnableRateLimiting] or globally. Store state in distributed cache for scale-out. Alternative: middleware with AspNetCoreRateLimit library. Consider API Gateway for production.", "source": "api_throttling"}
{"id": "ef_027", "domain": "entity_framework", "difficulty": "easy", "question": "What is the purpose of the Include method?", "ground_truth": "Eager loads related entities in single query. ThenInclude for nested relationships. Prevents N+1 query problem. Use when related data always needed. Consider query splitting with AsSplitQuery for cartesian explosion. Alternative: explicit loading with Load(), lazy loading with proxies.", "source": "include_method"}
{"id": "ef_028", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement table splitting in EF Core?", "ground_truth": "Multiple entities map to same table. Use ToTable with same name. Share primary key. Configure relationships. Use for: vertical partitioning, separation of concerns, optional properties. Entities must be loaded together. Alternative: owned entity types.", "source": "table_splitting"}
{"id": "ef_029", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement custom value converters in EF Core?", "ground_truth": "Create ValueConverter<TModel, TProvider>. Override ConvertToProvider/ConvertFromProvider. Register with HasConversion(). Use for: enums to strings, serialization, encryption. Can be reused across entities. Configure comparison behavior for change tracking. Example: JSON serialization, date normalization.", "source": "value_converters"}
{"id": "aspire_017", "domain": "aspire", "difficulty": "easy", "question": "What is the Aspire Dashboard and what information does it show?", "ground_truth": "Web UI for observability during development. Shows: logs with filtering, distributed traces, metrics, structured logs, environment variables, resource status. Launched automatically with AppHost. Access at https://localhost:15888. Uses OpenTelemetry protocol. Real-time updates.", "source": "dashboard_overview"}
{"id": "aspire_018", "domain": "aspire", "difficulty": "medium", "question": "How do you configure SQL Server in Aspire applications?", "ground_truth": "In AppHost: AddSqlServer('sql').AddDatabase('mydb'). In service: WithReference(sql), use AddSqlClient or AddDbContext. Supports SQL Server Express, LocalDB, Azure SQL. Connection string auto-configured. Health checks included. Can use Azure SQL with managed identity.", "source": "sqlserver_aspire"}
{"id": "patterns_019", "domain": "patterns", "difficulty": "easy", "question": "What is the Factory pattern and when do you use it?", "ground_truth": "Encapsulates object creation logic. Factory method returns interface/base class. Use when: creation complex, multiple implementations, decouple creation from usage. Static factory methods (Create, Of) for simple cases. Abstract factory for families of related objects.", "source": "factory_pattern"}
{"id": "patterns_020", "domain": "patterns", "difficulty": "hard", "question": "How do you implement the CQRS pattern with separate read and write models?", "ground_truth": "Separate command (write) and query (read) models. Commands modify state, return void/result. Queries return data, never modify. Use MediatR for handlers. Optimize read models (denormalized, projections). Event sourcing optional. Sync models via domain events or message bus. Benefits: scalability, optimization, security.", "source": "cqrs_implementation"}
{"id": "cs_041", "domain": "csharp", "difficulty": "medium", "question": "What are local functions and when should you use them?", "ground_truth": "Functions defined inside other methods. Capture outer variables as closures. Use for: helper functions, recursive algorithms, iterator implementation. Can be static (C# 8+) to avoid closures. Better than lambdas for complex logic, named recursion. Compiled efficiently.", "source": "local_functions"}
{"id": "cs_042", "domain": "csharp", "difficulty": "hard", "question": "How does the C# compiler optimize async state machines?", "ground_truth": "Generates state machine struct implementing IAsyncStateMachine. MoveNext() executes states. Locals become fields. Try-catch blocks map to states. Caches awaiter to avoid allocations. Uses AsyncTaskMethodBuilder for Task management. Optimizations: cached tasks, pooled state machines, inline fast paths.", "source": "async_optimization"}
{"id": "aspnet_036", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement response streaming in ASP.NET Core?", "ground_truth": "Use Response.BodyWriter or Response.Body.WriteAsync. Return IAsyncEnumerable<T> for async streaming. Use StreamJsonAsync for JSON streaming. Enable buffering with EnableBuffering(). Useful for large responses, real-time data, memory efficiency. Consider compression trade-offs.", "source": "response_streaming"}
{"id": "aspnet_037", "domain": "aspnet", "difficulty": "hard", "question": "What are the strategies for implementing multi-tenancy in ASP.NET Core?", "ground_truth": "Strategies: separate databases, shared database with tenant column, separate schemas. Identify tenant from: URL, header, claim. Use query filters for row-level security. Scoped DbContext with tenant ID. Middleware to resolve tenant. Library: Finbuckle.MultiTenant. Consider: data isolation, performance, scaling.", "source": "multi_tenancy"}
{"id": "ef_030", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement stored procedure mapping in EF Core?", "ground_truth": "Use FromSqlRaw/FromSqlInterpolated for queries. ExecuteSqlRaw for non-query. Use HasDbFunction for scalar functions. EF Core 7+ supports stored procedure mapping in entity configuration with InsertUsingStoredProcedure/UpdateUsingStoredProcedure/DeleteUsingStoredProcedure. Output parameters supported.", "source": "stored_procedures"}
{"id": "ef_031", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement database-first development with EF Core?", "ground_truth": "Use Scaffold-DbContext command or dotnet ef dbcontext scaffold. Generates entity classes and DbContext from existing database. Specify provider, connection string, tables. Use -Force to overwrite. Customize with partial classes. Consider: reverse engineering overhead, schema drift, generated code conflicts.", "source": "database_first"}
{"id": "aspire_019", "domain": "aspire", "difficulty": "medium", "question": "How do you add RabbitMQ messaging to Aspire applications?", "ground_truth": "In AppHost: AddRabbitMQ('rabbitmq'). In service: WithReference(rabbitmq), use AddRabbitMQClient. Aspire component includes health checks, telemetry. Supports management UI. Connection string auto-configured. Use with MassTransit or RabbitMQ.Client directly.", "source": "rabbitmq_aspire"}
{"id": "aspire_020", "domain": "aspire", "difficulty": "hard", "question": "How do you implement environment-specific configuration in Aspire?", "ground_truth": "Use AddParameter for parameterized values. External parameters in manifest become deployment variables. Use Azure Developer CLI (azd) parameter files. Environment variables override defaults. User secrets for local development. Azure Key Vault for production secrets. Configure per-environment in azd.", "source": "env_config_aspire"}
{"id": "patterns_021", "domain": "patterns", "difficulty": "medium", "question": "What is the Strategy pattern and how do you implement it in .NET?", "ground_truth": "Define family of algorithms, encapsulate each, make interchangeable. Interface IStrategy with implementations. Inject via DI. Use for: payment methods, validation strategies, pricing rules. Alternative: delegates/Func for simple cases. Benefits: open/closed principle, testability, runtime selection.", "source": "strategy_pattern"}
{"id": "cs_043", "domain": "csharp", "difficulty": "easy", "question": "What is the difference between abstract classes and interfaces?", "ground_truth": "Abstract class: can have implementation, single inheritance, fields, constructors. Interface: contract only (but default implementations in C# 8+), multiple inheritance, no fields. Use interface for contracts, abstract class for shared implementation. Prefer composition over inheritance.", "source": "abstract_vs_interface"}
{"id": "cs_044", "domain": "csharp", "difficulty": "medium", "question": "How do you implement the Dispose pattern with IAsyncDisposable?", "ground_truth": "Implement IAsyncDisposable with DisposeAsync() method. Use await using for automatic disposal. Async disposal for async cleanup (close connections, flush streams). Can implement both IDisposable and IAsyncDisposable. Dispose pattern: call DisposeAsync from Dispose if needed. Finalizer considerations.", "source": "async_disposable"}
{"id": "aspnet_038", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement content negotiation with custom media types?", "ground_truth": "Add formatters with AddControllers().AddXmlSerializerFormatters() or custom. Create InputFormatter/OutputFormatter for custom types. Client specifies Accept header. Use Produces attribute to advertise supported types. ProducesResponseType for OpenAPI. Consider: CSV, protobuf, MessagePack formatters.", "source": "content_negotiation_custom"}
{"id": "aspnet_039", "domain": "aspnet", "difficulty": "hard", "question": "How do you implement distributed session state in ASP.NET Core?", "ground_truth": "Use AddDistributedMemoryCache (in-process) or Redis/SQL Server for distributed. Configure with AddSession, UseSession. Session stored in cookie or distributed cache. Set timeout, cookie options. Alternative: JWT claims for stateless. Consider: scalability, performance, security. Use for authentication state, shopping carts.", "source": "distributed_session"}
{"id": "ef_032", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement pessimistic locking in EF Core?", "ground_truth": "Use database-specific locking hints with FromSqlRaw: SELECT * FROM Table WITH (UPDLOCK, ROWLOCK). No built-in EF Core support. Lock held until transaction commits. Alternative: optimistic concurrency with timestamps. Consider: deadlocks, lock escalation, transaction isolation levels.", "source": "pessimistic_locking"}
{"id": "ef_033", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement database sharding strategies with EF Core?", "ground_truth": "Multiple DbContext instances with different connection strings. Route based on shard key (tenant ID, hash). Implement DbContext factory. Consider: elastic database tools (Azure), query router, cross-shard queries complexity. Alternative: read replicas for read scaling. Horizontal partitioning at database level.", "source": "sharding_strategies"}
{"id": "aspire_021", "domain": "aspire", "difficulty": "medium", "question": "How do you add MongoDB to Aspire applications?", "ground_truth": "In AppHost: AddMongoDB('mongo').AddDatabase('mydb'). In service: WithReference(mongo), use AddMongoClient. Connection string auto-configured. Supports MongoDB Atlas. Health checks included. Use with official MongoDB.Driver. Can specify version, persistence.", "source": "mongodb_aspire"}
{"id": "patterns_022", "domain": "patterns", "difficulty": "hard", "question": "How do you implement the Backends for Frontends (BFF) pattern?", "ground_truth": "Separate backend per frontend type (web, mobile, desktop). Each BFF tailored to client needs. Implement as API gateway or separate service. Benefits: client-specific optimization, reduced chattiness, security. Use with aggregation, transformation. Consider: code duplication, maintenance overhead. YARP or separate ASP.NET Core apps.", "source": "bff_pattern"}
{"id": "cs_045", "domain": "csharp", "difficulty": "medium", "question": "What are default interface methods and when should you use them?", "ground_truth": "Interfaces can have default implementations (C# 8+). Enables interface evolution without breaking implementations. Override explicitly in classes. Use for: library versioning, optional behavior. Limitations: no fields, no protected. Not same as abstract class. Multiple inheritance of behavior possible.", "source": "default_interface_methods"}
{"id": "aspnet_040", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement tag helpers in ASP.NET Core?", "ground_truth": "Extend TagHelper class, override Process/ProcessAsync. Target HTML elements with [HtmlTargetElement]. Access properties with [HtmlAttributeName]. Register in _ViewImports.cshtml with @addTagHelper. Use for: custom HTML generation, form helpers, conditional rendering. Built-in: asp-for, asp-action, asp-route.", "source": "tag_helpers"}
{"id": "aspnet_041", "domain": "aspnet", "difficulty": "hard", "question": "What are the strategies for handling versioning in microservices?", "ground_truth": "API versioning: URL, header, query string. Service versioning: semantic versioning, blue-green deployment, canary releases. Schema versioning: backward compatibility, Postel's law. Use contracts, event versioning. Consider: API gateway routing, service mesh. Libraries: Asp.Versioning, Consul for service discovery.", "source": "microservice_versioning"}
{"id": "ef_034", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement soft delete with query filters?", "ground_truth": "Add IsDeleted bool to entities. Configure global query filter: modelBuilder.Entity<T>().HasQueryFilter(e => !e.IsDeleted). Override SaveChanges to set IsDeleted instead of deleting. Use IgnoreQueryFilters() to query all. Alternative: use DeletedAt timestamp. Include audit fields (DeletedBy, DeletedAt).", "source": "soft_delete_filters"}
{"id": "ef_035", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement GraphQL with EF Core?", "ground_truth": "Use HotChocolate library for GraphQL server. Configure with AddGraphQLServer(). Use IQueryable projections for efficient queries. Implement DataLoader for N+1 prevention. Pagination with cursor-based or offset. Filtering, sorting with HotChocolate filtering. Mutations with EF Core. Monitoring with Apollo tracing.", "source": "graphql_efcore"}
{"id": "aspire_022", "domain": "aspire", "difficulty": "hard", "question": "How do you implement custom telemetry exporters in Aspire?", "ground_truth": "Configure OpenTelemetry in ServiceDefaults. Add exporters with AddOtlpExporter, AddConsoleExporter, AddAzureMonitorExporter. Custom exporters implement BaseExporter<T>. Configure via environment variables or code. Support for Jaeger, Zipkin, Prometheus. Sampling, filtering strategies. Correlation with distributed tracing.", "source": "custom_telemetry"}
{"id": "patterns_023", "domain": "patterns", "difficulty": "medium", "question": "What is the Bulkhead pattern and how do you implement it?", "ground_truth": "Isolate resources to prevent cascade failures. Separate thread pools, connection pools per service. Polly library: AsyncBulkheadPolicy. Limit concurrent operations. Use for: resilience, resource isolation. Configure max parallelization, queue length. Circuit breaker works complementary. Kubernetes: resource limits, pod quotas.", "source": "bulkhead_pattern"}
{"id": "cs_046", "domain": "csharp", "difficulty": "hard", "question": "How do you implement zero-allocation parsing with Span<T>?", "ground_truth": "Use ReadOnlySpan<char> for string parsing. Span<T> methods: Slice, IndexOf, TrySplit. Avoid string.Split (allocates array). Use int.TryParse(span, out result). stackalloc for small buffers. Use ArrayPool for large buffers. Benefits: no GC pressure, high throughput. Use BenchmarkDotNet to measure.", "source": "zero_allocation_parsing"}
{"id": "aspnet_042", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement request/response compression?", "ground_truth": "Use Response Compression Middleware with AddResponseCompression, UseResponseCompression. Supports Gzip, Brotli. Configure compression level, MIME types. Disable for HTTPS + CRIME attacks consideration. Request decompression (ASP.NET Core 7+) with UseRequestDecompression. Check Accept-Encoding header. Consider CDN compression.", "source": "compression"}
{"id": "aspnet_043", "domain": "aspnet", "difficulty": "hard", "question": "How do you implement custom model binders for complex types?", "ground_truth": "Implement IModelBinder with BindModelAsync. Register with [ModelBinder(typeof(MyBinder))] or ModelBinderProviders. Access ValueProvider for request data. Create ModelBindingResult. Use for: custom formats, complex parsing, special headers. Example: parsing CSV, custom date formats, encrypted values.", "source": "custom_model_binders"}
{"id": "ef_036", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement audit logging in EF Core?", "ground_truth": "Override SaveChanges/SaveChangesAsync. Use ChangeTracker.Entries() to detect changes. Add CreatedAt, CreatedBy, ModifiedAt, ModifiedBy properties. Create audit log table. Use interceptors (SaveChangesInterceptor) for cleaner implementation. Include: entity type, operation, old/new values, timestamp, user.", "source": "audit_logging"}
{"id": "ef_037", "domain": "entity_framework", "difficulty": "hard", "question": "How do you handle multi-tenancy with separate databases in EF Core?", "ground_truth": "Use DbContext factory with tenant-specific connection strings. Resolve tenant from HTTP context, claims, or headers. Register IDbContextFactory<TContext>. Use scoped DbContext with correct connection. Consider: connection pooling per tenant, migration management, tenant isolation. Use Finbuckle.MultiTenant library.", "source": "multitenant_databases"}
{"id": "aspire_023", "domain": "aspire", "difficulty": "medium", "question": "How do you configure container resources in Aspire?", "ground_truth": "Use WithEnvironment, WithVolume, WithBindMount. Configure ports with WithEndpoint. Set resource limits with WithCpus, WithMemory. Add health checks with WithHealthCheck. Control container lifecycle. Use annotations for metadata. Configure for: databases, message queues, caching.", "source": "container_config"}
{"id": "patterns_024", "domain": "patterns", "difficulty": "hard", "question": "How do you implement the Anti-Corruption Layer pattern?", "ground_truth": "Isolates domain model from external systems. Translates between domain and external models. Implement as: adapter, facade, or service. Use for: legacy integration, third-party APIs, subdomain boundaries. Benefits: domain purity, flexibility, testability. MediatR for internal messaging. AutoMapper for transformations.", "source": "anti_corruption_layer"}
{"id": "cs_047", "domain": "csharp", "difficulty": "medium", "question": "What are primary constructors (C# 12) and when should you use them?", "ground_truth": "Constructor parameters declared in class/struct declaration. Parameters in scope for entire type. Use for: simple initialization, dependency injection, reducing boilerplate. Can combine with property initialization. Not same as positional records. Consider record types for immutable data.", "source": "primary_constructors"}
{"id": "aspnet_044", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement global exception handling in ASP.NET Core?", "ground_truth": "Use UseExceptionHandler middleware with custom error page/API. ProblemDetails for API errors (RFC 7807). IExceptionHandler interface (ASP.NET Core 8+) for custom handlers. Development: UseDeveloperExceptionPage. Log exceptions. Return appropriate status codes. Don't expose internal details.", "source": "global_exception_handling"}
{"id": "ef_038", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement database views with EF Core?", "ground_truth": "Use ToView() in OnModelCreating. Map entity to view instead of table. Views are read-only by default. Use keyless entity types for views without primary key. FromSqlRaw for ad-hoc view queries. Create views in migrations with Sql() method. Useful for: reporting, denormalized queries, complex joins.", "source": "database_views"}
{"id": "aspire_024", "domain": "aspire", "difficulty": "hard", "question": "How do you implement distributed tracing across Aspire microservices?", "ground_truth": "ServiceDefaults configures OpenTelemetry with W3C Trace Context. Automatic propagation across HTTP, gRPC. View traces in Aspire Dashboard. Export to Jaeger, Zipkin, Azure Monitor. Add custom spans with Activity API. Correlate logs with TraceId. Tag spans with metadata. Sampling strategies for production.", "source": "distributed_tracing_aspire"}
{"id": "patterns_025", "domain": "patterns", "difficulty": "medium", "question": "What is the Chain of Responsibility pattern and how is it used in ASP.NET Core?", "ground_truth": "Series of handlers process request sequentially. Each handler can process or pass to next. ASP.NET Core middleware is Chain of Responsibility. Polly policies can chain. Use for: request processing, validation pipeline, authorization. Implementation: linked handlers, pipeline with next(). Behavioral pattern for flexible request processing.", "source": "chain_of_responsibility"}
{"id": "cs_048", "domain": "csharp", "difficulty": "easy", "question": "What is the difference between string and StringBuilder?", "ground_truth": "string is immutable (creates new instance on modification). StringBuilder is mutable buffer for efficient concatenation. Use StringBuilder for loops, multiple concatenations. Use string for few operations, immutability needed. StringBuilder has initial capacity, can grow dynamically.", "source": "string_vs_stringbuilder"}
{"id": "aspnet_045", "domain": "aspnet", "difficulty": "easy", "question": "What is the purpose of Program.cs in ASP.NET Core?", "ground_truth": "Entry point for application. Configures services with builder.Services. Builds app pipeline with middleware. Minimal hosting model (ASP.NET Core 6+) combines Program and Startup. Configure: DI, middleware, routing, authentication, endpoints.", "source": "program_cs"}
{"id": "ef_039", "domain": "entity_framework", "difficulty": "easy", "question": "What is a navigation property in EF Core?", "ground_truth": "Property referencing related entities. Collection navigation (ICollection<T>) for one-to-many. Reference navigation (T) for one-to-one, many-to-one. Enables lazy loading, Include(). Can be virtual for lazy loading proxies. Foreign key property optional (shadow FK supported).", "source": "navigation_properties"}
{"id": "aspire_025", "domain": "aspire", "difficulty": "easy", "question": "How do you add Azure Storage to Aspire applications?", "ground_truth": "In AppHost: AddAzureStorage('storage').AddBlobs('blobs'). In service: WithReference(blobs), use AddAzureBlobClient. Supports Azurite emulator for local dev. Connection string auto-configured. Health checks included. Can add queues, tables similarly.", "source": "azure_storage_aspire"}
{"id": "patterns_026", "domain": "patterns", "difficulty": "easy", "question": "What is the Singleton pattern and how does DI implement it?", "ground_truth": "Ensures single instance throughout application lifetime. In ASP.NET Core DI: AddSingleton<T>(). Created once, shared by all. Use for: configuration, caching, logging. Thread-safe by default in DI. Careful with state, disposables. Lazy<T> for lazy initialization.", "source": "singleton_pattern"}
{"id": "cs_049", "domain": "csharp", "difficulty": "medium", "question": "What are raw string literals (C# 11) and when to use them?", "ground_truth": "Triple quotes for multi-line strings without escaping. Syntax: \"\"\"content\"\"\". Handles quotes, JSON, SQL naturally. Indentation preserved. Use for: embedded JSON, SQL queries, HTML templates. Prefix with $ for interpolation. Cleaner than verbatim strings (@\"\").", "source": "raw_string_literals"}
{"id": "aspnet_046", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement HTTP/2 and HTTP/3 in ASP.NET Core?", "ground_truth": "HTTP/2 enabled by default on Kestrel with HTTPS. Configure with ListenOptions.Protocols. HTTP/3 requires QUIC support (AddQuic). Benefits: multiplexing, server push, header compression. gRPC requires HTTP/2. Check browser support. ALPNs for protocol negotiation.", "source": "http2_http3"}
{"id": "ef_040", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement complex type properties in EF Core?", "ground_truth": "Use owned entity types with OwnsOne(). Complex type embedded in owner table. Alternative: use ComplexProperty (EF Core 8+) for value objects. No separate table, no identity. Use for: addresses, money, coordinates. Different from separate entity with relationship.", "source": "complex_types"}
{"id": "aspire_026", "domain": "aspire", "difficulty": "medium", "question": "How do you implement secrets management in Aspire?", "ground_truth": "Use AddParameter with secret type. User secrets for local dev (dotnet user-secrets). Azure Key Vault for production. Environment variables for deployment. azd provisions Key Vault automatically. Access via IConfiguration. ServiceDefaults configures secrets sources. Never commit secrets to git.", "source": "secrets_management_aspire"}
{"id": "patterns_027", "domain": "patterns", "difficulty": "medium", "question": "What is the Observer pattern and how does it relate to events in C#?", "ground_truth": "Subject notifies observers of state changes. C# events implement Observer pattern. Publisher (subject) raises events, subscribers (observers) handle. Use event keyword, EventHandler<T>. Weak event pattern for memory leaks. IObservable<T>/IObserver<T> in Rx.NET for reactive programming.", "source": "observer_pattern"}
{"id": "cs_050", "domain": "csharp", "difficulty": "hard", "question": "How do you implement custom LINQ operators?", "ground_truth": "Extension methods on IEnumerable<T> or IQueryable<T>. Use yield for deferred execution. IQueryable requires expression tree handling. Example: WhereIf, DistinctBy (built-in .NET 6+). Compose with existing LINQ. Maintain LINQ conventions (deferred, streaming). Test with empty sequences, null handling.", "source": "custom_linq_operators"}
{"id": "aspnet_047", "domain": "aspnet", "difficulty": "hard", "question": "How do you implement custom authorization policies with requirements and handlers?", "ground_truth": "Create IAuthorizationRequirement class. Implement AuthorizationHandler<TRequirement>. Register with AddAuthorization(options => options.AddPolicy()). Handle() method checks requirement. Support for multiple handlers per requirement. Use AuthorizationHandlerContext for user, resource. Inject dependencies in handler.", "source": "custom_authorization"}
{"id": "ef_041", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement interceptors in EF Core?", "ground_truth": "Implement DbCommandInterceptor, DbConnectionInterceptor, or SaveChangesInterceptor. Override relevant methods. Register with AddInterceptors(). Use for: logging, query modification, auditing, performance monitoring. Access to commands before execution. Modify parameters, results. Multiple interceptors chain.", "source": "efcore_interceptors"}
{"id": "aspire_027", "domain": "aspire", "difficulty": "hard", "question": "How do you implement blue-green deployments with Aspire?", "ground_truth": "Use Azure Container Apps revisions. Deploy new revision (green) alongside current (blue). Test green with traffic splitting. Switch traffic when validated. azd supports revision management. Configure with container app YAML. Rollback by routing to blue. Use deployment slots pattern.", "source": "blue_green_aspire"}
{"id": "patterns_028", "domain": "patterns", "difficulty": "hard", "question": "How do you implement the Event-Driven Architecture pattern in .NET microservices?", "ground_truth": "Services communicate via events (pub/sub). Use message brokers: Azure Service Bus, RabbitMQ, Kafka. Implement with MassTransit or NServiceBus. Event schema versioning. At-least-once delivery, idempotency. Event sourcing optional. Benefits: decoupling, scalability. Challenges: eventual consistency, debugging.", "source": "event_driven_architecture"}
{"id": "cs_051", "domain": "csharp", "difficulty": "medium", "question": "What are attributes and how do you create custom ones?", "ground_truth": "Metadata attached to code elements. Inherit from System.Attribute. Use [AttributeUsage] to specify targets. Access via reflection (GetCustomAttributes). Use for: validation, serialization, documentation, DI. Examples: [Obsolete], [Serializable], [Required]. Can have properties, constructor parameters.", "source": "custom_attributes"}
{"id": "aspnet_048", "domain": "aspnet", "difficulty": "medium", "question": "How do you implement API key authentication in ASP.NET Core?", "ground_truth": "Create custom AuthenticationHandler. Check for API key in header/query. Validate against stored keys. Create ClaimsPrincipal on success. Register with AddAuthentication().AddScheme(). Use [Authorize] with scheme name. Consider: key rotation, rate limiting, scope/permissions.", "source": "api_key_auth"}
{"id": "ef_042", "domain": "entity_framework", "difficulty": "medium", "question": "How do you implement enum support in EF Core?", "ground_truth": "Enums stored as integers by default. Use HasConversion for string storage: .HasConversion<string>(). Configure with enum name or value. Handle unknown values. Consider: database constraints, migrations, API serialization consistency. Use [JsonConverter] for JSON serialization.", "source": "enum_support"}
{"id": "aspire_028", "domain": "aspire", "difficulty": "medium", "question": "How do you add Elasticsearch to Aspire applications?", "ground_truth": "Use Aspire.Elastic.Clients.Elasticsearch component. In AppHost: AddElasticsearch('elasticsearch'). In service: WithReference, use AddElasticsearchClient. Supports Kibana for visualization. Connection string auto-configured. Health checks included. Use for: logging, search, analytics.", "source": "elasticsearch_aspire"}
{"id": "patterns_029", "domain": "patterns", "difficulty": "medium", "question": "What is the Adapter pattern and when do you use it?", "ground_truth": "Converts interface of class to another interface. Wraps incompatible interfaces. Use for: third-party libraries, legacy code integration, interface standardization. Example: wrapping external API with domain interface. Can be implemented with inheritance or composition. Similar to Facade but adapts existing interface.", "source": "adapter_pattern"}
{"id": "cs_052", "domain": "csharp", "difficulty": "hard", "question": "How do you implement efficient string interning in .NET?", "ground_truth": "string.Intern() stores in intern pool, returns reference. Use for: repeated identical strings, reduced memory. Cost: pool never GC'd. Alternative: dictionary for app-specific interning. Literals automatically interned. Use string.IsInterned() to check. Useful for: configuration keys, enums as strings, XML/JSON keys.", "source": "string_interning"}
{"id": "aspnet_049", "domain": "aspnet", "difficulty": "hard", "question": "How do you implement custom endpoints in minimal APIs?", "ground_truth": "Use MapMethods, MapGet, MapPost with route patterns. Group endpoints with MapGroup. Add filters with AddEndpointFilter. Bind parameters from route, query, body, services. Use Results.* for responses. Support for OpenAPI metadata. Validate with DataAnnotations. Configure CORS, auth per endpoint.", "source": "custom_minimal_endpoints"}
{"id": "ef_043", "domain": "entity_framework", "difficulty": "hard", "question": "How do you implement the Specification pattern with EF Core?", "ground_truth": "Create ISpecification<T> with ToExpression(). Encapsulate query logic. Compose specifications with And/Or/Not. Use with repository: repository.Get(spec). Libraries: Ardalis.Specification. Benefits: reusable queries, testable, composable. Can include sorting, paging, includes. Alternative: extension methods on IQueryable.", "source": "specification_efcore"}
{"id": "aspire_029", "domain": "aspire", "difficulty": "hard", "question": "How do you implement observability best practices in Aspire production?", "ground_truth": "Export telemetry to production backends (Azure Monitor, Datadog). Implement: structured logging, distributed tracing, metrics dashboards, alerting. Use correlation IDs. Log levels per environment. Sampling in production. Custom metrics with ActivitySource. Alert on: error rates, latency, resource usage. Cost management for telemetry volume.", "source": "observability_production"}
