{"id": "ce_001", "domain": "csharp_expert", "difficulty": "easy", "question": "What is a primary constructor in C# 13, and how does it differ from a traditional constructor?", "ground_truth": "A primary constructor is declared directly in the class or struct declaration (e.g., `class Person(string name, int age)`) with parameters automatically captured as private fields. It eliminates boilerplate code compared to traditional constructors that require explicit field assignments in the constructor body.", "source": "primary_constructors"}
{"id": "ce_002", "domain": "csharp_expert", "difficulty": "easy", "question": "How do you call a base class constructor from a primary constructor in a derived class?", "ground_truth": "Use the `: base(parameters)` syntax after the derived class's primary constructor declaration, e.g., `class Derived(string name) : Base(name)`. The base constructor call must include all required base parameters.", "source": "primary_constructors_inheritance"}
{"id": "ce_003", "domain": "csharp_expert", "difficulty": "easy", "question": "What is the spread operator in collection expressions (C# 13), and what problem does it solve?", "ground_truth": "The spread operator (`..`) allows unpacking existing collections into a new collection expression, e.g., `int[] numbers = [1, 2, ..existingArray, 3]`. It simplifies combining multiple collections without explicit loop or LINQ syntax.", "source": "collection_expressions"}
{"id": "ce_004", "domain": "csharp_expert", "difficulty": "easy", "question": "What are interceptors in C# 13, and what is their primary use case?", "ground_truth": "Interceptors are a source generator feature that can intercept and redirect method calls at compile time. They are primarily used for AOT (Ahead-of-Time) compilation optimization by replacing runtime calls with compile-time generated code without changing source code.", "source": "interceptors"}
{"id": "ce_005", "domain": "csharp_expert", "difficulty": "easy", "question": "What is Native AOT compilation in .NET 9, and what is its main advantage?", "ground_truth": "Native AOT compilation pre-compiles .NET applications to native machine code at build time instead of using JIT at runtime. Its main advantage is reduced startup time, lower memory consumption, and the ability to deploy without the .NET runtime.", "source": "native_aot"}
{"id": "ce_006", "domain": "csharp_expert", "difficulty": "easy", "question": "What is trimming in the context of Native AOT, and why is it necessary?", "ground_truth": "Trimming is the process of removing unused code and metadata from an application during AOT compilation. It is necessary to reduce the final binary size and ensure only required code is compiled, improving deployment efficiency.", "source": "native_aot_trimming"}
{"id": "ce_007", "domain": "csharp_expert", "difficulty": "easy", "question": "What is a property pattern in C# pattern matching, and provide a simple example.", "ground_truth": "A property pattern matches objects based on their property values using the syntax `{ PropertyName: pattern }`, e.g., `person is { Age: > 18, Name: \"John\" }`. It enables concise null-safe and conditional checks on object properties.", "source": "pattern_matching_property"}
{"id": "ce_008", "domain": "csharp_expert", "difficulty": "easy", "question": "What is a list pattern in C# 13 pattern matching, and what can it match?", "ground_truth": "A list pattern matches arrays or lists by their length and element values, e.g., `int[] is [1, 2, .., 5]`. It can match specific positions, use the spread pattern (`..`) to match remaining elements, and check list length without iteration.", "source": "pattern_matching_list"}
{"id": "ce_009", "domain": "csharp_expert", "difficulty": "easy", "question": "What is the difference between a record class and a record struct in C# 13?", "ground_truth": "A record class is a reference type with built-in value-based equality semantics, while a record struct is a value type with the same equality features. Record structs are stack-allocated and suitable for small immutable data; record classes are heap-allocated.", "source": "records"}
{"id": "ce_010", "domain": "csharp_expert", "difficulty": "easy", "question": "What does the `with` expression do in C# records?", "ground_truth": "The `with` expression creates a shallow copy of a record with specified properties modified, e.g., `var person2 = person1 with { Age = 30 }`. It provides a concise syntax for non-destructive mutation of immutable records.", "source": "records_with_expression"}
{"id": "ce_011", "domain": "csharp_expert", "difficulty": "easy", "question": "What are nullable reference types in C#, and what problem do they solve?", "ground_truth": "Nullable reference types allow marking reference type variables as nullable (`string?`) or non-nullable (`string`), enabling null-safety tracking. They solve the problem of null reference exceptions by providing compile-time warnings when potentially null values are dereferenced.", "source": "nullable_reference_types"}
{"id": "ce_012", "domain": "csharp_expert", "difficulty": "easy", "question": "What is the `!` operator in the context of nullable reference types?", "ground_truth": "The `!` operator (null-forgiving operator) tells the compiler to suppress null-safety warnings for a specific expression, e.g., `string name = input!;`. It asserts to the compiler that a value is not null despite its nullable type.", "source": "nullable_reference_types_annotations"}
{"id": "ce_013", "domain": "csharp_expert", "difficulty": "easy", "question": "What is the difference between Task and ValueTask in async/await patterns?", "ground_truth": "Task is a reference type (heap-allocated) representing an asynchronous operation, while ValueTask is a value type (stack-allocated) designed for low-allocation scenarios. ValueTask is more efficient when the operation often completes synchronously.", "source": "async_await_valuetask"}
{"id": "ce_014", "domain": "csharp_expert", "difficulty": "easy", "question": "What are async streams in C#, and what syntax do they use?", "ground_truth": "Async streams are sequences of asynchronously retrieved data using `IAsyncEnumerable<T>`, consumable with `await foreach`. They use `async IAsyncEnumerable<T>` with `yield return` to produce values asynchronously without blocking.", "source": "async_await_streams"}
{"id": "ce_015", "domain": "csharp_expert", "difficulty": "easy", "question": "What is deferred execution in LINQ, and what does it mean?", "ground_truth": "Deferred execution means LINQ query expressions are not executed when defined but rather when the result is enumerated (e.g., in a foreach or `.ToList()` call). This allows lazy evaluation and potentially more efficient processing of large datasets.", "source": "linq_deferred_execution"}
{"id": "ce_016", "domain": "csharp_expert", "difficulty": "easy", "question": "What is the purpose of a `where` clause in generic type constraints?", "ground_truth": "The `where` clause restricts which types can be used as type arguments for a generic type or method, e.g., `where T : class` or `where T : IComparable<T>`. It ensures type safety and enables calling specific methods on generic type instances.", "source": "generics_constraints"}
{"id": "ce_017", "domain": "csharp_expert", "difficulty": "easy", "question": "What is covariance in generics, and provide an example of its use case.", "ground_truth": "Covariance allows a derived type to be used where a base type is expected in generic type parameters, enabled by the `out` keyword, e.g., `IEnumerable<Derived>` is covariant to `IEnumerable<Base>`. It enables safe type hierarchies in read-only generic contexts.", "source": "generics_covariance"}
{"id": "ce_018", "domain": "csharp_expert", "difficulty": "easy", "question": "What are minimal APIs in .NET 9, and what do they replace?", "ground_truth": "Minimal APIs are lightweight alternatives to traditional ASP.NET Controller-based APIs, defined using WebApplication methods like `.MapGet()`, `.MapPost()`. They reduce boilerplate by allowing HTTP endpoints to be defined inline without controller classes.", "source": "minimal_apis"}
{"id": "ce_019", "domain": "csharp_expert", "difficulty": "easy", "question": "What is the main performance improvement focus in .NET 9, and how does it affect application behavior?", "ground_truth": ".NET 9 focuses on throughput and latency improvements through JIT optimizations, vectorization, and better GC performance. These improvements reduce CPU usage and execution time, resulting in faster application performance without code changes.", "source": "dotnet9_performance"}
{"id": "ce_020", "domain": "csharp_expert", "difficulty": "easy", "question": "What is the role of dependency injection in .NET applications, and which namespace provides the core abstractions?", "ground_truth": "Dependency injection manages object creation and lifetime, reducing tight coupling and improving testability. The `Microsoft.Extensions.DependencyInjection` namespace provides the `IServiceProvider` and `IServiceCollection` interfaces for configuring services.", "source": "dependency_injection"}
{"id": "ce_021", "domain": "csharp_expert", "difficulty": "medium", "question": "When using primary constructors in C# 13, how do parameter names interact with field initialization, and what happens if you declare a field with the same name as a primary constructor parameter?", "ground_truth": "Primary constructor parameters are captured as private fields automatically. If you explicitly declare a field with the same name as a parameter, you get a compiler error (CS0100) because you cannot have duplicate declarations. The parameter takes precedence and is used throughout the class scope.", "source": "primary_constructors"}
{"id": "ce_022", "domain": "csharp_expert", "difficulty": "medium", "question": "Explain how to call a base class constructor from a derived class that uses primary constructor syntax, and what are the limitations?", "ground_truth": "You call the base constructor using the colon syntax after the derived class declaration: `class Derived(int x) : Base(x) { }`. The base constructor call must occur immediately after the derived class primary constructor parameters and before the class body. You cannot conditionally invoke base constructors or defer them.", "source": "primary_constructors"}
{"id": "ce_023", "domain": "csharp_expert", "difficulty": "medium", "question": "In collection expressions with the spread operator, what is the difference between spreading a `List<T>` and spreading an `IEnumerable<T>`, and how does target typing affect the result?", "ground_truth": "Both spread correctly into collection expressions, but the target type determines the final collection type. If you spread into `[..list]` without a target type, it infers based on context; with explicit target typing like `List<int> x = [..enumerable]`, it creates the specified collection type. The spread operator itself works identically; only the collection container differs.", "source": "collection_expressions"}
{"id": "ce_024", "domain": "csharp_expert", "difficulty": "medium", "question": "What are interceptors in C# 13, and how do they differ from traditional method interception or aspect-oriented programming approaches?", "ground_truth": "Interceptors are source generator-based compile-time features that redirect method calls to different implementations without runtime overhead. Unlike AOP frameworks that use reflection or IL weaving, interceptors work at compile time and are fully AOT-compatible, producing zero runtime cost and enabling static analysis. They require source generator implementation to define interception rules.", "source": "interceptors"}
{"id": "ce_025", "domain": "csharp_expert", "difficulty": "medium", "question": "When configuring Native AOT compilation, what is the purpose of the trimmer and what types of code patterns are most likely to cause trimming warnings?", "ground_truth": "The trimmer removes unused code to reduce deployment size and enable ahead-of-time compilation. It generates warnings for reflection-based code (Reflection.Invoke, ActivatorCreateInstance), dynamic type loading, serialization via reflection, and code patterns that cannot be statically analyzed. Suppressing warnings requires `[DynamicallyAccessedMembers]` attributes or trimmer configuration files.", "source": "native_aot_compilation"}
{"id": "ce_026", "domain": "csharp_expert", "difficulty": "medium", "question": "Explain property patterns in C# pattern matching and provide an example scenario where they are superior to traditional null-checking approaches.", "ground_truth": "Property patterns match on object properties directly: `if (person is { Age: > 18, Address.City: \"NYC\" })`. They are superior to cascading null checks because they handle null navigation elegantly\u2014`person?.Address?.City == \"NYC\"` requires explicit null handling, while property patterns with nested property patterns naturally short-circuit on null. They also improve readability for complex nested conditions.", "source": "pattern_matching"}
{"id": "ce_027", "domain": "csharp_expert", "difficulty": "medium", "question": "When using list patterns in C# 13, what does the `..` (slice pattern) capture, and how does it interact with pattern guards?", "ground_truth": "The `..` slice pattern captures zero or more elements into a variable: `[first, ..rest, last]` binds `rest` to the middle elements. It can be combined with pattern guards: `[first, ..rest, last] when rest.Length > 2`. The slice is a subarray/subsequence; pattern guards evaluate after the match, allowing you to refine based on the captured slice contents.", "source": "pattern_matching"}
{"id": "ce_028", "domain": "csharp_expert", "difficulty": "medium", "question": "What is the semantic difference between a record class and a record struct in C# 13, particularly regarding equality semantics and inheritance?", "ground_truth": "Record classes use reference semantics for identity but value semantics for equality (comparing field values); they support inheritance hierarchies. Record structs use value semantics for both identity and equality; they cannot inherit from other structs but can implement interfaces. Record structs are stack-allocated by default, making them suitable for performance-critical scenarios, while record classes are heap-allocated.", "source": "records"}
{"id": "ce_029", "domain": "csharp_expert", "difficulty": "medium", "question": "Explain how the `with` expression works for records with primary constructors and what happens when you use `with` to modify a property that was never explicitly declared as a field.", "ground_truth": "The `with` expression creates a shallow copy and modifies specified properties: `var updated = original with { Name = \"New\" }`. For primary constructor parameters, `with` works on the captured fields directly. If a property has no backing field (computed property), `with` cannot modify it\u2014it only works on init properties or auto-properties backed by fields.", "source": "records"}
{"id": "ce_030", "domain": "csharp_expert", "difficulty": "medium", "question": "What are the practical differences between nullable reference types being enabled versus disabled, and why might a team enable it progressively across a codebase?", "ground_truth": "With nullable reference types enabled, the compiler enforces null safety: reference types are non-nullable by default, requiring `?` annotation for nullable ones; warnings flag potential null dereferences. Disabled, all references allow null without annotation. Progressive adoption allows teams to modernize incrementally via file-scoped `#nullable enable` directives, reducing breaking changes and allowing risk-based rollout while capturing null safety benefits.", "source": "nullable_reference_types"}
{"id": "ce_031", "domain": "csharp_expert", "difficulty": "medium", "question": "When using async/await with CancellationToken, what is the difference between passing a token to Task methods versus checking it manually in the method body, and when should each approach be used?", "ground_truth": "Passing a token to async operations (I/O methods, Task.Delay) integrates cancellation into the operation itself, raising OperationCanceledException when cancelled. Manual checks with `token.ThrowIfCancellationRequested()` in CPU-bound code allow custom cancellation logic. Use the first approach for I/O-bound operations (cleaner, avoids polling), the second for compute-bound or complex cancellation scenarios.", "source": "async_await"}
{"id": "ce_032", "domain": "csharp_expert", "difficulty": "medium", "question": "What is an async stream in C#, how does it differ from returning IEnumerable<T>, and what are the performance implications?", "ground_truth": "Async streams (`IAsyncEnumerable<T>`) yield values asynchronously using `yield return` in async methods, allowing each iteration to perform async operations. Unlike `IEnumerable<T>` (synchronous, computed upfront or eagerly), async streams enable lazy evaluation with async delays. Performance benefit: async streams allow responsive, non-blocking iteration over remote data (APIs, databases) without buffering entire results.", "source": "async_await"}
{"id": "ce_033", "domain": "csharp_expert", "difficulty": "medium", "question": "Explain deferred execution in LINQ and provide an example scenario where understanding this behavior is critical for correctness and performance.", "ground_truth": "Deferred execution means LINQ query expressions don't execute until enumerated; the query builds an expression tree evaluated lazily. Critical scenario: `var query = data.Where(x => x.Active); data.Clear(); foreach(var item in query)` will enumerate an empty collection because `data` is captured by reference, not snapshot. The query executes when iterated, after `data.Clear()`. Understanding this prevents bugs and enables optimization of chained operations.", "source": "linq"}
{"id": "ce_034", "domain": "csharp_expert", "difficulty": "medium", "question": "When should you use `ValueTask<T>` instead of `Task<T>` in .NET 9, and what are the trade-offs?", "ground_truth": "Use `ValueTask<T>` when the async method frequently completes synchronously (avoiding heap allocation) or in high-frequency, latency-sensitive code paths. Trade-offs: `ValueTask<T>` cannot be awaited multiple times (only once), makes code harder to compose, and adds complexity. `Task<T>` is safer for general use; `ValueTask<T>` is an optimization for specific scenarios where profiling shows allocation overhead matters.", "source": "async_await"}
{"id": "ce_035", "domain": "csharp_expert", "difficulty": "medium", "question": "What is the difference between method syntax and query syntax in LINQ, and are there scenarios where one has performance advantages over the other?", "ground_truth": "Query syntax is syntactic sugar compiled into method syntax; they are semantically equivalent after compilation. Query syntax can be more readable for complex multi-join or grouping operations. Performance is identical after compilation\u2014the compiler translates query syntax to method calls. However, some advanced operations (like custom methods) must use method syntax, and debugging shows method syntax stack traces directly.", "source": "linq"}
{"id": "ce_036", "domain": "csharp_expert", "difficulty": "medium", "question": "Explain generic constraints using `where` clauses and describe a scenario where combining multiple constraints (e.g., class, struct, new()) creates a design challenge.", "ground_truth": "Generic constraints limit type parameters: `where T : class` restricts to reference types, `where T : struct` to value types, `where T : new()` requires parameterless constructor. Challenge scenario: a generic repository `Repository<T> where T : class, new()` cannot store records (which support primary constructors but may lack parameterless ones) or use dependency injection. Solution: use factory pattern or remove `new()` constraint, accepting incomplete initialization.", "source": "generics"}
{"id": "ce_037", "domain": "csharp_expert", "difficulty": "medium", "question": "What is covariance and contravariance in generics, and provide a practical example where contravariance is necessary for type safety?", "ground_truth": "Covariance allows a derived type where a base type is expected: `IEnumerable<string>` is covariant to `IEnumerable<object>`. Contravariance reverses this: an action accepting base type where derived type is expected. Example: `Action<object>` is contravariant to `Action<string>`\u2014a method accepting any object can safely handle strings. Necessary for type-safe delegate and interface hierarchies without runtime errors.", "source": "generics"}
{"id": "ce_038", "domain": "csharp_expert", "difficulty": "medium", "question": "In a minimal API configuration, how does dependency injection work, and what are the limitations compared to traditional controller-based ASP.NET Core?", "ground_truth": "Minimal APIs use parameter binding: dependencies are injected as parameters in route handlers via `MapGet((IUserService svc) => ...)`. The framework resolves them from the DI container. Limitations: complex binding scenarios (model state details), filters/attributes, and inheritance chains are handled differently; action result helpers are fewer. Minimal APIs excel for simple, focused endpoints; complex applications may benefit from controllers.", "source": "minimal_apis"}
{"id": "ce_039", "domain": "csharp_expert", "difficulty": "medium", "question": "What is a scoped dependency in the .NET dependency injection container, and why is it important to understand scoped lifetime when using Entity Framework DbContext?", "ground_truth": "Scoped lifetime creates a single instance per HTTP request/logical scope; it's released when the scope ends. Critical for DbContext: Entity Framework tracks object changes within a scope using the Identity Map pattern. Creating a transient DbContext loses change tracking across requests; using scoped ensures one DbContext per request, maintaining entity state and preventing tracking conflicts. Improper scoping causes change detection failures.", "source": "dependency_injection"}
{"id": "ce_040", "domain": "csharp_expert", "difficulty": "medium", "question": "Describe what .NET 9 performance improvements address at the runtime level and provide an example of code that would benefit most from these optimizations.", "ground_truth": ".NET 9 improves JIT compilation speed, reduces GC pause times, and optimizes SIMD/vectorization. Code that benefits most: tight loops with frequent allocations (garbage collection improvements), data-parallel operations on arrays (SIMD enhancements), and startup-sensitive workloads (JIT improvements). Example: image processing with vectorized operations on pixel arrays sees significant speedup from enhanced vector intrinsics and reduced allocation overhead.", "source": "dotnet9_performance"}
{"id": "ce_041", "domain": "csharp_expert", "difficulty": "hard", "question": "In C# 13 primary constructors, when you declare a primary constructor parameter in a derived class that also calls a base constructor with parameters, how does parameter capture work if both the derived and base classes have primary constructors with the same parameter name?", "ground_truth": "Primary constructor parameters are captured as private fields in the class they're declared in. When a derived class primary constructor calls a base primary constructor, the derived class parameter shadows the base parameter; only the derived class captures it as a field. The base constructor receives the explicitly passed argument, not an implicit reference to the derived parameter. Each class maintains its own captured parameters independently.", "source": "primary_constructors_inheritance"}
{"id": "ce_042", "domain": "csharp_expert", "difficulty": "hard", "question": "Explain the memory and performance implications of using collection expressions with the spread operator on large collections in .NET 9, particularly regarding allocation patterns and when you should prefer traditional LINQ methods like Concat().", "ground_truth": "Collection expressions with spread operators create intermediate collections during evaluation, potentially causing multiple allocations. For large collections, they may allocate more memory than LINQ's deferred Concat() which chains enumerators. Spread operators are optimized for small collections and code clarity; for high-performance scenarios processing large datasets, use IEnumerable<T> LINQ methods that defer execution and minimize allocations.", "source": "collection_expressions_performance"}
{"id": "ce_043", "domain": "csharp_expert", "difficulty": "hard", "question": "How do interceptors in C# 13 source generators interact with method resolution and overload resolution at compile time, and what are the security implications if an interceptor intercepts a method call with sensitive parameters?", "ground_truth": "Interceptors use fully-qualified source locations and line numbers to intercept specific call sites at compile time, bypassing normal method resolution. They replace the intercepted call entirely with generated code. Security implications include: interceptors have access to all parameters (including sensitive data), can modify behavior without runtime checks, and are invisible in source code at call sites. Only trusted source generators should implement interceptors, as they effectively bypass encapsulation and method contracts.", "source": "interceptors_security"}
{"id": "ce_044", "domain": "csharp_expert", "difficulty": "hard", "question": "When using Native AOT compilation with trimming in .NET 9, what specific challenges arise when using reflection over generic types with constraints, and how does this differ from JIT deployment regarding metadata preservation?", "ground_truth": "Native AOT with trimming removes metadata for unused code paths. Generic types with constraints require runtime type information to validate constraint satisfaction via reflection. When using Activator.CreateInstance<T>() or reflection on constrained generics, the trimmer cannot determine which instantiations are needed, potentially removing necessary metadata. Unlike JIT (which can generate code on-demand), AOT must prove all needed generic instances at compile time; use DynamicallyAccessedMembers attributes to guide the trimmer about reflection patterns.", "source": "native_aot_generics_trimming"}
{"id": "ce_045", "domain": "csharp_expert", "difficulty": "hard", "question": "Design a scenario where you use list patterns with property patterns and relational patterns simultaneously in a C# 13 switch expression. What are the evaluation order guarantees and potential performance traps?", "ground_truth": "List patterns match arrays/lists by structure; when combined with property patterns and relational patterns in a switch expression, evaluation follows short-circuit left-to-right order. Property patterns are evaluated after list structure matches; relational patterns (<, >, etc.) are evaluated within property pattern conditions. Performance trap: matching against list elements by property requires iterating and deconstructing each element; combining complex patterns on list elements can cause O(n*m) complexity where n is list length and m is pattern complexity.", "source": "pattern_matching_complex"}
{"id": "ce_046", "domain": "csharp_expert", "difficulty": "hard", "question": "A record struct in C# 13 uses a primary constructor and implements value semantics. Explain the interaction between the generated Equals() method, mutable fields, and the implications for using record structs as Dictionary keys in high-concurrency scenarios.", "ground_truth": "Record structs with primary constructors auto-generate value-based Equals() and GetHashCode() using all fields. If any field is mutable and modified after insertion as a Dictionary key, the hash code becomes inconsistent with Equals, violating the Dictionary invariant and causing lookup failures or data corruption. In high-concurrency scenarios, this is dangerous without explicit synchronization. Best practice: use record structs as keys only if they remain immutable, or use record class (reference semantics) instead.", "source": "record_struct_semantics"}
{"id": "ce_047", "domain": "csharp_expert", "difficulty": "hard", "question": "In a nullable reference types (NRT) enabled project, explain the distinction between flow analysis implications of suppression operator (!) versus nullable forgiveness in async methods that involve await points, particularly with Task<T?> return types.", "ground_truth": "The suppression operator (!) tells the compiler a nullable reference is actually non-null at that point, but this is only valid within the local scope before await points. Across await points, the compiler cannot guarantee that the flow analysis assumption remains valid post-await because the async method may be suspended and resumed on different threads. Using ! before await or on Task<T?> result after await can hide legitimate null-dereference bugs. Better approach: use explicit null checks after await or redesign to avoid nullability across await boundaries.", "source": "nullable_reference_async"}
{"id": "ce_048", "domain": "csharp_expert", "difficulty": "hard", "question": "Compare the execution semantics and performance characteristics of async streams (IAsyncEnumerable<T>) with await foreach versus traditional Task<List<T>> in .NET 9, including memory efficiency, cancellation token propagation, and backpressure handling.", "ground_truth": "Async streams with await foreach enable lazy evaluation and can process items as they arrive without buffering the entire result, improving memory efficiency. However, they don't provide backpressure\u2014the producer controls the rate. Task<List<T>> buffers all results upfront (higher memory) but allows synchronous iteration and implicit completion semantics. Cancellation propagation differs: async streams require explicit CancellationToken parameters in the enumerator, while Task<T> uses token-based cancellation on the task itself. Choose streams for large/unbounded sequences; choose Task<List<T>> when you need all data upfront or synchronous processing.", "source": "async_streams_semantics"}
{"id": "ce_049", "domain": "csharp_expert", "difficulty": "hard", "question": "A LINQ query uses deferred execution and chains multiple operations (Select, Where, GroupBy) on an IQueryable<T> backed by a database provider. Explain how the provider determines when to materialize results, how lazy evaluation interacts with ordering operations, and what happens when you enumerate the query multiple times.", "ground_truth": "IQueryable<T> builds an expression tree representing all operations; materialization occurs at enumeration (foreach, ToList, Count, etc.). Ordering operations (OrderBy) may not execute until materialization. If you enumerate the same IQueryable multiple times, the expression tree is re-evaluated each time\u2014potentially re-executing database queries unless you materialize with ToList first. Lazy evaluation means the database provider sees the complete expression tree and can optimize it; early materialization prevents this optimization. Multiple enumerations = multiple database queries unless explicitly materialized.", "source": "linq_deferred_execution"}
{"id": "ce_050", "domain": "csharp_expert", "difficulty": "hard", "question": "In generic method constraints, explain the interaction between where T : class and where T : notnull in C# 13, including which types satisfy each constraint, variance rules, and implications for constraint satisfaction in derived generic methods.", "ground_truth": "where T : class constrains T to reference types (classes, interfaces, delegates); where T : notnull constrains T to non-nullable types (excludes T? and Nullable<U>). A type satisfying 'class' also satisfies 'notnull' for reference types, but struct types satisfy 'notnull' only. In derived generic methods, constraints cannot be weakened\u2014if a base method requires 'class', the override must enforce 'class' or stricter constraints. Combining both (where T : class, notnull) is redundant because 'class' already implies 'notnull' for reference types; used separately, they create different constraint hierarchies.", "source": "generics_constraints_notnull"}
{"id": "ce_051", "domain": "csharp_expert", "difficulty": "hard", "question": "Design a dependency injection scenario where you register both factory delegates (Func<IService>) and typed registrations, then discuss how service lifetime (transient, scoped, singleton) interacts with lazy initialization and circular dependency detection in a .NET 9 minimal API.", "ground_truth": "Factory delegates Func<IService> are typically registered as transient, creating new instances per invocation; typed registrations respect their declared lifetime. In minimal APIs, the dependency container resolves dependencies per-request in request scope. Lazy<T> can defer dependency resolution but doesn't change lifetime\u2014the wrapped service still respects its registered lifetime. Circular dependencies (A\u2192B\u2192A) are detected at resolution time via a traversal stack, throwing an InvalidOperationException before instantiation. To resolve circularity: refactor to break the cycle, use factories, or introduce a third mediator service.", "source": "dependency_injection_advanced"}
