[
  {
    "id": "re_001",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is YJIT in Ruby 3.3+ and what does it do?",
    "ground_truth": "YJIT is a JIT (Just-In-Time) compiler introduced in Ruby 3.1 and improved in Ruby 3.3+. It compiles Ruby code to machine code at runtime to improve performance, typically providing 15-40% faster execution for CPU-bound workloads.",
    "source": "YJIT_JIT_compiler"
  },
  {
    "id": "re_002",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is a Ractor and what concurrency model does it implement?",
    "ground_truth": "A Ractor is an actor-based concurrency primitive in Ruby that allows safe parallel execution without shared mutable state. It implements the actor model, where Ractors communicate via message passing rather than shared memory.",
    "source": "Ractors_actor_parallelism"
  },
  {
    "id": "re_003",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "How does pattern matching in Ruby (case/in) differ from traditional case/when statements?",
    "ground_truth": "Pattern matching using case/in allows destructuring of objects and arrays, and can match against complex structures and conditions. Unlike case/when which uses equality (==), case/in uses pattern matching to bind variables and validate structure.",
    "source": "pattern_matching_case_in"
  },
  {
    "id": "re_004",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is RBS and what problem does it solve?",
    "ground_truth": "RBS (Ruby Signature) is a type annotation format for Ruby that allows developers to write type signatures separate from code. It enables static type checking and IDE support without modifying actual Ruby code.",
    "source": "RBS_type_signatures"
  },
  {
    "id": "re_005",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is the Prism parser in Ruby and what does it replace?",
    "ground_truth": "Prism is a new parser for Ruby introduced in Ruby 3.3 to eventually replace the traditional Ripper parser. It provides better error recovery, more accurate AST generation, and improved performance for parsing Ruby code.",
    "source": "Prism_parser"
  },
  {
    "id": "re_006",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is the M:N thread scheduler in Ruby and why is it significant?",
    "ground_truth": "The M:N thread scheduler allows multiple user-level Ruby threads (M) to be mapped to fewer OS threads (N), improving efficiency and reducing context-switching overhead while maintaining scalability for I/O-bound applications.",
    "source": "M_N_thread_scheduler"
  },
  {
    "id": "re_007",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is a Fiber in Ruby and how does it differ from a Thread?",
    "ground_truth": "A Fiber is a lightweight coroutine that is manually scheduled (cooperative multitasking), whereas a Thread is OS-managed and preemptively scheduled. Fibers are faster and have lower overhead but require explicit context switching via yield/resume.",
    "source": "fibers_coroutines"
  },
  {
    "id": "re_008",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is the difference between a Block, a Proc, and a Lambda in Ruby?",
    "ground_truth": "A Block is unnamed code passed to a method. A Proc is a Block converted to an object with loose return behavior. A Lambda is a Proc variant with strict argument checking and local return behavior that returns only from the lambda, not the enclosing method.",
    "source": "blocks_procs_lambdas"
  },
  {
    "id": "re_009",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What does method_missing do and when would you use it?",
    "ground_truth": "method_missing is a metaprogramming hook that intercepts calls to undefined methods. It's useful for implementing dynamic method proxies, DSLs, and adapters, but should be used sparingly as it can hide errors and impact performance.",
    "source": "metaprogramming_method_missing"
  },
  {
    "id": "re_010",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is define_method and what advantage does it provide over manually defining methods?",
    "ground_truth": "define_method is a metaprogramming method that creates methods dynamically at runtime. It allows programmatic method generation with closures that capture local variables, enabling more flexible and DRY code generation patterns.",
    "source": "metaprogramming_define_method"
  },
  {
    "id": "re_011",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is a mixin in Ruby and how are they implemented?",
    "ground_truth": "A mixin is code reuse mechanism using Modules to share behavior across unrelated classes via the 'include' (instance methods) or 'extend' (class methods) keywords. Mixins enable multiple inheritance of interface without the complications of true multiple inheritance.",
    "source": "mixins_modules"
  },
  {
    "id": "re_012",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is an open class in Ruby and what does reopening a class allow you to do?",
    "ground_truth": "Ruby allows reopening any class to add or modify methods and attributes. This enables monkey-patching to extend existing classes, which is powerful but risky for maintainability if overused.",
    "source": "open_classes_reopening"
  },
  {
    "id": "re_013",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is the Enumerable module and name three common methods it provides?",
    "ground_truth": "Enumerable is a core mixin module providing collection iteration methods. Common methods include map (transform elements), select (filter by condition), reduce (accumulate into single value), and each_with_index (iteration with index).",
    "source": "Enumerable_standard_library"
  },
  {
    "id": "re_014",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What are refinements in Ruby and what problem do they solve?",
    "ground_truth": "Refinements allow scoped monkey-patching that only applies within a specific scope (module or file). They solve the problem of monkey-patching affecting global behavior by limiting modifications to lexical scope, reducing conflicts and unintended side effects.",
    "source": "refinements_scoped_changes"
  },
  {
    "id": "re_015",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What does the frozen string literal comment do and how is it enabled?",
    "ground_truth": "The frozen string literal comment (# frozen_string_literal: true) at the top of a file makes all string literals in that file immutable by default. This improves memory efficiency and performance by preventing duplicate string objects.",
    "source": "frozen_string_literals"
  },
  {
    "id": "re_016",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is the role of garbage collection in Ruby and name one GC configuration method.",
    "ground_truth": "Garbage collection automatically reclaims unused memory. Developers can control GC behavior using methods like GC.start (force collection), GC.disable (pause automatic collection), or configuration via environment variables like RUBY_GC_HEAP_INIT_SLOTS.",
    "source": "garbage_collection_management"
  },
  {
    "id": "re_017",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is a Ruby gem and how does Bundler manage them?",
    "ground_truth": "A gem is a reusable Ruby package containing code, documentation, and metadata. Bundler is a dependency manager that reads Gemfile declarations, resolves version constraints, and ensures consistent gem installation across environments via Gemfile.lock.",
    "source": "Ruby_gems_Bundler"
  },
  {
    "id": "re_018",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is Rack and what role does it play in Ruby web frameworks?",
    "ground_truth": "Rack is a lightweight interface specification that standardizes communication between web servers and Ruby web applications. It enables compatibility between different servers (Puma, Unicorn) and frameworks (Rails, Sinatra) via a simple request/response abstraction.",
    "source": "Rack_web_interface"
  },
  {
    "id": "re_019",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "How does Rails integrate with Ruby's core features like metaprogramming and open classes?",
    "ground_truth": "Rails extensively uses metaprogramming (define_method for associations, method_missing for dynamic finders), open classes (extending String, Array), and mixins (ActiveSupport modules) to provide convenient DSLs and ORM functionality that abstract database interactions.",
    "source": "Rails_integration_metaprogramming"
  },
  {
    "id": "re_020",
    "domain": "ruby_expert",
    "difficulty": "easy",
    "question": "What is the purpose of the yield keyword and how does it relate to blocks?",
    "ground_truth": "yield calls the block passed to a method, executing the block's code in the method's context. It enables methods to accept reusable callback behavior, and combined with block_given?, allows optional block execution within method logic.",
    "source": "blocks_yield_callback"
  },
  {
    "id": "re_021",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "Explain the trade-offs between using Ractors versus Fibers for concurrent operations in Ruby 3.3+. When would you choose one over the other?",
    "ground_truth": "Ractors provide true parallelism with isolated memory (actor model), suitable for CPU-bound work, but have GIL-like restrictions and message-passing overhead. Fibers offer lightweight M:N scheduling for I/O-bound work with shared memory, no process overhead, but run in the same thread. Use Ractors for parallel computation, Fibers for async I/O.",
    "source": "ractors_fibers_concurrency"
  },
  {
    "id": "re_022",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "How does YJIT's warmup behavior affect Rails application startup time, and what configuration would you use to optimize it for a production server?",
    "ground_truth": "YJIT requires warmup time to compile frequently-used methods, causing slower initial requests. In production, use `--yjit-exec-mem-size` to allocate more compilation buffer, `--yjit-call-threshold` to lower compilation threshold, or prewarm critical paths. Disable YJIT during development if startup speed matters.",
    "source": "yjit_configuration_optimization"
  },
  {
    "id": "re_023",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "When using RBS type signatures, how do refinements interact with type checking, and what limitations exist when combining them?",
    "ground_truth": "RBS type checking is performed statically and doesn't recognize refinements at runtime since refinements have lexical scope. Type signatures defined in `.rbs` files won't reflect refinement changes; refinements are better for runtime behavior while RBS handles broader type contracts.",
    "source": "rbs_refinements_interaction"
  },
  {
    "id": "re_024",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "Describe how pattern matching with the `case/in` syntax differs from traditional case statements when dealing with complex nested structures and extracting values.",
    "ground_truth": "`case/in` performs structural pattern matching with destructuring, allowing extraction of nested values in one expression and guard clauses via `if`. Traditional `case/when` uses `===` operator matching without destructuring. Pattern matching is more expressive for complex data like hashes and arrays with guards.",
    "source": "pattern_matching_case_in"
  },
  {
    "id": "re_025",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "How does the Prism parser improve upon the traditional Ruby parser, and what implications does this have for metaprogramming or AST manipulation?",
    "ground_truth": "Prism is a more robust, portable parser written in C with Ruby bindings, providing better error recovery, faster parsing, and cross-platform consistency. It enables safer AST manipulation and code analysis tools. For metaprogramming, it offers cleaner reflection on code structure without relying on fragile eval patterns.",
    "source": "prism_parser_capabilities"
  },
  {
    "id": "re_026",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "Explain the difference between using `method_missing` and `define_method` for dynamic method creation. When would each approach be preferred?",
    "ground_truth": "`method_missing` intercepts undefined method calls at runtime without storing methods, useful for proxies and DSLs but slower for repeated calls. `define_method` actually creates method objects stored in the class, faster for frequently-called methods. Use `method_missing` for sparse/dynamic behavior, `define_method` for performance-critical dynamic method creation.",
    "source": "method_missing_define_method"
  },
  {
    "id": "re_027",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "How does frozen string literal behavior (`# frozen_string_literal: true`) impact memory usage, object identity, and backward compatibility in a large codebase?",
    "ground_truth": "Frozen string literals reduce memory by reusing identical string objects, improving GC pressure. Object identity changes: `.equal?` may differ for previously non-frozen strings. Backward compatibility issues arise if code relies on mutable strings or modifies literals. Gradual adoption mitigates risks.",
    "source": "frozen_string_literals"
  },
  {
    "id": "re_028",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "Describe how mixins and open classes enable metaprogramming in Rails. What are the performance and maintainability trade-offs?",
    "ground_truth": "Mixins (modules included into classes) and open classes allow adding behavior to existing classes (like ActiveRecord::Base). This enables Rails' elegant DSLs but obscures method sources, complicates debugging, and can cause namespace pollution. Trade-off: developer expressiveness vs. code clarity and implicit behavior.",
    "source": "mixins_open_classes_metaprogramming"
  },
  {
    "id": "re_029",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "How does Bundler's dependency resolution differ between `Gemfile.lock` being present versus absent? What risks exist when updating gems in production?",
    "ground_truth": "With `Gemfile.lock`, Bundler installs exact locked versions ensuring consistency. Without it, Bundler resolves dependencies fresh, potentially selecting different versions. Updating in production risks breaking changes; safe approach: test updates in staging, review changelogs, use `bundle update --conservative` for minimal version bumps.",
    "source": "bundler_dependency_management"
  },
  {
    "id": "re_030",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "Explain how Ruby's M:N thread scheduler (Green Threads context) interacts with system threads and Ractors in Ruby 3.3+. What constraints exist?",
    "ground_truth": "Ruby uses M:N scheduling where N user-level threads (Fibers) map to M system threads (Ractors). Each Ractor has its own GVL and thread scheduler. Constraints: Ractors cannot share mutable objects, Fibers within a Ractor cooperatively yield, blocking syscalls block the entire Ractor's thread pool.",
    "source": "mn_thread_scheduler"
  },
  {
    "id": "re_031",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "When using blocks versus procs in Ruby, what are the semantic differences regarding `return` behavior, and how does this affect control flow?",
    "ground_truth": "`return` in a block returns from the enclosing method, while `return` in a proc returns only from the proc. This makes blocks tightly coupled to their enclosing method (used in iterators), while procs are more independent. Lambdas behave like procs with strict argument checking and local returns.",
    "source": "blocks_procs_lambdas"
  },
  {
    "id": "re_032",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "How does the Enumerable module leverage blocks and the `each` method to provide composable lazy evaluation? What are the performance implications?",
    "ground_truth": "Enumerable provides methods like `map`, `select`, `reduce` that depend on `each` and yield blocks. Lazy evaluation via `Enumerable#lazy` defers computation until terminal operation, saving memory for large datasets. Trade-off: reduced memory vs. slight overhead from lazy wrappers; ideal for chained transformations on infinite/large collections.",
    "source": "enumerable_lazy_evaluation"
  },
  {
    "id": "re_033",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "Describe how refinements affect method lookup and visibility in Ruby. What are the limitations when using refinements with open classes?",
    "ground_truth": "Refinements modify method lookup in a lexical scope, shadowing methods only in that scope without affecting the global class. With open classes, refinements cannot fully control access since code outside the refinement scope accesses the non-refined behavior. They don't prevent monkey-patching; they add a refinement layer.",
    "source": "refinements_scoping"
  },
  {
    "id": "re_034",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "How does Rack middleware ordering impact Rails request/response cycle performance, and what debugging approach would you use to diagnose middleware issues?",
    "ground_truth": "Middleware executes in stack order on request (top-to-bottom), reverse on response. Early middleware (like logging) impacts all requests; misplaced middleware can bypass exception handling or add unnecessary overhead. Debug by inspecting `Rack::Builder` output or using middleware profiling to identify bottlenecks.",
    "source": "rack_middleware_ordering"
  },
  {
    "id": "re_035",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "Explain the interaction between garbage collection tuning and YJIT compilation in Ruby 3.3+. How might GC pauses affect JIT performance metrics?",
    "ground_truth": "YJIT allocates JIT code in memory, increasing heap pressure and GC frequency. Major GC pauses pause thread scheduler, affecting YJIT execution consistency. Tuning: increase `RUBY_GC_HEAP_GROWTH_MAX_SLOTS` to reduce GC frequency, monitor with `GC.stat` to correlate GC pauses with JIT throughput loss.",
    "source": "gc_yjit_interaction"
  },
  {
    "id": "re_036",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "How does Rails integrate Rack, and what role does the Rails middleware stack play in handling exceptions, authentication, and request preprocessing?",
    "ground_truth": "Rails wraps the application in Rack via `Rack::Handler`, building a middleware stack with `Rails::Engine` and custom middleware. Exception handling, authentication, and request filtering occur in middleware layers; proper ordering ensures exceptions are caught before authentication checks and logs are written after responses.",
    "source": "rails_rack_integration"
  },
  {
    "id": "re_037",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "What are the security and performance implications of using `send` or `method_missing` to dynamically call methods based on user input in a Rails controller?",
    "ground_truth": "Using `send` with user input risks arbitrary method execution and security vulnerabilities (e.g., calling private methods). `method_missing` adds method lookup overhead. Safer approach: whitelist allowed methods, use polymorphism or routing to dispatch requests, avoid dynamic method calls with untrusted input.",
    "source": "dynamic_method_security"
  },
  {
    "id": "re_038",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "Explain how RBS signatures interact with Rails models, and what tooling challenges exist when adding type safety to a legacy Rails application?",
    "ground_truth": "RBS can annotate ActiveRecord models, but dynamic attribute methods (from `attr_accessor` and database columns) require explicit `.rbs` definitions since they're generated at runtime. Challenges: Rails metaprogramming makes static analysis difficult, requires separate `.rbs` files for gems without type info, and type checking doesn't enforce Rails magic methods.",
    "source": "rbs_rails_integration"
  },
  {
    "id": "re_039",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "How would you design a thread-safe cache using Fibers and a shared Ractor in Ruby 3.3+? What synchronization primitives are necessary?",
    "ground_truth": "Create a Ractor to manage cache state with message-passing (thread-safe by design). Fibers can safely access the cache via Ractor messages without blocking other Fibers. Use `Ractor.receive` for requests and `Ractor.yield` for responses; deadlock requires careful message protocol design.",
    "source": "ractor_fiber_cache_design"
  },
  {
    "id": "re_040",
    "domain": "ruby_expert",
    "difficulty": "medium",
    "question": "What are the performance characteristics of pattern matching with multiple `case/in` branches versus a chain of `if/elsif` statements, and when would each be preferred?",
    "ground_truth": "Pattern matching compiles to optimized bytecode, often faster for complex structural matching with destructuring. `if/elsif` chains are faster for simple equality checks. Prefer pattern matching for extracting nested data and readability; use `if/elsif` for simple boolean conditions to avoid overhead.",
    "source": "pattern_matching_performance"
  },
  {
    "id": "re_041",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "Explain the performance implications of using YJIT with a large Rails application that has significant metaprogramming (define_method, method_missing) in its ActiveRecord models. What are the JIT compilation thresholds and how does polymorphic call site invalidation affect warm-up time?",
    "ground_truth": "YJIT performs best on monomorphic and polymorphic call sites but struggles with megamorphic sites common in metaprogramming-heavy code. Define_method and method_missing create indirect calls that are expensive to compile; YJIT uses a threshold (~1000 calls) before JIT-compiling methods. Polymorphic invalidation requires recompilation when receiver types change, impacting warm-up in Rails' dynamic nature. Use --yjit-stats to measure compilation time and coverage.",
    "source": "YJIT_JIT_compiler_performance"
  },
  {
    "id": "re_042",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "A Ractor-based system processes immutable data using pattern matching with case/in. How do you safely share complex objects between Ractors, and what are the pitfalls of using Ractor.make_shareable with frozen collections containing references to unfrozen objects?",
    "ground_truth": "Ractor.make_shareable recursively freezes objects, but fails if unfrozen objects are referenced (raises FrozenError). Only deeply frozen objects can be shared; nested hashes/arrays must have all descendants frozen. Prefer passing copies via Ractor#send or using Ractor-local storage for mutable state. Pattern matching on shareable objects works efficiently because Ractor eliminates GVL contention for isolated data.",
    "source": "Ractors_actor_based_parallelism_object_sharing"
  },
  {
    "id": "re_043",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "Describe the interaction between Ruby's M:N thread scheduler (introduced in 3.0), Fiber scheduling, and the GVL. When would you use Fiber#transfer vs Ractor, and what are the GVL implications for CPU-bound work using fibers?",
    "ground_truth": "M:N scheduling uses green threads (Fibers) on native OS threads; the GVL is still acquired per-thread but Fibers can yield without blocking OS threads. Fiber#transfer is synchronous and doesn't yield to scheduler; use for coroutines within a thread. Ractors eliminate GVL entirely for CPU-bound parallelism, while Fibers suit I/O concurrency. Fibers don't parallelize CPU work\u2014they require blocking calls (IO, sleep) to benefit from M:N scheduling.",
    "source": "M:N_thread_scheduler_fibers_GVL"
  },
  {
    "id": "re_044",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "You're debugging a Rails app where refinements are used to extend String with custom methods, but pattern matching in case/in statements doesn't respect the refined methods. Explain why and propose a solution.",
    "ground_truth": "Refinements are lexically scoped and don't apply in case/in pattern matching because pattern matching compiles to bytecode that operates at a different scope level than the refinement scope. Pattern matching uses Case nodes that bypass method lookup in refinement context. Solution: define the pattern logic inside a method in refinement scope, or refactor to use explicit guards in pattern matching instead of relying on refined methods.",
    "source": "refinements_pattern_matching_scope"
  },
  {
    "id": "re_045",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "In a Rack middleware stack, you're using Prism parser (Ruby 3.3+) to dynamically analyze and transform request bodies. What are the security implications of caching Prism ASTs without proper invalidation, and how does frozen string literals mode affect parsing performance?",
    "ground_truth": "Prism caching without invalidation risks serving stale ASTs if request bodies are mutated, exposing injection attacks. Frozen string literals (--enable-frozen-string-literal) improve Prism performance by ~10-15% because the parser avoids string duplication for identifiers and literals. Store cache keys using content hash, not request path. In Rack, parse requests in a Fiber to avoid GVL blocking on I/O.",
    "source": "Prism_parser_security_caching_frozen_strings"
  },
  {
    "id": "re_046",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "Explain how RBS type signatures interact with Ruby's method_missing and define_method, including the implications for type checking and IDE support. What limitations exist when defining types for dynamically-generated methods?",
    "ground_truth": "RBS cannot statically type method_missing because method names are unknown at parse time; you must use RBS's `%a{method_missing}` syntax or define explicit signatures for each dynamic method post-generation. Define_method-generated methods require manual RBS signatures outside the Ruby file using RBS files. IDE type checkers (Steep, Sorbet) cannot track method_missing unless you provide RBS stubs. This is a fundamental limitation of static typing with dynamic Ruby.",
    "source": "RBS_type_signatures_dynamic_methods"
  },
  {
    "id": "re_047",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "A Rails Gem uses open classes to monkey-patch Enumerable#select with custom lazy-evaluation logic. How does this interact with the garbage collector, and what are the performance implications if the patch captures references to large objects in its closure?",
    "ground_truth": "Monkey-patching Enumerable creates a closure in the module's scope that captures large objects, preventing GC collection until the method is unpatched or the app exits. Ruby's GC marks all live method objects and their closures; captured references delay collection. Performance degrades due to increased heap size and GC pause times. Solution: use refinements instead to scope the patch, or use Enumerable::Lazy without monkey-patching. Prefer composition over open classes in libraries.",
    "source": "open_classes_GC_closures"
  },
  {
    "id": "re_048",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "When using Bundler with Gemfile.lock, describe the edge case where a gem's native extension requires YJIT to be disabled, but your app relies on YJIT for performance. How would you resolve this conflict, and what are the trade-offs?",
    "ground_truth": "Some C extensions (e.g., old versions of json, mysql2) conflict with YJIT due to incompatible frame layout assumptions. Resolution: use bundle config set build.gemname --with-jit=no to disable JIT only for that gem, or upgrade the gem to a YJIT-compatible version. Trade-off: lose JIT benefits for non-extension code if conflict is severe. Alternative: use Bundler's local gem override or fork the gem. Check gem compatibility at bundler.io/guides/using_bundler_in_applications.",
    "source": "Bundler_YJIT_native_extensions_conflict"
  },
  {
    "id": "re_049",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "Design a pattern matching solution (case/in) that safely handles deserialization of untrusted JSON data while preventing code injection. How do RBS signatures and Prism AST validation reduce attack surface?",
    "ground_truth": "Use case/in to match specific JSON structure with guard clauses validating types and ranges, rejecting unexpected keys. Prism AST validation can detect and reject inputs that would eval() or execute arbitrary code. RBS signatures enforce that deserialized objects conform to expected types before use. Example: `case json in {user: {id: Integer => id, name: String => name}} then ...` with guards checking id > 0. Combine with JSON.parse(data, object_class: CustomClass) to limit deserialization scope.",
    "source": "pattern_matching_RBS_Prism_injection_prevention"
  },
  {
    "id": "re_050",
    "domain": "ruby_expert",
    "difficulty": "hard",
    "question": "A Rails engine uses mixins extensively with multiple inheritance chains (A < B < C < Module1, Module2) and defines methods via define_method in Module1. Explain method resolution order (MRO) ambiguities and how Prism's AST can be used to statically analyze and warn about hidden method overrides across the chain.",
    "ground_truth": "Ruby's MRO follows left-to-right, depth-first search (C3 linearization); with multiple mixins, method resolution is: Class \u2192 included modules (right-to-left) \u2192 superclass. Define_method in Module1 can shadow earlier definitions, causing subtle bugs if not documented. Prism can parse the AST to identify all define_method calls and their targets, then build a call graph to detect unintended shadowing. Traverse AST for DefNode and SendNode (for define_method), output warnings to static analysis tools. Use Steep with RBS to catch at type-check time.",
    "source": "MRO_mixins_define_method_static_analysis"
  }
]
