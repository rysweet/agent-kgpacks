[
  {
    "id": "ve_001",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What is the primary purpose of the package.json manifest in a VS Code extension?",
    "ground_truth": "The package.json manifest defines extension metadata (name, version, publisher), declares activation events, contribution points, and dependencies required for VS Code to load and run the extension.",
    "source": "extension_anatomy"
  },
  {
    "id": "ve_002",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What are activation events and why are they important in VS Code extensions?",
    "ground_truth": "Activation events are triggers (e.g., onCommand, onLanguage, onView) that specify when the extension's activate() function should be called, allowing VS Code to lazy-load extensions and improve startup performance.",
    "source": "activation_events"
  },
  {
    "id": "ve_003",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "Name three common contribution points that can be declared in package.json.",
    "ground_truth": "Common contribution points include commands, keybindings, views, languages, themes, snippets, and debuggers. Each defines a specific feature the extension contributes to the VS Code UI or functionality.",
    "source": "contribution_points"
  },
  {
    "id": "ve_004",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What is the purpose of the TreeDataProvider interface in VS Code extensions?",
    "ground_truth": "TreeDataProvider is an interface that defines how extension developers supply hierarchical data to tree views, implementing methods like getChildren() and getTreeItem() to populate the tree structure.",
    "source": "tree_views"
  },
  {
    "id": "ve_005",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What does asWebviewUri() do and why is it important for webview security?",
    "ground_truth": "asWebviewUri() transforms local URIs to special webview URIs that can safely load resources within a webview while respecting content security policies and preventing unauthorized access to extension resources.",
    "source": "webview_security"
  },
  {
    "id": "ve_006",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What is the difference between WebviewPanel and WebviewView in VS Code?",
    "ground_truth": "WebviewPanel is a standalone panel (like a tab or dialog) that can be closed, while WebviewView is a persistent view integrated into a specific sidebar or activity bar location.",
    "source": "webviews"
  },
  {
    "id": "ve_007",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What does LSP (Language Server Protocol) enable in VS Code extensions?",
    "ground_truth": "LSP enables separation of language features (completion, hover, diagnostics) from the editor by defining a protocol for communication between a language client and language server, allowing reuse across different editors.",
    "source": "language_server_protocol"
  },
  {
    "id": "ve_008",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What is the purpose of custom editors in VS Code extensions?",
    "ground_truth": "Custom editors allow extensions to define specialized editors for specific file types or content, providing a custom UI instead of using the default text editor for that resource.",
    "source": "custom_editors"
  },
  {
    "id": "ve_009",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What does the notebook API allow developers to do?",
    "ground_truth": "The notebook API enables extensions to create custom notebook experiences by defining notebook document providers, renderers for cell outputs, and kernel controllers for executing notebook cells.",
    "source": "notebook_api"
  },
  {
    "id": "ve_010",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What is the Debug Adapter Protocol (DAP) and what problem does it solve?",
    "ground_truth": "DAP is a protocol that standardizes communication between debuggers and editors, allowing debugger extensions to provide debugging capabilities for any language without coupling tightly to VS Code.",
    "source": "debugger_extensions"
  },
  {
    "id": "ve_011",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "How do task providers allow extensions to contribute custom tasks to VS Code?",
    "ground_truth": "Task providers implement the TaskProvider interface, exposing a provideTasks() method that returns an array of Task objects, allowing extensions to dynamically contribute build, test, or custom workflow tasks.",
    "source": "task_providers"
  },
  {
    "id": "ve_012",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What is the purpose of an SCM provider in VS Code?",
    "ground_truth": "An SCM (Source Control Management) provider enables extensions to integrate version control systems into VS Code's source control UI, displaying file status, changes, and providing version control operations.",
    "source": "scm_providers"
  },
  {
    "id": "ve_013",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What package does @vscode/test-electron provide for testing extensions?",
    "ground_truth": "@vscode/test-electron provides utilities and a test runner for running extension tests in a full VS Code instance, allowing developers to test extension functionality in a realistic environment.",
    "source": "testing_extensions"
  },
  {
    "id": "ve_014",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What is a web extension and what limitation does @vscode/test-web address?",
    "ground_truth": "A web extension is an extension that runs in VS Code for the Web using the web APIs, and @vscode/test-web provides testing utilities specifically for validating web extension functionality in a browser environment.",
    "source": "web_extensions"
  },
  {
    "id": "ve_015",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What is vsce and what is its primary function?",
    "ground_truth": "vsce (Visual Studio Code Extension) is a command-line tool that packages extensions into .vsix files and publishes them to the VS Code Marketplace for distribution.",
    "source": "marketplace_publishing"
  },
  {
    "id": "ve_016",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "Why do developers use bundlers like webpack or esbuild for VS Code extensions?",
    "ground_truth": "Bundlers like webpack or esbuild combine extension code and dependencies into optimized files, reducing file size and improving load times by tree-shaking unused code and minifying the output.",
    "source": "extension_bundling"
  },
  {
    "id": "ve_017",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What are two key UX guidelines developers should follow when building VS Code extensions?",
    "ground_truth": "Extensions should minimize startup impact through lazy loading, use clear and consistent naming in UI elements, avoid cluttering the command palette, and follow VS Code's theme and styling conventions.",
    "source": "ux_guidelines"
  },
  {
    "id": "ve_018",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What does remote development support in VS Code extensions enable?",
    "ground_truth": "Remote development support allows extensions to function correctly when VS Code connects to remote environments (SSH, containers, WSL), ensuring extension features work seamlessly regardless of where code is executed.",
    "source": "remote_development"
  },
  {
    "id": "ve_019",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "How do commands work in VS Code extensions and what is their basic structure?",
    "ground_truth": "Commands are registered via vscode.commands.registerCommand() with a command ID and callback function; they appear in the command palette and can be bound to keybindings for user invocation.",
    "source": "commands_keybindings"
  },
  {
    "id": "ve_020",
    "domain": "vscode_extensions",
    "difficulty": "easy",
    "question": "What is the activate() function and what must it do?",
    "ground_truth": "The activate() function is the entry point called when an extension is activated; it must register all commands, views, providers, and other features the extension contributes, and return a context object or undefined.",
    "source": "extension_anatomy"
  },
  {
    "id": "ve_021",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "In a VS Code extension's package.json, what is the relationship between activationEvents and the extension's startup performance, and why would you use onLanguage:javascript instead of *?",
    "ground_truth": "activationEvents control when the extension is loaded; using onLanguage:javascript activates only when JavaScript files are opened, reducing startup overhead compared to * which activates immediately. This lazy-loading pattern improves VS Code's performance by deferring non-essential extension initialization.",
    "source": "extension_activation_events"
  },
  {
    "id": "ve_022",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "You need to display a file tree structure in a custom sidebar using a TreeView. What interface must your data provider implement, and what is the relationship between getChildren() and getTreeItem()?",
    "ground_truth": "You must implement TreeDataProvider interface with methods like getChildren() and getTreeItem(). getChildren() returns child nodes for a given parent element, while getTreeItem() converts a data element into a TreeItem for rendering; together they form a hierarchy.",
    "source": "tree_views_treedataprovider"
  },
  {
    "id": "ve_023",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "When using WebviewPanel in your extension, why is asWebviewUri() critical for security when loading images or stylesheets, and what does it prevent?",
    "ground_truth": "asWebviewUri() converts local file paths to webview-safe URIs that work within the restricted webview context. It prevents direct file:// access which would bypass security policies, ensuring resources are served through VS Code's secure resource scheme.",
    "source": "webviews_security"
  },
  {
    "id": "ve_024",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "Your extension defines a command 'myext.helloWorld' in package.json contribution points and implements it in code. If a user never triggers the command, when does the command handler execute, and why might this be problematic?",
    "ground_truth": "The command handler executes only when explicitly triggered by the user or by other code. This is not problematic\u2014it's the intended behavior. However, if the extension isn't activated by then (activation event not met), the command will fail unless triggered in a way that first activates the extension.",
    "source": "commands_keybindings"
  },
  {
    "id": "ve_025",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "Explain the difference between implementing language features via the Language Server Protocol (LSP) versus implementing them directly using VS Code's vscode.languages API. When would you choose LSP?",
    "ground_truth": "LSP uses a separate language server process communicating over a protocol, enabling language features to run out-of-process and be reused across editors. Choose LSP when you need heavy computation, cross-editor support, or want to leverage existing language server implementations; use vscode.languages API for simple, lightweight features.",
    "source": "lsp_language_features"
  },
  {
    "id": "ve_026",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "When bundling a VS Code extension with webpack or esbuild, what is the primary reason to set the target to 'node' or 'webworker', and how does this affect bundle size?",
    "ground_truth": "Setting target to 'node' or 'webworker' ensures the bundler excludes browser-specific polyfills and uses appropriate module resolution. 'node' is for main/activation code running in Node.js, 'webworker' for web extensions; correct targeting reduces bundle size by eliminating unnecessary dependencies.",
    "source": "extension_bundling"
  },
  {
    "id": "ve_027",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "In custom editor implementation, what must you return from resolveCustomEditor(), and why is this different from simply returning the CustomDocument?",
    "ground_truth": "resolveCustomEditor() must set up the editor UI (typically a WebviewPanel or similar) but doesn't return anything (void). You store the connection between the document and UI, whereas returning the document would not associate it with the UI for rendering and interaction.",
    "source": "custom_editors"
  },
  {
    "id": "ve_028",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "You're using the Notebook API to create a notebook controller. What is the relationship between NotebookController and NotebookDocument, and what happens if multiple controllers support the same notebook type?",
    "ground_truth": "A NotebookController handles execution for a NotebookDocument; multiple controllers can support the same type, and VS Code lets users select which controller to use. The active controller provides execution for that notebook instance.",
    "source": "notebook_api"
  },
  {
    "id": "ve_029",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "When implementing a debugger extension using the Debug Adapter Protocol, what is the purpose of the DebugAdapterDescriptorFactory, and when would you return a SocketDebugAdapterDescriptor versus a ProcessDebugAdapterDescriptor?",
    "ground_truth": "DebugAdapterDescriptorFactory creates connections to the debug adapter. Use ProcessDebugAdapterDescriptor to spawn a child process running the adapter; use SocketDebugAdapterDescriptor to connect to an existing debug adapter listening on a port.",
    "source": "debugger_dap"
  },
  {
    "id": "ve_030",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "A TaskProvider extension must implement provideTask(). If a user runs a task via the command palette but no activationEvent triggers, what error will they encounter, and how do you prevent this?",
    "ground_truth": "The task will fail to run because the extension isn't active. Prevent this by adding 'onTaskType:yourTaskType' to activationEvents in package.json, ensuring the extension loads before task resolution is attempted.",
    "source": "task_providers"
  },
  {
    "id": "ve_031",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "When using WebviewView (sidebar/panel webview) instead of WebviewPanel, what lifecycle difference affects resource disposal, and why is this important?",
    "ground_truth": "WebviewView persists across visibility changes, so its visibility property toggles rather than disposal. You must manually dispose resources when visibility changes to false, whereas WebviewPanel is destroyed on close. This prevents memory leaks in long-running sidebars.",
    "source": "webviews_webviewview"
  },
  {
    "id": "ve_032",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "In package.json, contribution points like keybindings define when and where commands are available. What does the 'when' clause do, and why is using when:'editorFocus' better than when:'true' for editor commands?",
    "ground_truth": "The 'when' clause specifies conditions for UI visibility/enablement using context variables. 'editorFocus' ensures the command is available only when the editor has focus, preventing accidental execution and providing better UX by hiding irrelevant commands.",
    "source": "contribution_points_when"
  },
  {
    "id": "ve_033",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "You're testing your extension using @vscode/test-electron. What does runTests() expect as parameters, and why would you need to configure extensionDevelopmentPath and extensionTestsPath?",
    "ground_truth": "runTests() expects a TestRunnerOptions object with paths to the extension and test files. extensionDevelopmentPath points to your extension source, extensionTestsPath to test files. VS Code loads your extension from the dev path, then runs tests to verify functionality.",
    "source": "testing_test_electron"
  },
  {
    "id": "ve_034",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "When publishing an extension to the Marketplace using vsce, why is the version field in package.json critical, and what happens if you publish the same version twice?",
    "ground_truth": "The version field identifies the release; vsce uses it for package naming and upload. Publishing the same version twice will fail because the Marketplace rejects duplicate versions, requiring you to increment the version before republishing.",
    "source": "marketplace_vsce"
  },
  {
    "id": "ve_035",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "An extension supports both local and remote development (SSH, WSL, containers). What does remoteSupport in package.json actually control, and when is an extension executed on the remote machine versus the local machine?",
    "ground_truth": "remoteSupport specifies which execution hosts are supported ('local', 'remote', 'ui'); it controls whether the extension runs on the remote machine or locally. UI extensions run locally but interact with remote workspace; workspace extensions run on the remote host.",
    "source": "remote_development_support"
  },
  {
    "id": "ve_036",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "You're implementing an SCM provider using the SCM API. What is the role of SourceControlResourceGroup, and how does it relate to SourceControlResourceState for displaying file changes?",
    "ground_truth": "SourceControlResourceGroup organizes changes into logical groups (e.g., staged/unstaged); each group contains SourceControlResourceState items representing individual files. This hierarchy allows SCM providers to display complex change structures like Git's staging area.",
    "source": "scm_providers"
  },
  {
    "id": "ve_037",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "When developing a web extension using @vscode/test-web, what fundamental restriction prevents certain Node.js modules from being used, and how do you work around this limitation?",
    "ground_truth": "Web extensions run in a browser environment without access to Node.js APIs like fs or child_process. Work around this by using VS Code's API (which abstracts file access), or delegating to a backend service via HTTP/WebSocket for OS-specific operations.",
    "source": "web_extensions"
  },
  {
    "id": "ve_038",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "In the extension manifest, what does the engines field specify, and why is specifying an accurate minimum vscode version important for compatibility?",
    "ground_truth": "The engines field specifies the minimum VS Code version required (e.g., '>=1.50.0'). Accurate specification prevents users with older versions from installing incompatible extensions, and Marketplace uses it to enforce compatibility rules.",
    "source": "manifest_engines"
  },
  {
    "id": "ve_039",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "When using TreeView with reveal() method, what does it accomplish, and what must you consider about the extension's active state when calling it?",
    "ground_truth": "reveal() expands the tree hierarchy and scrolls to show a specific item in the view. Call it only after the extension is activated, as the TreeView may not exist yet. It's useful for programmatically navigating users to important items.",
    "source": "tree_views_reveal"
  },
  {
    "id": "ve_040",
    "domain": "vscode_extensions",
    "difficulty": "medium",
    "question": "An extension uses vscode.workspace.onDidChangeWorkspaceFolders event. Why is this event important for multi-folder workspace support, and what should your extension do when a folder is removed?",
    "ground_truth": "This event notifies when folders are added/removed in a multi-folder workspace, allowing extensions to manage per-folder state (like language servers or build configurations). When a folder is removed, clean up associated resources and stop monitoring that folder to prevent memory leaks.",
    "source": "workspace_multi_folder"
  },
  {
    "id": "ve_041",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "When implementing a TreeDataProvider that displays file system items with asynchronous child resolution, what are the performance and memory implications of calling getChildren() without proper caching, and how should you structure your refresh logic to avoid exponential tree traversals?",
    "ground_truth": "Without caching, each parent expansion triggers redundant I/O operations for child nodes. Implement memoization at the provider level and use TreeView.reveal() selectively with onDidChangeTreeData to emit granular refresh events on specific nodes rather than the entire tree root, preventing cascading re-evaluations.",
    "source": "TreeDataProvider_performance"
  },
  {
    "id": "ve_042",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "Explain the security vulnerability that arises when using string concatenation to construct HTML content in a WebviewPanel, and what does asWebviewUri() actually prevent versus what it does not prevent.",
    "ground_truth": "String concatenation allows arbitrary script injection if user content is unsanitized; asWebviewUri() only sanitizes file:// URIs to webview-compatible resource:// URIs but does NOT prevent inline script execution or DOM-based XSS. You must use Content Security Policy (CSP), sanitize HTML via libraries like DOMPurify, and avoid eval()-like patterns regardless of URI rewriting.",
    "source": "webview_security"
  },
  {
    "id": "ve_043",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "When implementing a Language Server Protocol (LSP) client in an extension, what are the failure modes if the server process crashes, and how should you handle reconnection logic while preventing resource leaks from orphaned server instances?",
    "ground_truth": "The LanguageClient must monitor the server process and implement exponential backoff reconnection with a maximum retry threshold to avoid spawn storms. Use onDidChangeState listeners to gracefully deactivate the extension on permanent failures, ensure all stdio streams are properly closed, and maintain a single client instance reference to prevent multiple orphaned processes.",
    "source": "LSP_client_reliability"
  },
  {
    "id": "ve_044",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "How do activation events interact with lazy-loaded extensions in VS Code, and what performance penalty occurs if your extension specifies overly broad activation events like '*' versus '**/package.json'?",
    "ground_truth": "The '*' activation event loads your extension on every editor open, blocking VS Code startup; '**/package.json' only activates on those file types. Overly broad events create startup lag and memory overhead. Use precise file patterns, command activation events, or view focus events instead; measure with vscode --prof-startup and adjust activation triggers to the minimal set.",
    "source": "activation_events_performance"
  },
  {
    "id": "ve_045",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "In a custom editor implementation, what are the lifecycle edge cases when a document is opened in multiple editor groups, and how does the CustomEditorProvider.resolveCustomEditor() method handle concurrent invocations?",
    "ground_truth": "CustomEditorProvider.resolveCustomEditor() is called once per editor group even for the same document; you must maintain a map of WebviewPanel instances keyed by editor group to sync state across panels. Each panel is independent; updates to the document must broadcast to all associated panels via postMessage, and cleanup must remove only the specific panel instance, not the document's provider.",
    "source": "custom_editors_lifecycle"
  },
  {
    "id": "ve_046",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "What are the architectural differences between implementing a feature as a DebugAdapter (Debug Adapter Protocol) versus a LanguageServer, and in what scenarios would using both simultaneously create resource contention?",
    "ground_truth": "Debug adapters manage execution flow (threads, breakpoints, stack frames) while language servers provide static analysis (diagnostics, completions). Both spawn separate processes; using both for the same language doubles memory footprint and IPC overhead. Mitigate by sharing a common server process with separate protocol listeners or embedding debug capabilities into the language server if the protocol supports it.",
    "source": "DAP_vs_LSP_architecture"
  },
  {
    "id": "ve_047",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "When bundling an extension with webpack or esbuild, what are the gotchas with native modules and how does the '@vscode/test-electron' test runner differ from '@vscode/test-web' in handling bundled code?",
    "ground_truth": "Native modules must be excluded from bundling (external: ['native-module']) and are only available in Node.js; '@vscode/test-electron' runs in a real Electron/Node.js environment so native modules work, while '@vscode/test-web' runs in a browser sandbox where native modules are unavailable. Web extensions must polyfill Node APIs or use pure JavaScript alternatives; test configuration must match the target runtime.",
    "source": "bundling_native_modules"
  },
  {
    "id": "ve_048",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "How does remote development (SSH, WSL, Container) affect extension execution context, and what breaks when an extension assumes synchronous file system access or hard-coded file paths?",
    "ground_truth": "Remote extensions run on the remote machine; local extensions cannot access remote files synchronously. Hardcoded paths (e.g., /home/user) fail across machines. Use workspace.fs APIs and URI schemes instead of fs.readFileSync(). Extensions must declare remoteExtensionKind in package.json; if omitted, the extension runs locally and cannot directly manipulate remote files, requiring a remote companion extension or LSP bridging.",
    "source": "remote_development_context"
  },
  {
    "id": "ve_049",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "In the Notebook API, what ordering guarantees exist for cell execution events (onDidChangeNotebookDocument, onDidExecuteNotebookCell), and how should you handle race conditions when the same cell is executed twice in rapid succession?",
    "ground_truth": "Events are queued but execution is asynchronous; rapid executions can interleave. Track execution IDs or timestamps per cell to ignore stale completion events. Use a queue-based executor that cancels prior pending executions for the same cell, and bind execution tokens to CancellationTokens so interrupted cells can clean up. Document the execution order explicitly in your NotebookController.",
    "source": "notebook_execution_ordering"
  },
  {
    "id": "ve_050",
    "domain": "vscode_extensions",
    "difficulty": "hard",
    "question": "When publishing an extension to the VS Code Marketplace via vsce, what breaking changes in package.json structure (engines.vscode, contributes schemas) can cause silent deployment failures or compatibility issues, and how do you validate the manifest before publishing?",
    "ground_truth": "engines.vscode must match your minimum supported version; vsce validates this but won't block an overstated version. Contribution points with invalid schema (e.g., malformed keybindings, missing command IDs) are silently ignored. Use vsce ls to verify packaged contents, run vscode --inspect-extensions to debug activation, and test in the target VS Code versions before publishing. Semantic versioning mismatches cause install failures on older clients.",
    "source": "marketplace_publishing_validation"
  }
]
