{"id": "ae_001", "domain": "autogen_expert", "difficulty": "easy", "question": "What is Microsoft AutoGen?", "ground_truth": "Microsoft AutoGen is a multi-agent AI framework for building conversational and event-driven agent systems. It enables developers to create complex AI systems where multiple agents collaborate through message passing and event handling.", "source": "AutoGen_Overview"}
{"id": "ae_002", "domain": "autogen_expert", "difficulty": "easy", "question": "What is the primary difference between AgentChat API and Core API in AutoGen?", "ground_truth": "AgentChat API provides high-level abstractions with preset behaviors for common agent patterns, while Core API is event-driven and uses message passing for more fine-grained control over agent interactions.", "source": "AgentChat_API"}
{"id": "ae_003", "domain": "autogen_expert", "difficulty": "easy", "question": "Name three built-in agent types in AutoGen.", "ground_truth": "Three built-in agent types are ConversableAgent, AssistantAgent, and UserProxyAgent. These provide common roles for multi-agent conversations.", "source": "Agents"}
{"id": "ae_004", "domain": "autogen_expert", "difficulty": "easy", "question": "What is a GroupChat in AutoGen?", "ground_truth": "GroupChat is a team mechanism in AutoGen that enables multiple agents to communicate together. It includes speaker selection logic to determine which agent speaks next and supports resuming conversations.", "source": "GroupChat"}
{"id": "ae_005", "domain": "autogen_expert", "difficulty": "easy", "question": "What does SelectorGroupChat do differently from standard GroupChat?", "ground_truth": "SelectorGroupChat uses a more sophisticated speaker selection strategy compared to standard GroupChat, allowing for dynamic and intelligent selection of which agent should speak next based on context.", "source": "SelectorGroupChat"}
{"id": "ae_006", "domain": "autogen_expert", "difficulty": "easy", "question": "What are code executors in AutoGen?", "ground_truth": "Code executors are components that safely execute code generated by AI agents. AutoGen supports multiple execution environments including Docker-based executors and local executors.", "source": "Code_Executors"}
{"id": "ae_007", "domain": "autogen_expert", "difficulty": "easy", "question": "What is MagenticOne in the AutoGen ecosystem?", "ground_truth": "MagenticOne is a pre-built multi-agent system in AutoGen designed to solve complex tasks through coordinated agent collaboration with predefined roles and communication patterns.", "source": "MagenticOne"}
{"id": "ae_008", "domain": "autogen_expert", "difficulty": "easy", "question": "Can AutoGen agents use custom functions?", "ground_truth": "Yes, AutoGen agents can use custom functions and tools. Developers can define and register custom functions to extend agent capabilities beyond built-in functionality.", "source": "Tools_and_Functions"}
{"id": "ae_009", "domain": "autogen_expert", "difficulty": "easy", "question": "What is AutoGen Studio?", "ground_truth": "AutoGen Studio is a no-code user interface that allows developers to build and configure multi-agent systems without writing code, making AutoGen more accessible to non-programmers.", "source": "AutoGen_Studio"}
{"id": "ae_010", "domain": "autogen_expert", "difficulty": "easy", "question": "What does the Extensions API in AutoGen enable?", "ground_truth": "The Extensions API allows customization of AutoGen's core components including LLM clients and code execution engines, enabling developers to integrate custom implementations.", "source": "Extensions_API"}
{"id": "ae_011", "domain": "autogen_expert", "difficulty": "easy", "question": "What major change did the v0.4 redesign introduce to AutoGen?", "ground_truth": "The v0.4 redesign introduced async messaging for improved performance and added cross-language support, making AutoGen more flexible for polyglot development environments.", "source": "v0.4_Redesign"}
{"id": "ae_012", "domain": "autogen_expert", "difficulty": "easy", "question": "What is state management in AutoGen agents?", "ground_truth": "State management in AutoGen refers to how agents track and maintain their internal state, conversation history, and context throughout their lifecycle and interactions.", "source": "State_Management"}
{"id": "ae_013", "domain": "autogen_expert", "difficulty": "easy", "question": "What is the migration path from AutoGen to Microsoft Agent Framework?", "ground_truth": "The migration path from AutoGen to Microsoft Agent Framework involves transitioning existing AutoGen applications to the newer Agent Framework while maintaining compatibility with core patterns and behaviors.", "source": "Migration_Path"}
{"id": "ae_014", "domain": "autogen_expert", "difficulty": "easy", "question": "What role does AssistantAgent play in a typical AutoGen conversation?", "ground_truth": "AssistantAgent is an agent type that typically represents an AI assistant role in conversations, capable of responding to prompts and performing tasks assigned by other agents.", "source": "AssistantAgent"}
{"id": "ae_015", "domain": "autogen_expert", "difficulty": "easy", "question": "What is UserProxyAgent used for?", "ground_truth": "UserProxyAgent acts as a proxy for human users in multi-agent systems, enabling human input and approval in automated agent conversations and workflows.", "source": "UserProxyAgent"}
{"id": "ae_016", "domain": "autogen_expert", "difficulty": "easy", "question": "What is ConversableAgent?", "ground_truth": "ConversableAgent is a foundational agent type in AutoGen that can engage in conversations with other agents through message passing and event-driven interactions.", "source": "ConversableAgent"}
{"id": "ae_017", "domain": "autogen_expert", "difficulty": "easy", "question": "How do teams work in AutoGen?", "ground_truth": "Teams in AutoGen are groupings of agents that work together to accomplish shared objectives. They manage coordination, communication, and task distribution among member agents.", "source": "Teams"}
{"id": "ae_018", "domain": "autogen_expert", "difficulty": "easy", "question": "What does speaker selection mean in AutoGen GroupChat?", "ground_truth": "Speaker selection is the mechanism in GroupChat that determines which agent should speak or act next in a multi-agent conversation, based on context and conversation state.", "source": "GroupChat_Speaker_Selection"}
{"id": "ae_019", "domain": "autogen_expert", "difficulty": "easy", "question": "What does resume functionality do in GroupChat?", "ground_truth": "Resume functionality in GroupChat allows a paused or interrupted conversation to continue from where it left off, maintaining context and conversation history.", "source": "GroupChat_Resume"}
{"id": "ae_020", "domain": "autogen_expert", "difficulty": "easy", "question": "How does Docker support code execution in AutoGen?", "ground_truth": "Docker support in AutoGen provides a containerized, isolated environment for safely executing code generated by agents, preventing system-level interference and improving security.", "source": "Docker_Code_Executor"}
{"id": "ae_021", "domain": "autogen_expert", "difficulty": "medium", "question": "What is the key architectural difference between the AgentChat API and the Core API in AutoGen?", "ground_truth": "The AgentChat API provides high-level, preset agent behaviors with simplified interfaces for common patterns, while the Core API is event-driven and based on message passing, offering lower-level control for custom agent workflows.", "source": "AgentChat_vs_Core_API"}
{"id": "ae_022", "domain": "autogen_expert", "difficulty": "medium", "question": "How does ConversableAgent differ from AssistantAgent in terms of conversation capabilities?", "ground_truth": "ConversableAgent is a base class that supports bidirectional conversation and customizable message handling, while AssistantAgent is a preset implementation of ConversableAgent designed specifically for LLM-based assistants with predefined behaviors.", "source": "Agent_Types"}
{"id": "ae_023", "domain": "autogen_expert", "difficulty": "medium", "question": "What role does UserProxyAgent play in multi-agent systems, and when would you use it instead of an AssistantAgent?", "ground_truth": "UserProxyAgent represents human input or external system participation in conversations. Use it when you need human-in-the-loop interaction, approval workflows, or to simulate user behavior in automated testing scenarios.", "source": "UserProxyAgent"}
{"id": "ae_024", "domain": "autogen_expert", "difficulty": "medium", "question": "Explain the speaker selection mechanism in GroupChat and how it impacts multi-agent conversations.", "ground_truth": "GroupChat uses a speaker selection algorithm (typically round-robin or LLM-based) to determine which agent speaks next based on message context and conversation history. This controls turn-taking and prevents all agents from responding simultaneously.", "source": "GroupChat_Speaker_Selection"}
{"id": "ae_025", "domain": "autogen_expert", "difficulty": "medium", "question": "What is the purpose of the resume functionality in GroupChat, and how does it affect agent coordination?", "ground_truth": "Resume functionality allows a GroupChat to continue from a previous conversation state, maintaining context and agent memory across sessions. This enables long-running conversations and debugging of multi-agent interactions without full restart.", "source": "GroupChat_Resume"}
{"id": "ae_026", "domain": "autogen_expert", "difficulty": "medium", "question": "How does SelectorGroupChat improve upon standard GroupChat for managing complex multi-agent scenarios?", "ground_truth": "SelectorGroupChat uses an LLM-based selector agent to make more intelligent speaker selection decisions based on conversation context, rather than simple round-robin, enabling better handling of complex reasoning tasks.", "source": "SelectorGroupChat"}
{"id": "ae_027", "domain": "autogen_expert", "difficulty": "medium", "question": "What are the trade-offs between Docker and local code executors in AutoGen, and when would you choose each?", "ground_truth": "Docker executors provide isolation and reproducibility but add overhead and complexity; local executors are faster and simpler but less safe and may affect system state. Use Docker for production/untrusted code, local for development/trusted code.", "source": "Code_Executors"}
{"id": "ae_028", "domain": "autogen_expert", "difficulty": "medium", "question": "How does MagenticOne differentiate itself as a multi-agent system, and what types of tasks is it optimized for?", "ground_truth": "MagenticOne is a specialized multi-agent system designed for complex web research and information retrieval tasks, using coordinated agents with specialized roles for browsing, analysis, and synthesis.", "source": "MagenticOne"}
{"id": "ae_029", "domain": "autogen_expert", "difficulty": "medium", "question": "Describe how tools and custom functions are integrated into AutoGen agents, and what flexibility this provides.", "ground_truth": "Tools and custom functions are registered with agents and made available through function calling capabilities in the LLM. This allows agents to invoke external services, compute resources, and domain-specific logic dynamically during conversations.", "source": "Tools_Custom_Functions"}
{"id": "ae_030", "domain": "autogen_expert", "difficulty": "medium", "question": "What state management strategies are available in AutoGen for maintaining agent memory across multiple conversations?", "ground_truth": "AutoGen supports state management through conversation history, agent memory buffers, and serialization of agent state to persistent storage. Teams can maintain context across sessions by reloading prior conversation states.", "source": "State_Management"}
{"id": "ae_031", "domain": "autogen_expert", "difficulty": "medium", "question": "How does AutoGen Studio enable no-code multi-agent system creation, and what are its limitations compared to programmatic approaches?", "ground_truth": "AutoGen Studio provides a visual UI for designing agents, teams, and workflows without coding. Limitations include reduced flexibility for complex custom logic, less granular control over agent behavior, and dependency on the UI for modifications.", "source": "AutoGen_Studio"}
{"id": "ae_032", "domain": "autogen_expert", "difficulty": "medium", "question": "What capabilities does the Extensions API provide, and how would you implement a custom LLM client using it?", "ground_truth": "The Extensions API allows registering custom LLM clients and code executors. Implement a custom LLM client by extending the base LLM interface and implementing required methods for model configuration, token counting, and response generation.", "source": "Extensions_API"}
{"id": "ae_033", "domain": "autogen_expert", "difficulty": "medium", "question": "Explain the key improvements introduced in the v0.4 redesign regarding async messaging and cross-language support.", "ground_truth": "v0.4 introduced true async messaging patterns for non-blocking agent communication and cross-language support through language-agnostic protocols, enabling AutoGen to work in polyglot environments.", "source": "v0.4_Redesign"}
{"id": "ae_034", "domain": "autogen_expert", "difficulty": "medium", "question": "What is the recommended migration path from AutoGen to the Microsoft Agent Framework, and what benefits does it provide?", "ground_truth": "The migration path involves mapping AutoGen agents to Agent Framework components, updating event handling to the new framework's patterns, and leveraging enhanced enterprise features like better state management and monitoring.", "source": "Migration_Path"}
{"id": "ae_035", "domain": "autogen_expert", "difficulty": "medium", "question": "How does termination handling work in multi-agent conversations, and what conditions can trigger conversation end?", "ground_truth": "Termination is controlled by termination handlers that evaluate conversation state against exit conditions such as message count limits, specific keywords, task completion signals, or user-defined logic.", "source": "Termination"}
{"id": "ae_036", "domain": "autogen_expert", "difficulty": "medium", "question": "What factors should be considered when selecting models for different agents in a team, and how does this impact system performance?", "ground_truth": "Consider task complexity, cost, latency, and capability requirements. Using smaller models for simple tasks and larger models for reasoning reduces costs and latency while maintaining quality. Model selection significantly impacts overall system performance and reliability.", "source": "Models"}
{"id": "ae_037", "domain": "autogen_expert", "difficulty": "medium", "question": "How are teams structured in AutoGen, and what are the benefits of organizing agents into teams versus flat multi-agent systems?", "ground_truth": "Teams organize agents with defined communication patterns and hierarchies. Benefits include better scalability, reduced message overhead, clearer responsibility separation, and improved debugging and monitoring of agent interactions.", "source": "Teams"}
{"id": "ae_038", "domain": "autogen_expert", "difficulty": "medium", "question": "In the context of research tasks, how would you design a multi-agent group chat to efficiently gather and synthesize information?", "ground_truth": "Design agents with specialized roles: researcher for gathering information, analyzer for evaluation, and synthesizer for summary. Use GroupChat or SelectorGroupChat to coordinate them, configure termination conditions for completion, and ensure tool integration for information retrieval.", "source": "Perform_Research_Multi_Agent"}
{"id": "ae_039", "domain": "autogen_expert", "difficulty": "medium", "question": "What are the key considerations for debugging multi-agent conversations in AutoGen, and how do the resume and logging features help?", "ground_truth": "Key considerations include tracking message flow, agent decision-making, and tool execution. Resume functionality allows replaying conversations from saved states, while logging features capture detailed execution traces for post-analysis and troubleshooting.", "source": "Debugging_Multi_Agent"}
{"id": "ae_040", "domain": "autogen_expert", "difficulty": "medium", "question": "How would you implement a custom agent behavior by extending ConversableAgent, and what methods must be overridden?", "ground_truth": "Extend ConversableAgent and override message handling methods like _on_message() or generate_reply() to customize response logic. Ensure proper event propagation and maintain compatibility with the message-passing framework.", "source": "Custom_Agent_Behavior"}
{"id": "ae_041", "domain": "autogen_expert", "difficulty": "hard", "question": "In AutoGen's v0.4 redesign, how does the async messaging architecture improve upon the synchronous message passing model, and what are the specific implications for handling long-running tool executions across distributed agent systems?", "ground_truth": "The v0.4 async messaging architecture enables non-blocking communication and concurrent agent operations, allowing long-running tool executions to proceed without halting other agents. This prevents deadlocks and improves throughput in distributed systems where latency varies, compared to the synchronous model which forces sequential blocking operations.", "source": "v0.4_redesign_async_messaging"}
{"id": "ae_042", "domain": "autogen_expert", "difficulty": "hard", "question": "Explain the fundamental architectural difference between the AgentChat API's preset behaviors and the Core API's event-driven message passing model. In what scenarios would you choose Core API over AgentChat despite higher implementation complexity?", "ground_truth": "AgentChat provides high-level abstractions with pre-configured agent behaviors (simple orchestration), while Core API offers low-level event-driven message passing for custom control. Choose Core API when requiring fine-grained control over message routing, custom termination logic, conditional branching, or integration with external event systems that AgentChat's presets cannot accommodate.", "source": "AgentChat_vs_CoreAPI"}
{"id": "ae_043", "domain": "autogen_expert", "difficulty": "hard", "question": "When using SelectorGroupChat with a custom speaker selection strategy, what are the potential failure modes related to agent availability and message context that could cause the selection function to deadlock or produce infinite loops? How should these be mitigated?", "ground_truth": "Failure modes include: (1) selection function always choosing unavailable agents, (2) circular dependencies in selection logic, (3) loss of conversation context during selection. Mitigate via: implementing timeout mechanisms, fallback selection strategies, maintaining accessible agent state tracking, and validation that selection logic eventually terminates and selects at least one available agent.", "source": "SelectorGroupChat_speaker_selection"}
{"id": "ae_044", "domain": "autogen_expert", "difficulty": "hard", "question": "Describe the security implications of using Docker code executors versus local code executors in AutoGen. What are the specific attack vectors for each, and how would you harden a production deployment handling untrusted LLM-generated code?", "ground_truth": "Docker executors provide isolation and prevent host system compromise but have container escape risks; local executors directly expose the host to arbitrary code execution. Harden production via: containerization with resource limits, read-only filesystems, network segmentation, code sandboxing, input validation before execution, audit logging, and running agents with minimal required privileges. Docker should be preferred for untrusted code.", "source": "code_executors_security"}
{"id": "ae_045", "domain": "autogen_expert", "difficulty": "hard", "question": "In a multi-agent conversation within GroupChat, explain how the resume functionality works when an agent goes offline and reconnects. What state information must be persisted, and what race conditions could occur if state synchronization is not properly managed?", "ground_truth": "Resume functionality persists conversation history, agent role definitions, and turn state. When reconnecting, the agent replays history and resumes from the last message. Race conditions occur if: (1) multiple agents receive the same message twice, (2) concurrent state updates conflict, (3) message ordering is violated. Mitigate via distributed consensus mechanisms, versioned message IDs, and atomic state commits before continuing conversation.", "source": "GroupChat_resume_state_management"}
{"id": "ae_046", "domain": "autogen_expert", "difficulty": "hard", "question": "How does ConversableAgent's tool registration and execution model differ from AssistantAgent, and what custom function signatures are required to ensure proper integration with the Extensions API for LLM clients?", "ground_truth": "ConversableAgent provides generic tool registration via callable functions; AssistantAgent has specialized OpenAI tool_choice behavior. Custom functions must accept standardized signatures: input parameters matching JSON schema, return serializable outputs, and handle exceptions gracefully. The Extensions API requires functions to conform to async/await patterns and provide proper type hints for schema generation.", "source": "ConversableAgent_tools_registration"}
{"id": "ae_047", "domain": "autogen_expert", "difficulty": "hard", "question": "Explain the performance and consistency trade-offs when choosing between multiple sequential two-agent conversations versus a single GroupChat with multiple agents. What metrics should guide this architectural decision?", "ground_truth": "Sequential conversations: lower context window pressure, simpler implementation, but longer total time (serial latency). GroupChat: parallel processing, shared context (avoids redundancy), but higher memory usage and complexity. Metrics: total execution time, token consumption, context window utilization, agent idle time, and consistency of shared knowledge. Choose sequential for token-constrained scenarios; GroupChat for collaborative complex reasoning.", "source": "Teams_architecture_tradeoffs"}
{"id": "ae_048", "domain": "autogen_expert", "difficulty": "hard", "question": "In the MagenticOne multi-agent system, how does the interaction between the Planner, WebSurfer, and Coder agents handle conflicting recommendations or divergent problem-solving approaches? What mechanisms prevent redundant work or contradictory actions?", "ground_truth": "MagenticOne uses hierarchical coordination where the Planner orchestrates task decomposition and agent assignments. Conflict prevention relies on: (1) explicit role separation (Planner owns strategy), (2) message passing through GroupChat ensuring all agents see decisions, (3) termination conditions that halt exploration once consensus is reached. Redundancy is mitigated through shared plan state and agent communication about completed subtasks.", "source": "MagenticOne_multi_agent_coordination"}
{"id": "ae_049", "domain": "autogen_expert", "difficulty": "hard", "question": "How does the migration path from AutoGen v0.3 AgentChat to the Microsoft Agent Framework differ in terms of state management, tool definitions, and orchestration patterns? What backward compatibility challenges would arise in a large production system?", "ground_truth": "Migration requires: converting agent state from implicit to explicit schema, refactoring tool definitions to comply with MAF's standardized interface, replacing GroupChat orchestration with MAF's native orchestration. Backward compatibility challenges include: tool function signature changes, loss of custom termination logic, timeout behavior differences, and serialization format incompatibilities. Phased migration or adapter layers are recommended.", "source": "migration_to_agent_framework"}
{"id": "ae_050", "domain": "autogen_expert", "difficulty": "hard", "question": "When using AutoGen Studio's no-code UI to generate agent configurations, what are the limitations in expressing complex conditional logic, dynamic tool selection, and state-dependent behavior that would necessitate dropping down to code-based configuration?", "ground_truth": "AutoGen Studio limitations: (1) predefined agent templates cannot express custom conditional routing, (2) static tool registration lacks dynamic selection based on runtime state, (3) termination conditions are template-limited, (4) state management is implicit and not customizable. Complex logic requires code to implement: custom speaker selection functions, conditional tool availability, state machines, and cross-agent state synchronization.", "source": "AutoGen_Studio_limitations"}
