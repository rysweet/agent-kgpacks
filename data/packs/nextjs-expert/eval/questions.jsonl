{"id": "ne_001", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is the primary purpose of Next.js?", "ground_truth": "Next.js is a React framework that enables production-grade applications by providing server-side rendering (SSR), static site generation (SSG), and API routes built on top of React.", "source": "core_framework"}
{"id": "ne_002", "domain": "nextjs_expert", "difficulty": "easy", "question": "What does SSR stand for in the context of Next.js?", "ground_truth": "SSR stands for Server-Side Rendering, a technique where Next.js renders React components on the server and sends pre-rendered HTML to the client.", "source": "rendering_modes"}
{"id": "ne_003", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is Static Site Generation (SSG) in Next.js?", "ground_truth": "SSG is a rendering method where Next.js pre-renders pages at build time and serves them as static HTML files, improving performance and SEO.", "source": "rendering_modes"}
{"id": "ne_004", "domain": "nextjs_expert", "difficulty": "easy", "question": "Which folder structure is used for file-based routing in Next.js?", "ground_truth": "Next.js uses the `pages` directory (or `app` directory in Next.js 13+) where the file structure automatically maps to URL routes.", "source": "routing"}
{"id": "ne_005", "domain": "nextjs_expert", "difficulty": "easy", "question": "What file name is reserved for API route handlers in the pages directory?", "ground_truth": "Files named `api/*.js` or `api/*.ts` in the pages directory are automatically treated as serverless API endpoints that handle HTTP requests.", "source": "api_routes"}
{"id": "ne_006", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is the `getStaticProps` function used for in Next.js?", "ground_truth": "`getStaticProps` is a Next.js function that runs at build time to fetch data and pass it as props to a page, enabling static generation with dynamic data.", "source": "data_fetching"}
{"id": "ne_007", "domain": "nextjs_expert", "difficulty": "easy", "question": "What does the `getServerSideProps` function do?", "ground_truth": "`getServerSideProps` fetches data on every request at runtime, allowing you to render pages with server-side data on each HTTP request.", "source": "data_fetching"}
{"id": "ne_008", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is incremental static regeneration (ISR) in Next.js?", "ground_truth": "ISR allows static pages to be regenerated on-demand after deployment, combining the benefits of static generation with the ability to update content without rebuilding.", "source": "rendering_modes"}
{"id": "ne_009", "domain": "nextjs_expert", "difficulty": "easy", "question": "How do you define dynamic routes in Next.js?", "ground_truth": "Dynamic routes are created using square bracket syntax, such as `[id].js` or `[slug].js`, which captures URL parameters as route variables.", "source": "routing"}
{"id": "ne_010", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is the purpose of the `next.config.js` file?", "ground_truth": "The `next.config.js` file is used to configure Next.js build behavior, including webpack settings, environment variables, and custom server configurations.", "source": "configuration"}
{"id": "ne_011", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is the App Router in Next.js 13+?", "ground_truth": "The App Router is a new routing system introduced in Next.js 13 that uses the `app` directory and supports layouts, nested routing, and improved data fetching patterns.", "source": "routing"}
{"id": "ne_012", "domain": "nextjs_expert", "difficulty": "easy", "question": "What are middleware in Next.js used for?", "ground_truth": "Middleware in Next.js allows you to run code before a request completes, enabling authentication checks, request logging, and request/response manipulation.", "source": "middleware"}
{"id": "ne_013", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is the Image component in Next.js?", "ground_truth": "The Next.js Image component (`next/image`) optimizes images automatically with lazy loading, responsive sizing, and modern format conversion for better performance.", "source": "optimization"}
{"id": "ne_014", "domain": "nextjs_expert", "difficulty": "easy", "question": "What does the `useRouter` hook provide in Next.js?", "ground_truth": "The `useRouter` hook from `next/router` provides access to the Next.js router object, allowing you to navigate programmatically and access route parameters.", "source": "routing"}
{"id": "ne_015", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is the purpose of the public folder in a Next.js project?", "ground_truth": "The `public` folder stores static assets like images, fonts, and documents that are served directly without processing and referenced from the root path.", "source": "project_structure"}
{"id": "ne_016", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is automatic code splitting in Next.js?", "ground_truth": "Automatic code splitting breaks the JavaScript bundle into separate chunks per page, so each page only loads the code it needs, improving initial load performance.", "source": "optimization"}
{"id": "ne_017", "domain": "nextjs_expert", "difficulty": "easy", "question": "What environment variables file should be used for sensitive secrets in Next.js?", "ground_truth": "The `.env.local` file should be used for sensitive environment variables as it is not committed to version control, unlike `.env.local.example`.", "source": "configuration"}
{"id": "ne_018", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is the Link component in Next.js used for?", "ground_truth": "The Link component from `next/link` enables client-side navigation between pages with prefetching enabled by default for better performance.", "source": "routing"}
{"id": "ne_019", "domain": "nextjs_expert", "difficulty": "easy", "question": "What does the revalidate option in getStaticProps do?", "ground_truth": "The `revalidate` option specifies the time (in seconds) after which a statically generated page should be regenerated, enabling incremental static regeneration.", "source": "data_fetching"}
{"id": "ne_020", "domain": "nextjs_expert", "difficulty": "easy", "question": "What is the default port that Next.js development server runs on?", "ground_truth": "Next.js development server runs on port 3000 by default, accessible via `http://localhost:3000`, though this can be changed with the `-p` flag.", "source": "development"}
{"id": "ne_021", "domain": "nextjs_expert", "difficulty": "medium", "question": "Explain the difference between getStaticProps and getServerSideProps in Next.js and when you would use each approach.", "ground_truth": "getStaticProps generates static HTML at build time and revalidates on-demand or at intervals (ISR), best for content that changes infrequently. getServerSideProps runs on every request, allowing dynamic data fetching, but with higher latency and server load. Use getStaticProps for performance; use getServerSideProps when real-time data is required.", "source": "data_fetching"}
{"id": "ne_022", "domain": "nextjs_expert", "difficulty": "medium", "question": "What is Incremental Static Regeneration (ISR) and how does it improve upon traditional static generation?", "ground_truth": "ISR allows static pages to be regenerated in the background after a specified revalidation interval without rebuilding the entire site. This combines the benefits of static generation (fast CDN caching) with the flexibility of server-side rendering (fresh data), reducing build times and enabling near-real-time updates.", "source": "isr"}
{"id": "ne_023", "domain": "nextjs_expert", "difficulty": "medium", "question": "How does Next.js handle image optimization, and what are the benefits of using the Image component?", "ground_truth": "The Next.js Image component automatically optimizes images by serving modern formats (WebP), resizing for different devices, and implementing lazy loading. Benefits include automatic srcset generation, reduced bandwidth, improved Core Web Vitals, and prevention of Cumulative Layout Shift (CLS).", "source": "image_optimization"}
{"id": "ne_024", "domain": "nextjs_expert", "difficulty": "medium", "question": "Describe the purpose of middleware in Next.js 13+ and provide an example use case.", "ground_truth": "Middleware in Next.js runs before request processing, allowing you to modify requests/responses or redirect users. Common use cases include authentication checks, setting custom headers, implementing feature flags, rate limiting, or redirecting based on user locale or device type.", "source": "middleware"}
{"id": "ne_025", "domain": "nextjs_expert", "difficulty": "medium", "question": "What is the App Router and how does it differ from the Pages Router in terms of file structure and capabilities?", "ground_truth": "The App Router (introduced in Next.js 13) uses a file-based routing system in the app/ directory with layout.js and page.js conventions, supports React Server Components by default, and provides better organization for nested routes. The Pages Router uses files in pages/ directory and is client-centric. App Router offers improved performance and developer experience.", "source": "routing"}
{"id": "ne_026", "domain": "nextjs_expert", "difficulty": "medium", "question": "Explain React Server Components (RSC) and their advantages in the context of Next.js.", "ground_truth": "RSCs are React components that run exclusively on the server, allowing direct database access and keeping sensitive data server-side without exposing it to clients. Advantages include reduced JavaScript bundle size, improved security, direct backend access, and better performance since rendering happens server-side.", "source": "server_components"}
{"id": "ne_027", "domain": "nextjs_expert", "difficulty": "medium", "question": "How does Next.js handle dynamic routes, and what is the difference between [id] and [...slug] syntax?", "ground_truth": "[id] matches a single dynamic segment (e.g., /posts/1), while [...slug] is a catch-all route that matches multiple segments (e.g., /docs/getting-started/installation). The catch-all route collects all remaining path segments into an array, useful for breadcrumb structures or nested documentation sites.", "source": "dynamic_routes"}
{"id": "ne_028", "domain": "nextjs_expert", "difficulty": "medium", "question": "What are API Routes in Next.js and how would you secure them?", "ground_truth": "API Routes are serverless functions in the api/ directory that handle HTTP requests without setting up a separate backend. Secure them by validating input, implementing authentication tokens (JWT), using environment variables for secrets, rate limiting, CORS configuration, and adding authorization checks based on user roles.", "source": "api_routes"}
{"id": "ne_029", "domain": "nextjs_expert", "difficulty": "medium", "question": "Explain the concept of Static Site Generation (SSG) and its trade-offs compared to dynamic rendering.", "ground_truth": "SSG pre-builds pages at build time as static HTML files, providing fast load times and reduced server cost. Trade-offs include longer build times for large sites, inability to serve real-time data without ISR, and rebuild requirements for content updates. Best for content-heavy sites with infrequent changes.", "source": "static_generation"}
{"id": "ne_030", "domain": "nextjs_expert", "difficulty": "medium", "question": "How does Next.js handle environment variables, and what is the difference between .env.local and .env.production?", "ground_truth": ".env.local contains variables for all environments and is git-ignored. .env.production is loaded in production builds, .env.development in dev mode. Variables prefixed with NEXT_PUBLIC_ are exposed to the browser; others remain server-only. Next.js automatically loads appropriate files based on NODE_ENV.", "source": "environment_variables"}
{"id": "ne_031", "domain": "nextjs_expert", "difficulty": "medium", "question": "What is the purpose of next.config.js and provide three configuration examples.", "ground_truth": "next.config.js customizes Next.js behavior. Examples: redirects/rewrites for URL mapping, webpack config for bundler customization, env variables exposure, image optimization settings, i18n configuration, and build optimizations. This file is evaluated at build and server startup.", "source": "configuration"}
{"id": "ne_032", "domain": "nextjs_expert", "difficulty": "medium", "question": "Explain the difference between shallow routing and regular routing in Next.js.", "ground_truth": "Shallow routing allows updating the URL without re-running getServerSideProps or getStaticProps, useful for modal overlays or filters. However, this approach is less commonly used in modern Next.js with App Router. Regular routing reruns data fetching methods and provides full URL state management with better SEO.", "source": "routing"}
{"id": "ne_033", "domain": "nextjs_expert", "difficulty": "medium", "question": "How does Next.js implement automatic code splitting and what are its benefits?", "ground_truth": "Next.js automatically splits code by page, loading only the JavaScript needed for each route. Benefits include smaller initial bundle sizes, faster page loads, improved Core Web Vitals, and better caching. Third-party libraries are also split into separate chunks for optimized caching strategies.", "source": "code_splitting"}
{"id": "ne_034", "domain": "nextjs_expert", "difficulty": "medium", "question": "Explain how to implement client-side data fetching in Next.js and when it's appropriate to use.", "ground_truth": "Use fetch, SWR, or React Query hooks within useEffect in client components. Appropriate for user-specific data, real-time updates, or data that changes frequently. Less ideal for SEO-critical content or initial page load performance, but good for interactive features like dashboards or personalized content.", "source": "data_fetching"}
{"id": "ne_035", "domain": "nextjs_expert", "difficulty": "medium", "question": "What is the difference between <Link> component and regular <a> tags in Next.js, and why should you use Link?", "ground_truth": "The <Link> component enables client-side navigation without full page reloads, improving performance and UX. It prefetches linked pages by default, manages history state, and works with dynamic routes. Regular <a> tags trigger full page reloads, losing application state and client-side context.", "source": "navigation"}
{"id": "ne_036", "domain": "nextjs_expert", "difficulty": "medium", "question": "How does Next.js optimize CSS, and what CSS solutions are recommended for production applications?", "ground_truth": "Next.js supports CSS Modules, global CSS, and CSS-in-JS solutions. It automatically minifies and bundles CSS, and supports PostCSS. Recommended for production: CSS Modules for component isolation, Tailwind CSS for utility-first styling, or styled-components for dynamic styling. Avoid inline styles and unused CSS.", "source": "styling"}
{"id": "ne_037", "domain": "nextjs_expert", "difficulty": "medium", "question": "Explain how Next.js handles font optimization and its impact on performance.", "ground_truth": "Next.js automatically optimizes fonts by self-hosting and using font-display: swap to prevent layout shifts. The next/font package allows you to import Google Fonts or local fonts with zero layout shift (CLS improvement). This reduces external requests and improves Core Web Vitals.", "source": "font_optimization"}
{"id": "ne_038", "domain": "nextjs_expert", "difficulty": "medium", "question": "What is the purpose of the _app.js (or layout.js in App Router) file and what can you configure there?", "ground_truth": "This file wraps all pages, allowing global configurations like layout components, global CSS imports, authentication checks, analytics setup, and theme providers. In App Router, use layout.js for consistent UI structure across routes. This is the appropriate place for shared context providers and error boundaries.", "source": "app_structure"}
{"id": "ne_039", "domain": "nextjs_expert", "difficulty": "medium", "question": "How does Next.js handle internationalization (i18n), and what are the deployment considerations?", "ground_truth": "Next.js supports i18n through sub-path routing (/en/page, /fr/page) or domain routing. Libraries like next-i18next automate this. Deployment considerations include serving correct language based on Accept-Language header, SEO optimization per locale, and CDN caching for each language variant.", "source": "internationalization"}
{"id": "ne_040", "domain": "nextjs_expert", "difficulty": "medium", "question": "Describe the Next.js deployment options and trade-offs between Vercel, self-hosting, and other platforms.", "ground_truth": "Vercel (official platform) provides seamless deployments, automatic scaling, and optimal defaults. Self-hosting offers more control but requires infrastructure management. Other platforms (AWS, Docker, etc.) provide flexibility but require custom configuration. Vercel is fastest to deploy; self-hosting offers cost control; Docker provides portability.", "source": "deployment"}
{"id": "ne_041", "domain": "nextjs_expert", "difficulty": "hard", "question": "When using Next.js App Router with Server Components, how does the framework handle hydration mismatches between server-rendered content and client-side JavaScript, and what are the performance implications of using 'use client' boundary placement?", "ground_truth": "Next.js uses a selective hydration strategy where only Client Components marked with 'use client' are hydrated on the client. Hydration mismatches occur when server and client render different content; Next.js logs warnings in development. Strategic 'use client' placement at leaf components minimizes JavaScript bundles sent to the client, improving Core Web Vitals by reducing Largest Contentful Paint (LCP) and reducing Time to Interactive (TTI).", "source": "app_router_hydration"}
{"id": "ne_042", "domain": "nextjs_expert", "difficulty": "hard", "question": "Explain the interaction between Next.js incremental static regeneration (ISR), revalidation strategies, and the cache() function in Server Components. How do you resolve conflicts when using both on-demand and time-based revalidation?", "ground_truth": "ISR uses revalidatePath() or revalidateTag() for on-demand revalidation and the 'revalidate' export for time-based. The cache() function in Server Components caches fetch requests per-request by default. Conflicts arise when mixing strategies; prioritize revalidateTag() with strategic tagging for fine-grained control, and avoid cache('force-cache') on dynamic data. Background Revalidation (PPR) reconciles this by allowing stale-while-revalidate patterns.", "source": "isr_revalidation_caching"}
{"id": "ne_043", "domain": "nextjs_expert", "difficulty": "hard", "question": "How does Next.js handle concurrent rendering and request deduplication in Server Components when multiple parallel routes or dynamic segments trigger the same asynchronous data fetches, and what are the optimization strategies?", "ground_truth": "Next.js automatically deduplicates identical fetch requests within the same render pass using a request memoization layer. With parallel routes, duplicate fetches across segments are collapsed into a single network request. Use React's cache() wrapper for custom async functions to achieve similar deduplication. For distributed cache invalidation across replicas, implement consistent tagging with revalidateTag() and coordinate via a shared cache layer.", "source": "request_deduplication_parallel_routes"}
{"id": "ne_044", "domain": "nextjs_expert", "difficulty": "hard", "question": "What are the security implications of using Next.js API Routes with dynamic routing (e.g., /api/[id]/route.ts), and how should you implement authorization to prevent IDOR vulnerabilities while maintaining performance?", "ground_truth": "Dynamic API Routes are vulnerable to Insecure Direct Object Reference (IDOR) if authorization is not enforced per-request. Implement middleware-based session validation using NextAuth.js or a custom auth provider, verify user ownership of the resource before returning data, and avoid relying solely on obscure IDs. Use secure cookies with httpOnly flag, validate UUIDs over sequential IDs, and rate-limit endpoints to mitigate enumeration attacks.", "source": "api_route_security_idor"}
{"id": "ne_045", "domain": "nextjs_expert", "difficulty": "hard", "question": "Describe the execution model differences between getServerSideProps, getStaticProps, and Server Components in terms of when code runs, secret exposure risks, and how to securely handle environment variables across rendering strategies.", "ground_truth": "getServerSideProps runs on every request on the server (exposing secrets safely), getStaticProps runs at build-time (secure for build secrets), and Server Components run on-demand on the server. Secrets in getServerSideProps are safe as code doesn't ship to client. Use NEXT_PUBLIC_ prefix only for client-visible variables; Server Components automatically exclude non-public vars from client bundles. Avoid using secrets in getStaticProps unless using on-demand ISR with proper request validation.", "source": "rendering_secrets_environment"}
{"id": "ne_046", "domain": "nextjs_expert", "difficulty": "hard", "question": "How does Next.js Edge Runtime differ from Node.js Runtime in App Router, and what are the constraints when implementing authentication middleware with Edge Functions? When should you choose one over the other?", "ground_truth": "Edge Runtime runs on Cloudflare Workers/Vercel Edge with limited APIs (no filesystem, limited Node.js modules), lower cold starts, and global distribution. Node.js Runtime offers full Node.js APIs and native database drivers. For auth middleware, Edge Functions are optimal for lightweight JWT verification and redirects, but require Edge-compatible crypto libraries. Use Edge for session validation only; offload complex auth logic to API Routes in Node.js Runtime to avoid bundle size and compatibility issues.", "source": "edge_runtime_middleware"}
{"id": "ne_047", "domain": "nextjs_expert", "difficulty": "hard", "question": "Explain the streaming architecture in Next.js (Suspense boundaries, React Server Components), including how selective preloading and progressive HTML delivery impact perceived performance and SEO implications.", "ground_truth": "Streaming sends HTML chunks as they're ready, unblocking browser rendering via Suspense boundaries around async components. Boundaries wrap slow data fetches, rendering fallback UI immediately while data loads server-side. This improves First Contentful Paint (FCP) and perceived performance. SEO risk exists if critical content is behind Suspense without initial server-rendering; crawlers may miss streamed content depending on implementation. Use dynamic imports strategically and ensure critical content above-the-fold doesn't stream.", "source": "streaming_suspense_seo"}
{"id": "ne_048", "domain": "nextjs_expert", "difficulty": "hard", "question": "When building a multi-tenant Next.js application with dynamic subdomains or path-based routing, how do you handle tenant isolation, data segregation, and prevent cross-tenant data leaks in Server Components and API Routes?", "ground_truth": "Extract tenant context from hostname (middleware) or URL path, validate and memoize it per-request using headers() or params. Enforce tenant filters in all database queries by appending tenant_id WHERE clauses; never rely on client-provided identifiers. Use request-scoped context (AsyncLocalStorage or middleware state) to propagate tenant info to nested components/functions. Implement audit logging for cross-tenant access attempts, and use separate databases per tenant for maximum isolation if compliance requires it.", "source": "multi_tenant_isolation"}
{"id": "ne_049", "domain": "nextjs_expert", "difficulty": "hard", "question": "How does Next.js handle Module Federation and Micro Frontends at scale? What are the trade-offs between dynamic imports, build-time federation, and runtime federation in the context of App Router?", "ground_truth": "Next.js supports dynamic imports (next/dynamic) for lazy-loading remote modules but lacks native Module Federation support. Build-time federation couples deployment cycles; runtime federation (via third-party tools or custom solutions) allows independent deployment but adds network latency and version mismatch risks. With App Router, prefer colocated feature modules and shared package management over federation unless teams require strict deployment autonomy. Version management and hydration mismatches become critical with federation across routes.", "source": "module_federation_micro_frontends"}
{"id": "ne_050", "domain": "nextjs_expert", "difficulty": "hard", "question": "Describe the deployment and configuration differences when running Next.js in serverless (Vercel, AWS Lambda), containerized (Docker), and self-hosted Node.js environments. What are the implications for database connection pooling, warm starts, and resource constraints?", "ground_truth": "Serverless functions have cold start penalties (mitigated via provisioned concurrency) and no persistent connections; use connection pooling (PgBouncer, Prisma connection pooling) with short timeouts. Containerized environments support persistent connections and longer request lifetimes but require resource management and orchestration. Self-hosted offers full control but requires DevOps overhead. Each affects: streaming response limits (serverless has strict timeouts), environment variable injection, secret management, and file system access (ephemeral in serverless).", "source": "deployment_environments_constraints"}
