{"id": "ge_001", "domain": "go_expert", "difficulty": "easy", "question": "What does the `maps.Keys` function from Go 1.21's `maps` package return, and is the order of returned keys guaranteed?", "ground_truth": "`maps.Keys[M ~map[K]V, K comparable, V any](m M) []K` returns a slice of all keys in the map. The order is explicitly not guaranteed and may differ between calls, consistent with Go's unordered map semantics. This function is part of the `maps` standard library package added in Go 1.21.", "source": "maps_package_go_1_21"}
{"id": "ge_002", "domain": "go_expert", "difficulty": "easy", "question": "What does `maps.Clone` from Go 1.21's `maps` package do, and what kind of copy does it perform?", "ground_truth": "`maps.Clone[M ~map[K]V](m M) M` returns a new map with the same key-value pairs as the original. It performs a shallow copy: keys and values are copied directly, but if values are pointers, slices, or maps, the clone shares the same underlying data as the original. It is part of the `maps` package added in Go 1.21.", "source": "maps_package_go_1_21"}
{"id": "ge_003", "domain": "go_expert", "difficulty": "easy", "question": "What Go version introduced range-over-func iterators?", "ground_truth": "Go 1.23 introduced range-over-func iterators, allowing custom iteration patterns by ranging over function types that yield values.", "source": "range_over_func"}
{"id": "ge_004", "domain": "go_expert", "difficulty": "easy", "question": "What does the slices.All iterator function return in Go 1.23?", "ground_truth": "slices.All returns an iterator function that yields each element and its index from a slice, enabling for...range loops over slice indices and values.", "source": "range_over_func_slices"}
{"id": "ge_005", "domain": "go_expert", "difficulty": "easy", "question": "What is the primary advantage of using slog for structured logging in Go?", "ground_truth": "slog provides structured logging with key-value pairs, multiple output formats (JSON, text), and context integration, making logs machine-readable and easier to query.", "source": "slog_structured_logging"}
{"id": "ge_006", "domain": "go_expert", "difficulty": "easy", "question": "Name the two main handler types provided by the slog package.", "ground_truth": "slog provides JSONHandler for JSON-formatted logs and TextHandler for human-readable text-formatted logs.", "source": "slog_handlers"}
{"id": "ge_007", "domain": "go_expert", "difficulty": "easy", "question": "What does `errors.Join` (introduced in Go 1.20) do, and how does it differ from `fmt.Errorf(\"%w\", err)` for wrapping errors?", "ground_truth": "`errors.Join(errs ...error) error` creates a single error that wraps multiple errors simultaneously. Unlike `fmt.Errorf(\"%w\")` which wraps exactly one error, `errors.Join` accepts a variadic number of errors. The returned error's `Unwrap() []error` method returns all of them, and `errors.Is`/`errors.As` traverse all joined errors. Passing only nil values returns nil.", "source": "errors_join_go_1_20"}
{"id": "ge_008", "domain": "go_expert", "difficulty": "easy", "question": "What does `slices.BinarySearch` from Go 1.21 return, and what precondition must the slice satisfy for correct results?", "ground_truth": "`slices.BinarySearch[S ~[]E, E cmp.Ordered](s S, target E) (int, bool)` returns (position, found). If the target is found, `found` is true and `position` is its index. If not found, `found` is false and `position` is where the target would be inserted to maintain sort order. The slice must be sorted in ascending order; results are undefined for unsorted input.", "source": "slices_binary_search_go_1_21"}
{"id": "ge_009", "domain": "go_expert", "difficulty": "easy", "question": "What does the `slices.Contains` function from Go's `slices` package do, and what constraint must the element type satisfy?", "ground_truth": "`slices.Contains(s []E, v E) bool` searches a slice for a specific value and returns true if found. The element type E must satisfy the `comparable` constraint, meaning it supports the == operator. It performs a linear search and is part of the `slices` standard library package added in Go 1.21.", "source": "slices_package_functions"}
{"id": "ge_010", "domain": "go_expert", "difficulty": "easy", "question": "What does `slices.Index` return when the target value is not found in the slice?", "ground_truth": "`slices.Index(s []E, v E) int` returns -1 when the target value is not found. When found, it returns the zero-based index of the first occurrence. Like `slices.Contains`, the element type E must be `comparable`. It is part of the `slices` package added in Go 1.21.", "source": "slices_package_functions"}
{"id": "ge_011", "domain": "go_expert", "difficulty": "easy", "question": "What is the `iter.Seq[V any]` type in Go 1.23, and what is its underlying function signature?", "ground_truth": "`iter.Seq[V any]` is a named type defined as `func(yield func(V) bool)` in the `iter` package introduced in Go 1.23. An iterator calls `yield` for each value; if `yield` returns false, the iterator must stop. This type is used with `for...range` over functions, enabling custom iteration patterns.", "source": "iter_package_types"}
{"id": "ge_012", "domain": "go_expert", "difficulty": "easy", "question": "What major change does `math/rand/v2` (introduced in Go 1.22) make compared to the original `math/rand` package?", "ground_truth": "`math/rand/v2` uses a randomly-seeded, goroutine-safe global source by default (backed by ChaCha8 or PCG algorithms), eliminating the need to call `rand.Seed()` at program startup. The original `math/rand` used a fixed default seed of 1, requiring manual seeding for non-deterministic output. `math/rand/v2` also removes deprecated functions and renames others (e.g., `Intn` becomes `IntN`).", "source": "math_rand_v2"}
{"id": "ge_013", "domain": "go_expert", "difficulty": "easy", "question": "What does `cmp.Compare` return in Go 1.21, and what types does the `cmp.Ordered` constraint include?", "ground_truth": "`cmp.Compare[T cmp.Ordered](x, y T) int` returns -1 if x < y, 0 if x == y, and +1 if x > y, following the same sign convention as `strings.Compare`. The `cmp.Ordered` constraint covers all built-in ordered types: signed integers (int, int8, int16, int32, int64), unsigned integers (uint, uint8, uint16, uint32, uint64, uintptr), floats (float32, float64), and string. The `cmp` package was added in Go 1.21.", "source": "cmp_package_go_1_21"}
{"id": "ge_014", "domain": "go_expert", "difficulty": "easy", "question": "What is the purpose of go.work files in Go modules?", "ground_truth": "go.work files enable workspaces, allowing multiple modules to be developed locally with edit-time replacement of dependencies without publishing to a registry.", "source": "modules_workspaces"}
{"id": "ge_015", "domain": "go_expert", "difficulty": "easy", "question": "What does `slog.SetDefault` do in Go 1.21, and how does it affect the existing `log` package output?", "ground_truth": "`slog.SetDefault(l *slog.Logger)` sets the default logger used by top-level `slog` package functions (`slog.Info`, `slog.Debug`, `slog.Warn`, `slog.Error`). It also redirects the standard `log` package's default output to use the new slog logger, so existing code using `log.Println` or `log.Printf` automatically routes through the structured handler. This enables gradual migration from `log` to `slog` without changing all call sites.", "source": "slog_set_default_go_1_21"}
{"id": "ge_016", "domain": "go_expert", "difficulty": "easy", "question": "What is the purpose of testing subtests in Go?", "ground_truth": "Subtests enable organizing related tests within a single test function, improving output readability and allowing selective test execution with filtering.", "source": "testing_subtests"}
{"id": "ge_017", "domain": "go_expert", "difficulty": "easy", "question": "What function is used to create benchmarks in Go testing?", "ground_truth": "Functions named with Benchmark prefix and parameter *testing.B are used for benchmarking, measuring code performance across iterations.", "source": "testing_benchmarks"}
{"id": "ge_018", "domain": "go_expert", "difficulty": "easy", "question": "What is fuzzing in Go testing and which testing function supports it?", "ground_truth": "Fuzzing automatically generates random test inputs to find edge cases and crashes; FuzzXxx functions with *testing.F parameter enable native fuzzing in Go 1.18+.", "source": "testing_fuzzing"}
{"id": "ge_019", "domain": "go_expert", "difficulty": "easy", "question": "What does the `unique` package introduced in Go 1.23 provide, and what is the primary use of `unique.Make`?", "ground_truth": "The `unique` package provides value canonicalization (interning). `unique.Make[T](v T)` returns a `Handle[T]` that is guaranteed to be pointer-equal for equivalent values. This enables efficient deduplication and comparison by pointer instead of by value, reducing memory use for repeated strings or structs and allowing O(1) equality checks via `==` on handles.", "source": "unique_package_go_1_23"}
{"id": "ge_020", "domain": "go_expert", "difficulty": "easy", "question": "What does `slices.Sorted` do in Go 1.23, and how does it differ from `slices.Sort`?", "ground_truth": "`slices.Sorted(seq iter.Seq[E]) []E` collects all values from an iterator into a new slice and returns it sorted. Unlike `slices.Sort`, which sorts an existing slice in-place, `slices.Sorted` creates a new slice from an iterator, integrating naturally with range-over-func patterns introduced in Go 1.23.", "source": "slices_package_go_1_23"}
{"id": "ge_021", "domain": "go_expert", "difficulty": "medium", "question": "When implementing a generic function that works with both integers and floats, what constraint would you use and why would a simple interface{} approach be insufficient?", "ground_truth": "Use a constraint like `constraints.Ordered` or define a custom constraint with `type Number interface { int | float64 | ... }`. A simple interface{} requires runtime type assertions and loses compile-time type safety; constraints enable type-safe operations at compile time while supporting multiple concrete types.", "source": "generics_constraints"}
{"id": "ge_022", "domain": "go_expert", "difficulty": "medium", "question": "Explain the difference between explicit and implicit type inference in Go generics. When might implicit inference fail and require explicit type arguments?", "ground_truth": "Implicit inference deduces type parameters from function arguments; explicit type arguments are provided directly (e.g., `MyFunc[int](...)`). Implicit inference fails when types cannot be uniquely determined from arguments, such as when a type parameter appears only in the return type or in interface method signatures.", "source": "generics_type_inference"}
{"id": "ge_023", "domain": "go_expert", "difficulty": "medium", "question": "In Go 1.23, how does range-over-func enable custom iteration patterns? What is the signature of an iterator function and how does it differ from traditional for-range loops?", "ground_truth": "Range-over-func allows `for v := range iterFunc()` syntax where iterFunc returns an iterator function with signature `func(func(T) bool) error` or `func(func(T) bool)`. The iterator calls the yield function for each element; if yield returns false, iteration stops, enabling custom control flow without explicit channels.", "source": "range_over_func_iterators"}
{"id": "ge_024", "domain": "go_expert", "difficulty": "medium", "question": "When would you use `slices.All()` vs implementing a custom range-over-func iterator? What trade-offs exist between convenience and flexibility?", "ground_truth": "`slices.All()` provides simple, efficient iteration over slice elements and should be preferred for basic slice traversal. Custom iterators offer flexibility to filter, transform, or control iteration order at the cost of additional complexity. Use `slices.All()` for straightforward cases; custom iterators when you need domain-specific logic.", "source": "range_over_func_iterators"}
{"id": "ge_025", "domain": "go_expert", "difficulty": "medium", "question": "Describe the relationship between `slog.Logger`, `slog.Handler`, and `slog.Attr`. How does this design support flexible log output handling?", "ground_truth": "Logger coordinates logging operations and delegates formatting to Handler; Attr represents key-value pairs added to records. This separation allows handlers (JSONHandler, TextHandler, custom) to process the same Logger output differently without changing application code, supporting different output formats and destinations.", "source": "structured_logging_slog"}
{"id": "ge_026", "domain": "go_expert", "difficulty": "medium", "question": "How can you integrate `slog` logging with Go's context package to pass request-scoped attributes through your application? What are the benefits of this approach?", "ground_truth": "Use `slog.With()` and context to add request-scoped attributes that propagate through function calls without explicit parameter passing. Alternatively, store a logger in context using `context.WithValue()` and retrieve it downstream. Benefits include automatic request correlation, cleaner function signatures, and consistent logging across call chains.", "source": "structured_logging_context"}
{"id": "ge_027", "domain": "go_expert", "difficulty": "medium", "question": "Compare error wrapping with `fmt.Errorf(\"%w\", err)` versus creating custom error types. When is each approach preferable?", "ground_truth": "`fmt.Errorf` with `%w` is simpler and preserves error chains for inspection with `errors.Is/As`; use it for transient wrapping. Custom error types allow carrying structured metadata and implementing specific error interfaces; use them when errors need domain-specific information or custom handling logic.", "source": "error_handling_wrapping"}
{"id": "ge_028", "domain": "go_expert", "difficulty": "medium", "question": "Explain how `errors.Is()` and `errors.As()` work with wrapped errors. What is the difference in use cases between these two functions?", "ground_truth": "`errors.Is()` checks if a wrapped error matches a target error (identity/equality comparison), useful for detecting specific error types. `errors.As()` extracts a wrapped error of a specific type into a variable, allowing access to type-specific fields. Use `Is` for conditionals, `As` when you need to extract and work with the concrete type.", "source": "error_handling_inspection"}
{"id": "ge_029", "domain": "go_expert", "difficulty": "medium", "question": "In concurrent Go programs, when should you use channels versus mutexes? What patterns help decide between them?", "ground_truth": "Use channels for communication between goroutines and expressing sequential workflows; use mutexes to protect shared data structures. Channels are better for synchronizing independent tasks; mutexes for protecting state accessed by multiple goroutines. The rule of thumb: \"Don't communicate by sharing memory; share memory by communicating\" guides channel use.", "source": "concurrency_channels_mutexes"}
{"id": "ge_030", "domain": "go_expert", "difficulty": "medium", "question": "How does Go's `context.Context` improve cancellation and timeout handling in concurrent programs? What mistakes commonly occur when propagating context?", "ground_truth": "Context provides cancellation signals and deadlines that propagate through goroutines, allowing coordinated shutdown. Common mistakes: not checking `ctx.Done()` in loops, forgetting to pass context to child functions, or using context.Background() when a cancellable context is needed. Always pass context as the first parameter and respect cancellation signals.", "source": "concurrency_context"}
{"id": "ge_031", "domain": "go_expert", "difficulty": "medium", "question": "Design a worker pool pattern in Go. What synchronization primitives would you use and why? How does it improve resource efficiency?", "ground_truth": "Use a buffered channel to distribute work, WaitGroup to track completion, and context for cancellation. Worker goroutines receive jobs from the channel and send results back. Worker pools limit concurrent execution, preventing goroutine explosion on high-volume workloads. This provides backpressure, controlled concurrency, and efficient CPU/memory usage.", "source": "concurrency_worker_pools"}
{"id": "ge_032", "domain": "go_expert", "difficulty": "medium", "question": "Explain the pipeline pattern in Go concurrency. How does it compose stages and what channel direction declarations contribute to safety?", "ground_truth": "Pipelines chain stages where each stage reads from input, processes, and sends to output channels. Each stage runs in its own goroutine, enabling parallel processing. Using send-only (`chan<-`) and receive-only (`<-chan`) channel types prevents accidental misuse and makes data flow explicit, improving code clarity and preventing deadlocks.", "source": "concurrency_pipelines"}
{"id": "ge_033", "domain": "go_expert", "difficulty": "medium", "question": "What is the purpose of `go.mod` and `go.sum` files? How do they differ in function and when would you commit each to version control?", "ground_truth": "`go.mod` declares module metadata and required dependencies with versions; `go.sum` contains cryptographic hashes ensuring dependency integrity. Always commit both to version control: `go.mod` specifies reproducible builds, `go.sum` detects tampering or corruption. Together they ensure deterministic dependency resolution across machines.", "source": "modules_go_mod"}
{"id": "ge_034", "domain": "go_expert", "difficulty": "medium", "question": "How do Go module workspaces (introduced in Go 1.18) simplify multi-module development? When are they preferable to using `replace` directives?", "ground_truth": "Workspaces (`go.work`) allow multiple modules to be developed together without modifying their individual `go.mod` files, automatically using local versions. Preferable to `replace` directives because they're non-persistent (not committed), support uncommitted changes, and cleanly separate development-time overrides from version control. Ideal for monorepos and local development.", "source": "modules_workspaces"}
{"id": "ge_035", "domain": "go_expert", "difficulty": "medium", "question": "Describe table-driven tests in Go. What advantages do they provide over individual test functions, and how do they integrate with subtests?", "ground_truth": "Table-driven tests use a slice of test cases with inputs and expected outputs, reducing boilerplate and improving maintainability. Each case iterates through the table, running the same test logic. Subtests (`t.Run()`) allow parameterized execution with individual pass/fail reporting. Together they enable exhaustive testing with minimal code, better failure isolation, and easier result filtering.", "source": "testing_table_driven"}
{"id": "ge_036", "domain": "go_expert", "difficulty": "medium", "question": "How do Go benchmarks work and what does the `b.N` loop accomplish? How would you avoid common pitfalls like compiler optimizations eliminating benchmark code?", "ground_truth": "Benchmarks run test code repeatedly, adjusting iterations until results stabilize; `b.N` is the iteration count. The `testing` framework adjusts `b.N` to achieve sufficient duration. Avoid pitfalls by assigning results to a package-level variable (preventing dead-code elimination) and using `b.ResetTimer()` to exclude setup costs. `go test -bench=.` runs benchmarks with `-benchmem` for allocation stats.", "source": "testing_benchmarks"}
{"id": "ge_037", "domain": "go_expert", "difficulty": "medium", "question": "What is fuzzing in Go testing and how does `testing.F` differ from standard tests? When should you apply fuzzing to your code?", "ground_truth": "Fuzzing automatically generates diverse inputs to find edge cases and crash conditions; `testing.F` uses corpus data and mutates it. Unlike unit tests with fixed inputs, fuzzing explores the input space. Apply fuzzing to parsing code, serialization, cryptographic functions, and any code handling untrusted input. The Go fuzzer maintains a corpus and reproduces failures from seeds.", "source": "testing_fuzzing"}
{"id": "ge_038", "domain": "go_expert", "difficulty": "medium", "question": "Name three key principles from Effective Go that improve code clarity in concurrent programs. How do they reduce bugs?", "ground_truth": "Key principles include: (1) \"Don't communicate by sharing memory; share memory by communicating\" \u2014 use channels instead of locks to avoid race conditions; (2) Keep interfaces small (one method) \u2014 enables composition and testability; (3) Use goroutines for independent concurrent work with clear synchronization \u2014 prevents data races. Together these reduce deadlocks, race conditions, and coupling.", "source": "effective_go_patterns"}
{"id": "ge_039", "domain": "go_expert", "difficulty": "medium", "question": "What are the major new features in Go 1.22 and 1.23 beyond range-over-func? How do they impact code clarity or performance?", "ground_truth": "Go 1.22: range loops copy iteration variables (fixing capture bugs), `for i := range n` syntax for integer ranges. Go 1.23: range-over-func iterators, `iter.Seq` and `iter.Seq2` types, clear() builtin for maps/slices. These improve code clarity (fewer range-variable closure bugs), enable custom iteration patterns, and provide convenience for loop counting without explicit indexing.", "source": "release_features_1_22_1_23"}
{"id": "ge_040", "domain": "go_expert", "difficulty": "medium", "question": "How would you implement a generic constraint that accepts only types implementing both `Reader` and `Writer` interfaces? What limitations exist in Go's type parameter design?", "ground_truth": "Use `type MyConstraint interface { io.Reader; io.Writer }` as a type constraint. Go allows composing interface types in constraints using embedded syntax. Limitations include: constraints cannot express \"sum types\" precisely (no union constraints beyond `|`), no higher-order generics, and constraints cannot express \"any type implementing method X with signature Y\" without explicit enumeration. Complex type relationships require interface-based approaches.", "source": "generics_advanced_constraints"}
{"id": "ge_041", "domain": "go_expert", "difficulty": "hard", "question": "When designing a generic function with type constraints, what is the critical difference between using `interface{}` constraints versus specific constraint interfaces like `constraints.Ordered`, and how does this impact type inference and runtime performance?", "ground_truth": "Using `interface{}` allows any type but disables type inference and requires explicit type parameters at call sites, while `constraints.Ordered` enables the compiler to infer concrete types and generates specialized code for each type, eliminating runtime overhead. Specific constraints also provide compile-time safety by restricting operations to valid types.", "source": "generics_type_constraints"}
{"id": "ge_042", "domain": "go_expert", "difficulty": "hard", "question": "Explain the performance implications and use-case trade-offs between using `range-over-func` iterators (Go 1.23) versus traditional slice iteration, particularly regarding memory allocation, goroutine spawning, and lazy evaluation in pipeline patterns.", "ground_truth": "Range-over-func iterators use pull-based evaluation avoiding intermediate allocations and enabling lazy evaluation, making them superior for pipelines and large datasets. Traditional slice iteration pre-allocates entire collections. However, range-over-func adds function call overhead and cannot easily spawn goroutines per iteration like goroutine-per-item patterns, making them suboptimal for CPU-bound parallel work.", "source": "range_over_func_iterators"}
{"id": "ge_043", "domain": "go_expert", "difficulty": "hard", "question": "In structured logging with slog, when should you use `slog.Handler` implementations versus pre-built handlers like `slog.JSONHandler`? Describe a scenario where a custom handler is necessary and the performance considerations involved.", "ground_truth": "Custom handlers are necessary when you need domain-specific log formatting, dynamic filtering based on request context, or sampling strategies that built-in handlers don't support. Performance considerations include minimizing allocations in the hot path, efficient attribute serialization, and avoiding blocking I/O; built-in handlers are optimized but less flexible, while custom handlers trade flexibility for potential performance cost if poorly implemented.", "source": "slog_handler_architecture"}
{"id": "ge_044", "domain": "go_expert", "difficulty": "hard", "question": "Design an error handling strategy for a microservice that must distinguish between retryable (timeouts, transient network errors) and non-retryable errors (auth failures, validation errors). How would you implement this using Go 1.22+ error wrapping patterns with `errors.Is`, `errors.As`, and custom error types?", "ground_truth": "Define custom error types implementing `Retryable()` method or interface, wrap errors with `fmt.Errorf` preserving the original error, and use `errors.As` to extract and check the custom type. For categorization, use `errors.Is` with sentinel errors for specific conditions (e.g., `context.DeadlineExceeded`), and inspect the unwrapped error type chain to determine retry logic without exposing internals.", "source": "error_handling_patterns"}
{"id": "ge_045", "domain": "go_expert", "difficulty": "hard", "question": "In a high-throughput system, you must choose between using buffered channels with select statements versus sync.Mutex-protected queues for worker pool coordination. What are the critical performance, deadlock-risk, and backpressure handling differences?", "ground_truth": "Channels provide built-in backpressure via buffer capacity and are deadlock-safe with select semantics, but have context-switching overhead and cannot be resized. Mutexes offer lower latency with careful implementation but risk deadlocks if held across multiple critical sections; they don't provide natural backpressure. For high-throughput systems, channels with appropriately sized buffers are safer; mutex-based queues require explicit backpressure mechanisms and careful lock ordering.", "source": "concurrency_worker_pools"}
{"id": "ge_046", "domain": "go_expert", "difficulty": "hard", "question": "When using Go workspaces (Go 1.18+), explain how dependency version resolution differs from single-module projects. What are the pitfalls when one workspace module requires `v1.0` and another requires `v1.5` of the same dependency?", "ground_truth": "Workspaces use the highest version required across all modules in the workspace, so conflicting requirements (v1.0 vs v1.5) will select v1.5. This can mask incompatibilities during development that surface in production where modules are separate. The pitfall is false confidence: if v1.5 introduces breaking changes incompatible with v1.0 expectations, the code works locally but fails when deployed as separate modules. Workspace dependencies should be explicitly documented.", "source": "modules_workspaces"}
{"id": "ge_047", "domain": "go_expert", "difficulty": "hard", "question": "Design a fuzzing strategy for a parser that handles untrusted input. How would you structure fuzz targets to avoid resource exhaustion (infinite loops, memory bombs) while maintaining meaningful coverage of edge cases? Consider Go 1.18+ native fuzzing.", "ground_truth": "Use fuzzing with explicit timeout contexts and memory limits via `testing.F.Add` seeding. Structure fuzz targets to detect pathological cases (e.g., deeply nested structures) and fail fast. Combine with table-driven unit tests for known edge cases, and use `-fuzz` with `-fuzztime` and `-fuzzminimizationduration` flags. Monitor resource usage and add guards like depth checks in parsers to prevent algorithmic complexity attacks.", "source": "testing_fuzzing"}
{"id": "ge_048", "domain": "go_expert", "difficulty": "hard", "question": "In Go 1.22, the for loop semantics changed regarding variable capture in closures. Explain the breaking change, why it occurred, and how this affects existing concurrent code patterns (e.g., goroutine loops launching closures).", "ground_truth": "Go 1.22 changed loop variable scoping: each iteration now has its own copy instead of reusing the same variable. This fixes the common gotcha where goroutines launched in loops all captured the same variable reference. Code that worked around this (by shadowing with `:= range`) still works but is unnecessary. Code relying on the old behavior (capturing the final loop variable value) will break, but this is rare and was generally a bug.", "source": "go_1_22_release_features"}
{"id": "ge_049", "domain": "go_expert", "difficulty": "hard", "question": "Explain the interaction between context cancellation, goroutine lifetime, and resource cleanup in a complex pipeline with multiple stages. How do you prevent resource leaks when an upstream stage panics or a downstream stage cancels?", "ground_truth": "Use `defer` statements to guarantee cleanup regardless of cancellation or panic. Pass context through the pipeline and check it at each stage. For bidirectional signaling, use WaitGroups to track goroutine lifecycle and ensure parent stages terminate after children. Panic recovery with `recover()` must re-cancel the context to notify sibling goroutines. Each stage should independently ensure its resources are cleaned up, not rely on parent cleanup.", "source": "concurrency_context_pipelines"}
{"id": "ge_050", "domain": "go_expert", "difficulty": "hard", "question": "When using generic slice/map utility functions from `slices` and `maps` packages (Go 1.22+), what are the performance characteristics and when should you implement specialized versions instead? Provide a concrete example where the generic version becomes a bottleneck.", "ground_truth": "Generic functions use reflection or interface{} internally in some cases, adding overhead compared to type-specialized implementations. For hot-path operations on large collections (e.g., `slices.Sort` on millions of items), a type-specific quicksort can be 10-30% faster. However, for small collections or non-critical paths, generic utilities are fine and reduce code duplication. Benchmark before optimizing; profiling typically shows generic utilities are acceptable unless processing terabyte-scale data.", "source": "generics_std_library_utilities"}
