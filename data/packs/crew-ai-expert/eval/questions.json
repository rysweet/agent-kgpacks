[
  {
    "id": "ca_001",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What is CrewAI and what type of framework is it?",
    "ground_truth": "CrewAI is the leading open-source multi-agent orchestration framework that enables teams of AI agents to collaborate and work together on complex tasks.",
    "source": "introduction"
  },
  {
    "id": "ca_002",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "Name three types of agent roles commonly used in CrewAI.",
    "ground_truth": "Three common agent roles in CrewAI are: Manager (oversees and coordinates), Worker (executes specific tasks), and Researcher (gathers and analyzes information).",
    "source": "agents"
  },
  {
    "id": "ca_003",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What are the two primary process types for executing crews in CrewAI?",
    "ground_truth": "The two primary process types are sequential (tasks executed one after another in order) and hierarchical (tasks executed based on a hierarchical management structure).",
    "source": "processes"
  },
  {
    "id": "ca_004",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What is a Task in CrewAI and what key information does it require?",
    "ground_truth": "A Task in CrewAI is a unit of work assigned to an agent. It requires a description and typically includes guardrails to define constraints and expected behavior.",
    "source": "tasks"
  },
  {
    "id": "ca_005",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What does the Flows feature in CrewAI enable?",
    "ground_truth": "Flows in CrewAI enable event-driven workflows with state management, allowing more flexible and responsive orchestration of multi-agent processes.",
    "source": "flows"
  },
  {
    "id": "ca_006",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "How many built-in tools does CrewAI provide out of the box?",
    "ground_truth": "CrewAI provides 100+ built-in tools that agents can use to interact with external systems and perform various operations.",
    "source": "tools"
  },
  {
    "id": "ca_007",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What is agentic RAG in the context of CrewAI Knowledge?",
    "ground_truth": "Agentic RAG (Retrieval-Augmented Generation) in CrewAI Knowledge allows agents to intelligently retrieve and utilize information from knowledge bases to inform their decisions and responses.",
    "source": "knowledge"
  },
  {
    "id": "ca_008",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "Name the four types of memory supported by CrewAI.",
    "ground_truth": "CrewAI supports four types of memory: short-term (immediate context), long-term (persistent storage), entity memory (information about specific entities), and contextual memory (background and context awareness).",
    "source": "memory"
  },
  {
    "id": "ca_009",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What database does CrewAI use to back its memory system?",
    "ground_truth": "CrewAI uses LanceDB as the backing database for its memory system, providing efficient storage and retrieval of agent memories.",
    "source": "memory"
  },
  {
    "id": "ca_010",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What is the purpose of the Planning Agent in CrewAI?",
    "ground_truth": "The Planning Agent in CrewAI is responsible for developing strategies and breaking down complex objectives into executable steps for other agents to perform.",
    "source": "planning"
  },
  {
    "id": "ca_011",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What does asynchronous task execution allow in CrewAI?",
    "ground_truth": "Asynchronous task execution in CrewAI allows multiple tasks to run concurrently without blocking each other, improving overall crew efficiency and responsiveness.",
    "source": "tasks"
  },
  {
    "id": "ca_012",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What is MCP integration in CrewAI Tools?",
    "ground_truth": "MCP (Model Context Protocol) integration in CrewAI allows agents to connect to and utilize external services and data sources through a standardized protocol.",
    "source": "tools"
  },
  {
    "id": "ca_013",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What method is used to start the execution of a crew in CrewAI?",
    "ground_truth": "The kickoff method is used to start the execution of a crew in CrewAI, which initiates the crew's workflow and begins task processing.",
    "source": "crews"
  },
  {
    "id": "ca_014",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "How does CrewAI's reasoning feature enhance agent capabilities?",
    "ground_truth": "CrewAI's reasoning feature enables agents to think through problems step-by-step, analyze information critically, and make more informed decisions based on logical deduction.",
    "source": "reasoning"
  },
  {
    "id": "ca_015",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What is the primary purpose of Event Listeners in CrewAI?",
    "ground_truth": "Event Listeners in CrewAI allow users to monitor and respond to specific events occurring during agent and crew execution, enabling custom logging and reactive behavior.",
    "source": "event_listeners"
  },
  {
    "id": "ca_016",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What does the CrewAI CLI provide to developers?",
    "ground_truth": "The CrewAI CLI provides command-line tools for creating, initializing, and managing CrewAI projects, streamlining development workflow.",
    "source": "cli"
  },
  {
    "id": "ca_017",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "Name three observability platforms that integrate with CrewAI.",
    "ground_truth": "Three observability platforms that integrate with CrewAI are: Langfuse (for tracing and monitoring), Datadog (for infrastructure and performance monitoring), and MLflow (for experiment tracking).",
    "source": "observability"
  },
  {
    "id": "ca_018",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What is role-based design in the context of CrewAI Agents?",
    "ground_truth": "Role-based design in CrewAI Agents involves assigning specific roles to each agent (e.g., analyst, researcher, manager) that define their responsibilities and capabilities within the crew.",
    "source": "agents"
  },
  {
    "id": "ca_019",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "How can custom tools be integrated into CrewAI?",
    "ground_truth": "Custom tools can be created and integrated into CrewAI by defining tool functions and registering them with agents, extending the framework's capabilities beyond built-in tools.",
    "source": "tools"
  },
  {
    "id": "ca_020",
    "domain": "crew_ai_expert",
    "difficulty": "easy",
    "question": "What does task description define in CrewAI?",
    "ground_truth": "A task description in CrewAI clearly outlines what the agent needs to accomplish, including objectives, expected outputs, and any specific requirements or constraints for execution.",
    "source": "tasks"
  },
  {
    "id": "ca_021",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "In CrewAI, how do role-based agent designs differ when implementing a manager agent versus a worker agent in a hierarchical crew structure?",
    "ground_truth": "Manager agents are designed to orchestrate and delegate tasks to worker agents, requiring higher-level decision-making and task allocation capabilities, while worker agents specialize in executing specific tasks with defined responsibilities. Manager agents typically use hierarchical process types to supervise workflow, whereas worker agents focus on efficiency in their assigned domain.",
    "source": "agents_role_based_design"
  },
  {
    "id": "ca_022",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "What is the purpose of task guardrails in CrewAI, and how do they differ from task descriptions in controlling agent behavior?",
    "ground_truth": "Task guardrails provide explicit constraints and safety boundaries that agents must respect during execution, preventing deviation from intended behavior, while task descriptions define what work needs to be done. Guardrails act as hard constraints on how tasks are executed, whereas descriptions focus on the goal and context.",
    "source": "tasks_guardrails"
  },
  {
    "id": "ca_023",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "Explain the difference between sequential and hierarchical crew processes, and when you would choose one over the other.",
    "ground_truth": "Sequential processes execute tasks one after another in a defined order, with each task's output potentially feeding into the next, while hierarchical processes use a manager agent to dynamically assign and coordinate tasks among worker agents. Sequential is simpler and better for linear workflows, whereas hierarchical is superior for complex problem-solving requiring dynamic task allocation and decision-making.",
    "source": "crews_sequential_hierarchical"
  },
  {
    "id": "ca_024",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "How does asynchronous task execution in CrewAI improve performance for crews with multiple parallel operations?",
    "ground_truth": "Asynchronous task execution allows multiple tasks to run concurrently rather than waiting for each to complete sequentially, reducing total execution time and improving system throughput. This is particularly beneficial when tasks involve I/O operations or when independent tasks can be parallelized without blocking each other.",
    "source": "tasks_async_execution"
  },
  {
    "id": "ca_025",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "What role do event-driven workflows play in CrewAI Flows, and how do they differ from traditional crew processes?",
    "ground_truth": "Event-driven workflows in Flows respond to specific events or state changes to trigger subsequent actions, enabling dynamic and reactive orchestration, while traditional crew processes follow predefined sequential or hierarchical execution paths. Flows provide more flexibility for complex, non-linear workflows where actions depend on runtime events rather than predetermined structure.",
    "source": "flows_event_driven"
  },
  {
    "id": "ca_026",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "How does state management in CrewAI Flows contribute to maintaining consistency across event-driven workflows?",
    "ground_truth": "State management in Flows tracks and maintains data across multiple events and transitions, ensuring that agents have access to current context and preventing data inconsistencies. It allows workflows to make decisions based on accumulated state rather than isolated events, enabling coherent multi-step processes.",
    "source": "flows_state_management"
  },
  {
    "id": "ca_027",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "Describe the trade-offs between using built-in CrewAI tools versus integrating custom tools through the Model Context Protocol (MCP).",
    "ground_truth": "Built-in tools provide immediate functionality with minimal setup and are optimized for common operations, while MCP-integrated custom tools offer greater flexibility and domain-specific capabilities tailored to unique requirements. Built-in tools sacrifice customization for convenience, whereas MCP integration requires more setup but enables specialized integrations.",
    "source": "tools_builtin_custom_mcp"
  },
  {
    "id": "ca_028",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "What is agentic RAG in CrewAI's knowledge module, and how does it enhance traditional retrieval-augmented generation?",
    "ground_truth": "Agentic RAG empowers agents to actively decide when and how to query the knowledge base based on task requirements, rather than passively retrieving documents. This approach allows agents to perform iterative retrieval, validate information quality, and combine retrieved knowledge with reasoning to produce more accurate and contextual responses.",
    "source": "knowledge_agentic_rag"
  },
  {
    "id": "ca_029",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "How do short-term and long-term memory types in CrewAI serve different purposes during task execution?",
    "ground_truth": "Short-term memory stores immediate task context and conversation history for current execution, enabling agents to reference recent interactions and decisions, while long-term memory persists information across multiple crew runs for learning and pattern recognition. Short-term memory is ephemeral and task-focused, whereas long-term memory builds knowledge over time.",
    "source": "memory_short_long_term"
  },
  {
    "id": "ca_030",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "What advantages does LanceDB-backed memory provide compared to in-memory memory storage in CrewAI?",
    "ground_truth": "LanceDB-backed memory provides persistent, scalable vector storage that can handle large volumes of data and survive process restarts, enabling agents to leverage historical information across sessions. In-memory storage is faster but limited to session duration and available RAM, making LanceDB preferable for production systems requiring long-term knowledge retention.",
    "source": "memory_lancedb"
  },
  {
    "id": "ca_031",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "Explain how entity memory differs from contextual memory in CrewAI's memory system.",
    "ground_truth": "Entity memory tracks and stores information about specific entities (people, organizations, concepts) and their attributes, enabling agents to maintain knowledge about important subjects, while contextual memory captures the broader situation and relationships within tasks. Entity memory focuses on discrete objects with properties, whereas contextual memory tracks the overall scenario and interconnections.",
    "source": "memory_entity_contextual"
  },
  {
    "id": "ca_032",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "What is the planning agent in CrewAI, and how does it enhance crew performance in complex task scenarios?",
    "ground_truth": "The planning agent is a specialized agent that breaks down complex tasks into subtasks and creates strategic plans for crew execution, improving efficiency and task decomposition. It enables better handling of multi-step problems by generating structured approaches before execution, reducing agent confusion and improving overall crew coordination.",
    "source": "planning_agent"
  },
  {
    "id": "ca_033",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "How does reasoning capability in CrewAI agents improve decision-making compared to agents without explicit reasoning steps?",
    "ground_truth": "Reasoning enables agents to work through problems step-by-step, explain their logic, and validate conclusions before acting, reducing errors and improving transparency. Agents with reasoning can handle more complex scenarios by breaking problems into logical components, whereas non-reasoning agents rely on direct pattern matching and may miss important considerations.",
    "source": "reasoning"
  },
  {
    "id": "ca_034",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "What are the primary differences between training and testing modes in CrewAI, and why is this distinction important for production deployments?",
    "ground_truth": "Training mode allows crews to learn from interactions and optimize task execution through feedback, while testing mode validates crew performance against defined metrics without modifying the trained model. This distinction ensures that production crews can be validated before deployment and prevents unwanted model drift from production interactions.",
    "source": "training_testing"
  },
  {
    "id": "ca_035",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "Describe the role of the CrewAI CLI in development workflows and how it streamlines crew creation and management.",
    "ground_truth": "The CrewAI CLI provides command-line tools for initializing projects, generating agent and task scaffolding, running crews, and managing configurations. It reduces manual setup overhead and standardizes crew structure, enabling developers to quickly prototype and deploy multi-agent systems without writing boilerplate code.",
    "source": "cli"
  },
  {
    "id": "ca_036",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "How do event listeners in CrewAI enable observability and debugging of agent behavior during execution?",
    "ground_truth": "Event listeners hook into agent execution events such as task start, completion, errors, and tool calls, allowing developers to capture detailed execution telemetry and logs. They enable real-time monitoring, debugging, and behavioral analysis by providing visibility into agent decision-making and task progression.",
    "source": "event_listeners"
  },
  {
    "id": "ca_037",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "What architectural components are essential for deploying CrewAI crews in production environments?",
    "ground_truth": "Essential components include a durable task queue or orchestrator for task management, persistent storage for memory and state, monitoring and logging infrastructure, API layer for external access, and fault tolerance mechanisms. A robust production architecture must handle scaling, resilience, and maintaining state across multiple crew instances.",
    "source": "production_architecture"
  },
  {
    "id": "ca_038",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "How do Langfuse, Datadog, and MLflow integrations differ in the observability stack for CrewAI systems?",
    "ground_truth": "Langfuse specializes in LLM-specific tracing and prompt monitoring, Datadog provides comprehensive infrastructure and application performance monitoring, and MLflow focuses on experiment tracking and model lifecycle management. Together they provide multi-layered observability: LLM behavior, system metrics, and model performance respectively.",
    "source": "observability_langfuse_datadog_mlflow"
  },
  {
    "id": "ca_039",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "How should you design a researcher agent differently from a worker agent in terms of capabilities and tool access?",
    "ground_truth": "Researcher agents require broad access to information retrieval tools, knowledge bases, and external data sources to conduct thorough investigations, while worker agents focus on executing specific tasks with targeted tool sets. Researcher agents need higher autonomy and search capability, whereas worker agents optimize for efficiency in narrowly-scoped work.",
    "source": "agents_researcher_design"
  },
  {
    "id": "ca_040",
    "domain": "crew_ai_expert",
    "difficulty": "medium",
    "question": "What considerations should guide the choice between using a single crew with multiple agents versus multiple specialized crews in a system architecture?",
    "ground_truth": "A single crew is simpler to manage and suitable for tightly integrated workflows, while multiple specialized crews enable better isolation, independent scaling, and focus on specific domains. The choice depends on task interdependencies, scalability requirements, and organizational structure; tightly coupled tasks benefit from single crews, whereas independent problem domains suit multiple crews.",
    "source": "crews_architecture_design"
  },
  {
    "id": "ca_041",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "When designing a hierarchical crew process, how does the manager agent's decision-making differ from a sequential process, and what are the performance trade-offs when handling 50+ tasks?",
    "ground_truth": "In hierarchical processes, the manager agent dynamically delegates and orchestrates worker agents, allowing parallel execution and adaptive task ordering based on intermediate results, unlike sequential processes that execute linearly. Performance trade-offs include increased LLM calls for orchestration decisions but potential faster overall execution through parallelization; latency depends on manager decision speed versus sequential bottlenecks.",
    "source": "processes_hierarchical"
  },
  {
    "id": "ca_042",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "How does CrewAI's agentic RAG implementation in the Knowledge feature differ from traditional RAG, and what specific advantages does it provide for multi-agent reasoning chains?",
    "ground_truth": "Agentic RAG in CrewAI allows agents to autonomously decide when and how to query knowledge sources during task execution, enabling iterative refinement and context-aware retrieval based on reasoning progress. This differs from traditional RAG's static retrieval pipeline by supporting agents making retrieval decisions as part of their reasoning, improving answer quality for complex multi-step tasks requiring knowledge verification.",
    "source": "knowledge_agentic_rag"
  },
  {
    "id": "ca_043",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "Explain the memory hierarchy in CrewAI (short-term, long-term, entity, contextual) and how LanceDB backing affects persistence, retrieval latency, and memory conflicts in long-running agent sessions.",
    "ground_truth": "Short-term memory stores immediate task context, long-term memory persists across sessions via LanceDB vector store, entity memory tracks relationship graphs, and contextual memory captures environmental state. LanceDB provides low-latency vector retrieval and persistent storage, reducing memory conflicts through semantic deduplication; trade-offs include storage overhead and query latency scaling with memory size.",
    "source": "memory_lancedb"
  },
  {
    "id": "ca_044",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "When implementing custom tools with MCP (Model Context Protocol) integration, what are the critical security considerations and potential failure modes when agents have access to external system resources?",
    "ground_truth": "Critical security considerations include input validation/sanitization to prevent injection attacks, least-privilege access controls, rate limiting, and timeout enforcement. Failure modes include tool hanging, exception propagation disrupting task execution, and uncaught errors breaking crew workflows; mitigation requires robust error handling, fallback strategies, and sandboxing external tool execution.",
    "source": "tools_mcp_custom"
  },
  {
    "id": "ca_045",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "Design a production architecture for a CrewAI multi-agent system handling 1000+ concurrent tasks. What observability stack (Langfuse, Datadog, MLflow) would you choose and why, considering tracing, metrics, and cost optimization?",
    "ground_truth": "For high concurrency: use Langfuse for detailed LLM tracing and cost per agent, Datadog for infrastructure/system metrics and alerting, and MLflow for experiment tracking and model versioning. Langfuse provides agent-level insights; Datadog handles resource scaling; MLflow tracks reasoning quality. Cost optimization requires sampling strategies for high-volume traces and metric aggregation at appropriate granularities.",
    "source": "observability_production"
  },
  {
    "id": "ca_046",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "How do async task execution and event-driven flows interact in CrewAI? When should you use async tasks versus flows, and what synchronization challenges arise?",
    "ground_truth": "Async tasks allow non-blocking task execution within crews, while flows provide event-driven workflows with explicit state management. Use async for independent tasks within a crew to improve throughput; use flows for complex inter-agent coordination requiring conditional branching and event triggering. Synchronization challenges include managing dependencies between async results, handling partial failures, and maintaining consistent state across distributed executions.",
    "source": "flows_async_tasks"
  },
  {
    "id": "ca_047",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "Explain the role-based agent design pattern in CrewAI (researcher, manager, worker) and how to prevent common pitfalls like role confusion, redundant reasoning, and inefficient task delegation.",
    "ground_truth": "Role-based design assigns distinct responsibilities: researchers gather/analyze information, managers orchestrate and delegate, workers execute specific tasks. Prevent confusion by defining clear role prompts with explicit boundaries, avoid overlapping tool access, use hierarchical processes with explicit delegation, and implement role-specific memory isolation to prevent context leakage and redundant analysis.",
    "source": "agents_role_based"
  },
  {
    "id": "ca_048",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "What is the relationship between the planning agent and the reasoning framework in CrewAI, and how do guardrails on tasks enforce constraints during plan execution?",
    "ground_truth": "The planning agent generates high-level action sequences, while the reasoning framework enables agents to evaluate decisions and refine plans. Task guardrails enforce execution constraints by validating outputs against defined criteria (e.g., format, content restrictions), preventing execution if violated. This creates a feedback loop where reasoning agents detect guardrail violations and replan accordingly.",
    "source": "planning_reasoning_guardrails"
  },
  {
    "id": "ca_049",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "How should you structure crew training and testing workflows in CrewAI to evaluate agent performance, and what metrics would you track to measure reasoning quality versus task completion efficiency?",
    "ground_truth": "Structure training/testing by creating task datasets with ground-truth outputs, running crews against them, and comparing results. Track reasoning quality metrics (e.g., explanation coherence, fact accuracy via fact-checking) versus efficiency metrics (latency, token usage, LLM calls). Use evaluation agents to score outputs, implement A/B testing for agent configurations, and leverage MLflow for experiment tracking and comparison.",
    "source": "training_testing_evaluation"
  },
  {
    "id": "ca_050",
    "domain": "crew_ai_expert",
    "difficulty": "hard",
    "question": "When deploying CrewAI via CLI or programmatically, how do event listeners enable real-time observability, and what are architectural implications of event streaming at scale (throughput, latency, storage)?",
    "ground_truth": "Event listeners hook into crew execution lifecycle (agent start/end, task complete, errors), emitting events for real-time monitoring. At scale, implications include event buffering requirements to prevent blocking execution, potential latency from listener processing, storage overhead for event logs, and need for filtering/sampling to manage event volume. Implement asynchronous event handling and consider stream processing (Kafka, Kinesis) for high-throughput scenarios.",
    "source": "event_listeners_cli"
  }
]
