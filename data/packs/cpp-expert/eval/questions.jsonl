{"id": "ce_001", "domain": "cpp_expert", "difficulty": "easy", "question": "What is the primary purpose of C++ modules introduced in C++20 and refined in C++23?", "ground_truth": "Modules replace the traditional #include-based header system to improve compilation speed, reduce macro pollution, and provide better encapsulation by explicitly controlling what symbols are exported from a module.", "source": "modules"}
{"id": "ce_002", "domain": "cpp_expert", "difficulty": "easy", "question": "How does std::expected differ from std::optional in error handling?", "ground_truth": "std::optional holds either a value or nothing, while std::expected holds either a value or an error object, allowing the error information to be returned and inspected alongside the result.", "source": "std::expected"}
{"id": "ce_003", "domain": "cpp_expert", "difficulty": "easy", "question": "What does the std::generator coroutine type do in C++23?", "ground_truth": "std::generator is a coroutine utility that produces a sequence of values lazily, allowing you to write generator functions that yield values one at a time without creating a full collection in memory.", "source": "coroutines"}
{"id": "ce_004", "domain": "cpp_expert", "difficulty": "easy", "question": "What is the key difference between constexpr and consteval functions?", "ground_truth": "constexpr functions can run at compile-time or runtime depending on context, while consteval functions must always run at compile-time and cannot be used in runtime expressions.", "source": "constexpr_consteval"}
{"id": "ce_005", "domain": "cpp_expert", "difficulty": "easy", "question": "What problem does std::mdspan solve that std::vector cannot?", "ground_truth": "std::mdspan provides a multi-dimensional array view with layout and access policies, allowing efficient representation and indexing of multi-dimensional data without owning the underlying storage.", "source": "std::mdspan"}
{"id": "ce_006", "domain": "cpp_expert", "difficulty": "easy", "question": "What is the purpose of concepts in C++20 and later?", "ground_truth": "Concepts define sets of requirements for template parameters, enabling clearer template constraints, better compiler error messages, and function overload resolution based on template parameter properties.", "source": "concepts"}
{"id": "ce_007", "domain": "cpp_expert", "difficulty": "easy", "question": "What does std::format provide that printf-style formatting lacks?", "ground_truth": "std::format provides type-safe formatting with compile-time format string checking, better extensibility for custom types, and integration with C++ streams and strings.", "source": "std::format"}
{"id": "ce_008", "domain": "cpp_expert", "difficulty": "easy", "question": "What is the main advantage of using std::flat_map over std::map?", "ground_truth": "std::flat_map uses contiguous storage (like a vector) for better cache locality and memory efficiency compared to std::map's node-based tree structure, at the cost of slower insertions and deletions.", "source": "flat_map"}
{"id": "ce_009", "domain": "cpp_expert", "difficulty": "easy", "question": "What does std::span provide that std::vector does not?", "ground_truth": "std::span is a non-owning view of a contiguous sequence, allowing zero-copy references to array data without allocation, and can be created from arrays, vectors, or raw pointers.", "source": "span"}
{"id": "ce_010", "domain": "cpp_expert", "difficulty": "easy", "question": "What is structured binding in C++17 and later?", "ground_truth": "Structured binding allows decomposing objects like tuples, arrays, or structs into individual named variables in a single declaration, improving code readability.", "source": "structured_bindings"}
{"id": "ce_011", "domain": "cpp_expert", "difficulty": "easy", "question": "What does RAII stand for and what problem does it solve?", "ground_truth": "RAII (Resource Acquisition Is Initialization) ties resource lifetime to object lifetime, ensuring automatic cleanup when objects are destroyed, preventing resource leaks and providing strong exception safety guarantees.", "source": "RAII"}
{"id": "ce_012", "domain": "cpp_expert", "difficulty": "easy", "question": "When should you use std::unique_ptr versus std::shared_ptr?", "ground_truth": "Use std::unique_ptr for exclusive ownership with zero overhead, and std::shared_ptr when multiple owners need to share responsibility for the same resource and the last owner should clean it up.", "source": "smart_pointers"}
{"id": "ce_013", "domain": "cpp_expert", "difficulty": "easy", "question": "What does move semantics allow that copy semantics does not?", "ground_truth": "Move semantics transfers ownership of resources from one object to another without deep copying, enabling efficient transfer of expensive resources like dynamic memory and improving performance.", "source": "move_semantics"}
{"id": "ce_014", "domain": "cpp_expert", "difficulty": "easy", "question": "What is perfect forwarding and which utility enables it?", "ground_truth": "Perfect forwarding preserves the value category (lvalue or rvalue) of arguments when passing them to another function, and is enabled by std::forward combined with universal references (T&&).", "source": "perfect_forwarding"}
{"id": "ce_015", "domain": "cpp_expert", "difficulty": "easy", "question": "What is the primary benefit of std::jthread over std::thread?", "ground_truth": "std::jthread automatically joins on destruction and supports cancellation tokens, eliminating the risk of detached threads and providing cleaner thread lifecycle management.", "source": "threading"}
{"id": "ce_016", "domain": "cpp_expert", "difficulty": "easy", "question": "What guarantees does std::atomic provide in multithreaded code?", "ground_truth": "std::atomic provides atomic access to shared variables with configurable memory ordering guarantees, preventing data races and ensuring thread-safe reads and writes without explicit locks.", "source": "atomic_operations"}
{"id": "ce_017", "domain": "cpp_expert", "difficulty": "easy", "question": "What is a range view in the C++20 ranges library?", "ground_truth": "A range view is a non-owning, lazy transformation over a range that composes with other views and adapters, allowing efficient chaining of operations without creating intermediate containers.", "source": "ranges_views"}
{"id": "ce_018", "domain": "cpp_expert", "difficulty": "easy", "question": "What is the key improvement of C++23 lambdas with multi-statement bodies in certain contexts?", "ground_truth": "C++23 allows more flexible lambda syntax and deduction patterns, improving usability in template contexts and enabling constexpr lambdas to perform more complex computations at compile-time.", "source": "lambda_improvements"}
{"id": "ce_019", "domain": "cpp_expert", "difficulty": "easy", "question": "What does std::print provide compared to std::cout?", "ground_truth": "std::print is a simpler, safer alternative to std::cout that uses std::format internally for formatted output, avoiding stream state issues and providing a more straightforward API for printing.", "source": "std::print"}
{"id": "ce_020", "domain": "cpp_expert", "difficulty": "easy", "question": "What is template metaprogramming and why is it useful in modern C++?", "ground_truth": "Template metaprogramming uses C++ templates to perform computations at compile-time, enabling zero-runtime-cost abstractions, type-safe generic code, and optimizations that would be impossible at runtime.", "source": "template_metaprogramming"}
{"id": "ce_021", "domain": "cpp_expert", "difficulty": "medium", "question": "Explain the difference between std::expected<T, E> and std::optional<T>. When would you prefer std::expected for error handling in a C++23 codebase?", "ground_truth": "std::optional<T> can only represent success (T) or absence, while std::expected<T, E> carries detailed error information of type E. Use std::expected when you need to propagate meaningful error details; use std::optional when failure needs no context. std::expected supports operator>> for error propagation chains.", "source": "std::expected error handling"}
{"id": "ce_022", "domain": "cpp_expert", "difficulty": "medium", "question": "How do C++20 concepts and constraints improve over traditional SFINAE? Give an example of a constraint that would be clearer with concepts than enable_if.", "ground_truth": "Concepts provide named, reusable type requirements with better compiler diagnostics and readability. Instead of enable_if<is_integral_v<T>>, you write a Concept like 'Integral' and use 'requires Integral<T>'. Concepts generate clearer error messages when constraints fail and compose more naturally than SFINAE.", "source": "concepts and constraints"}
{"id": "ce_023", "domain": "cpp_expert", "difficulty": "medium", "question": "What are the key differences between std::unique_ptr and std::shared_ptr in terms of memory overhead, thread safety, and move semantics?", "ground_truth": "unique_ptr has zero overhead and mandatory move semantics (no copy). shared_ptr has atomic reference counting overhead and supports copying, making it thread-safe for incrementing/decrementing counts but requiring synchronization for object access. unique_ptr is preferred when exclusive ownership is clear; shared_ptr when ownership is shared.", "source": "smart pointers"}
{"id": "ce_024", "domain": "cpp_expert", "difficulty": "medium", "question": "Explain perfect forwarding using std::forward and when it fails. Give a scenario where a forwarding template cannot perfectly forward a lvalue reference.", "ground_truth": "std::forward preserves value category (lvalue stays lvalue, rvalue stays rvalue) for template parameters. Perfect forwarding fails with bitfields, initializer lists, and incomplete types. For example, forwarding a bitfield extracts its value, losing the binding to the original object.", "source": "perfect forwarding"}
{"id": "ce_025", "domain": "cpp_expert", "difficulty": "medium", "question": "How do C++20 modules improve compilation time and symbol visibility compared to header files? What are the trade-offs when migrating existing code to modules?", "ground_truth": "Modules eliminate the need for include guards and redundant preprocessing, enabling parallel compilation and faster builds. They provide explicit interface/implementation separation and reduce ODR violations. Trade-offs include ecosystem immaturity, limited tool support, and difficulty mixing with legacy headers.", "source": "C++20 modules"}
{"id": "ce_026", "domain": "cpp_expert", "difficulty": "medium", "question": "Explain the relationship between std::span<T> and std::mdspan. When would you use mdspan instead of a vector of vectors for multidimensional data?", "ground_truth": "std::span is a non-owning view over contiguous 1D sequences; std::mdspan extends this to multidimensional arrays with custom layouts (C, Fortran order, etc.). Use mdspan for cache-efficient access patterns, scientific computing, and when you need strided or transposed views without copying.", "source": "std::span and std::mdspan"}
{"id": "ce_027", "domain": "cpp_expert", "difficulty": "medium", "question": "Describe how std::generator from C++23 simplifies writing coroutines compared to manual promise_type implementations. What are the limitations?", "ground_truth": "std::generator<T> provides a ready-made coroutine wrapper for yielding sequences, eliminating boilerplate promise_type code. Limitations include single-value co_yield only (not exceptions), no suspension-point customization, and compiler support variance. Manual coroutines remain necessary for complex state machines.", "source": "coroutines with std::generator"}
{"id": "ce_028", "domain": "cpp_expert", "difficulty": "medium", "question": "What is the difference between constexpr and consteval functions? In what scenarios would you use consteval instead of constexpr?", "ground_truth": "constexpr can evaluate at compile-time or runtime; consteval forces compile-time evaluation only. Use consteval for compile-time-only metaprogramming, type-level computations, and to guarantee no runtime cost. constexpr is more flexible when runtime evaluation is acceptable.", "source": "constexpr and consteval"}
{"id": "ce_029", "domain": "cpp_expert", "difficulty": "medium", "question": "Explain how structured bindings (C++17) interact with move semantics. Why can't you use structured bindings to move-extract elements from a container?", "ground_truth": "Structured bindings create references to the original object, not moved copies. To move-extract, you must use std::move(container).at(i) and bind non-const references, or move into a temporary struct. Direct binding always creates references, preserving const semantics.", "source": "structured bindings"}
{"id": "ce_030", "domain": "cpp_expert", "difficulty": "medium", "question": "Compare the performance and use cases of std::flat_map versus std::map. When is the cache-friendly layout of flat_map worth its insertion/deletion costs?", "ground_truth": "flat_map uses contiguous storage for better cache locality and lower memory overhead than std::map's tree. Prefer flat_map for read-heavy workloads, small maps, or when insertion frequency is low. Use std::map when frequent insertions/deletions dominate or large datasets require O(log n) single operations.", "source": "flat_map"}
{"id": "ce_031", "domain": "cpp_expert", "difficulty": "medium", "question": "How do ranges views and adaptors (C++20) improve expressiveness over traditional iterator ranges? Give an example of a transformation chain impossible with std::algorithm.", "ground_truth": "Ranges support lazy composition and chainable adaptors (e.g., filter | transform | take). Traditional algorithms force eager evaluation and intermediate storage. Example: `vec | views::filter(predicate) | views::transform(fn) | views::take(n)` computes values on-demand without temporaries.", "source": "ranges library with views and adaptors"}
{"id": "ce_032", "domain": "cpp_expert", "difficulty": "medium", "question": "Explain the memory model implications of std::atomic<T> operations and memory ordering. When should you use std::memory_order_acquire instead of memory_order_seq_cst?", "ground_truth": "acquire ordering provides synchronization for dependent loads without full sequential consistency overhead. Use acquire when you need to prevent subsequent operations from reordering before a load, but don't require global ordering. seq_cst is slower but guarantees a single total order\u2014use when correctness requires strong guarantees.", "source": "atomic operations and memory model"}
{"id": "ce_033", "domain": "cpp_expert", "difficulty": "medium", "question": "How does RAII prevent resource leaks in the presence of exceptions? Illustrate with a file-handling example and explain why manual cleanup is insufficient.", "ground_truth": "RAII binds resource acquisition to object construction and release to destruction, guaranteed by stack unwinding during exceptions. Manual cleanup fails if exceptions occur between acquisition and cleanup. Example: a file_guard class acquires on construction, closes on destruction\u2014safe even if operations throw.", "source": "RAII principle"}
{"id": "ce_034", "domain": "cpp_expert", "difficulty": "medium", "question": "Describe how jthread improves upon std::thread in C++20. What makes jthread exception-safe and how does its stop_token mechanism work?", "ground_truth": "jthread automatically joins on destruction (RAII), preventing detached leaks. stop_token provides cooperative cancellation without signals. Construction guarantees join on scope exit, even if exceptions occur. Use jthread by default; std::thread only when you need explicit non-joining behavior.", "source": "threading with jthread"}
{"id": "ce_035", "domain": "cpp_expert", "difficulty": "medium", "question": "What are the trade-offs between template metaprogramming using constexpr and traditional TMP with type traits? When would you still choose traditional TMP?", "ground_truth": "constexpr TMP is more readable and debuggable but limited to compile-time computation; traditional type traits excel at type manipulation and SFINAE. Use constexpr for value computation; use type traits when you need type-level specialization, inheritance chains, or toolkit consistency with older code.", "source": "template metaprogramming"}
{"id": "ce_036", "domain": "cpp_expert", "difficulty": "medium", "question": "Explain std::format and std::print from C++20/23. How do they improve over printf and std::cout in terms of safety and performance?", "ground_truth": "std::format provides type-safe formatting with zero-overhead abstraction and compile-time format string validation (C++23). std::print handles output redirection and locale correctly. Both avoid printf vulnerabilities (format string attacks) and manage ostream state automatically, with faster performance than cout chains.", "source": "std::format and std::print"}
{"id": "ce_037", "domain": "cpp_expert", "difficulty": "medium", "question": "How do lambda improvements in C++20/23 (e.g., template parameters, captures by pack, deduced return types) enable patterns impossible in C++17?", "ground_truth": "C++20 adds template parameters to lambdas (generic lambdas without explicit templates), pack captures for perfect forwarding, and implicit deduction of return types. This enables higher-order function composition and reduces boilerplate for generic algorithms without writing full function templates.", "source": "lambda improvements"}
{"id": "ce_038", "domain": "cpp_expert", "difficulty": "medium", "question": "Describe a scenario where move semantics reduces unnecessary copies in an STL algorithm. How does std::move_iterator enable this optimization?", "ground_truth": "When transforming a container with std::copy(v.begin(), v.end(), result.begin()), heavy objects are copied. std::move_iterator(v.begin()) forces move assignment, reducing overhead. Example: copying strings into a new vector becomes move-assignment, preserving allocated buffers.", "source": "move semantics"}
{"id": "ce_039", "domain": "cpp_expert", "difficulty": "medium", "question": "What are the time and space complexity trade-offs when choosing between std::vector, std::deque, and std::list for a high-insertion workload? Justify your choice for a real-time system.", "ground_truth": "vector: amortized O(1) push_back, contiguous cache-friendly; deque: O(1) front/back insertion, no reallocation; list: O(1) insertion anywhere but cache-unfriendly and O(n) access. For real-time: deque avoids latency spikes from vector reallocation while maintaining O(1) operations.", "source": "STL containers and algorithms"}
{"id": "ce_040", "domain": "cpp_expert", "difficulty": "medium", "question": "Explain how combining std::expected with ranges and coroutines enables ergonomic error handling in C++23. Give an example of chaining operations with error propagation.", "ground_truth": "std::expected's operator>> enables monadic chaining in range pipelines; combine with std::generator to yield results or errors lazily. Example: a pipeline of async operations each returning expected<T, E> can chain with ranges::filter(has_value) and transform(unwrap), propagating errors implicitly.", "source": "error handling integration"}
{"id": "ce_041", "domain": "cpp_expert", "difficulty": "hard", "question": "Explain the interaction between C++20 modules and ODR (One Definition Rule). Why can you define the same symbol in multiple translation units when using modules, and what are the implications for template instantiation across module boundaries?", "ground_truth": "Modules create a new namespace for definitions that isolates internal linkage and module-private entities from ODR violations. Template instantiation across module boundaries uses the instantiation context of the importer (point of instantiation), not the module interface, requiring explicit export of template definitions or use of export syntax. This prevents duplicate instantiations and symbol conflicts.", "source": "modules_odr_semantics"}
{"id": "ce_042", "domain": "cpp_expert", "difficulty": "hard", "question": "In C++23, when using std::expected<T, E>, explain the performance and ABI implications of choosing E to be a polymorphic exception hierarchy versus a simple enum or custom struct. What are the trade-offs regarding object layout, copy elision, and error propagation chains?", "ground_truth": "Polymorphic exception hierarchies in std::expected increase storage overhead (vtable pointer) and prevent empty base optimization, while enum-based errors enable more aggressive inlining and smaller objects. Polymorphic types disable copy elision for error paths due to runtime type checking requirements. Enum errors provide better performance but lose type information; custom structs offer middle ground with predictable layout and potential ABI stability issues.", "source": "expected_error_design"}
{"id": "ce_043", "domain": "cpp_expert", "difficulty": "hard", "question": "Describe the lifetime semantics and memory safety guarantees of std::mdspan when used with a custom accessor and layout combination. What happens if the underlying data is deallocated while mdspan views exist, and how do concepts constrain safe accessor implementations?", "ground_truth": "std::mdspan provides no lifetime management\u2014it is a non-owning view that relies on the user to ensure data validity. Custom accessors must satisfy ElementAccessor concept constraints requiring proper reference semantics. If underlying data is deallocated, dereferencing mdspan causes undefined behavior; the layout and accessor concepts cannot prevent this. Safety depends entirely on disciplined lifetime management by the user.", "source": "mdspan_lifetime_safety"}
{"id": "ce_044", "domain": "cpp_expert", "difficulty": "hard", "question": "When designing a coroutine with std::generator<T> in C++23, explain how the promise_type manages suspension points and what happens to the coroutine state machine if an exception is thrown in the generator body. How does this differ from manually implemented coroutines?", "ground_truth": "std::generator's promise_type automatically manages co_yield suspension and co_return cleanup, storing yielded values in the coroutine frame. Exceptions thrown in the body propagate to the caller on next() iteration and terminate the coroutine. Manual coroutines require explicit exception handling in promise callbacks; std::generator abstracts this via standard semantics, providing exception safety guarantees and automatic frame destruction.", "source": "generator_exception_semantics"}
{"id": "ce_045", "domain": "cpp_expert", "difficulty": "hard", "question": "Explain the difference between constexpr and consteval in C++20/23, including when the compiler is required to evaluate at compile-time versus when it may defer. How do consteval functions interact with template instantiation and what are the security implications for constant-time cryptographic functions?", "ground_truth": "constexpr allows both compile-time and runtime evaluation (compiler chooses), while consteval forces compile-time evaluation. consteval functions cannot be called at runtime, making them unsuitable for APIs requiring runtime use. In templates, consteval instantiation occurs at definition time, not instantiation time. For crypto, consteval prevents runtime timing attacks but sacrifices flexibility; constexpr requires discipline to avoid cache-timing vulnerabilities.", "source": "constexpr_consteval_semantics"}
{"id": "ce_046", "domain": "cpp_expert", "difficulty": "hard", "question": "Design a thread-safe lazy singleton using C++17 features (not std::call_once) that handles exception safety, prevents double-checked locking issues, and works correctly with std::jthread. What memory ordering guarantees are required and why?", "ground_truth": "Use a static local variable (guaranteed thread-safe by C++11 magic statics with release/acquire semantics) or atomic<T*> with acquire/release ordering. jthread compatibility requires the singleton outlive all threads accessing it; use a shared_ptr or guard with a scoped_lock. Avoid double-checked locking without explicit atomic operations\u2014rely on compiler-generated synchronization. acquire/release sufficient for publication; full sequential_consistency unnecessary.", "source": "singleton_thread_safety"}
{"id": "ce_047", "domain": "cpp_expert", "difficulty": "hard", "question": "Explain the interaction between perfect forwarding, std::move_if_noexcept, and move constructors with noexcept specifications in generic code. When should you use std::forward versus std::move_if_noexcept in a container's emplacement function?", "ground_truth": "std::forward preserves lvalue/rvalue category; std::move_if_noexcept moves only if the move constructor is noexcept. In emplacement, use std::forward to preserve passed argument category (respecting user intent), but internally container must use move_if_noexcept when relocating elements on reallocation for exception safety. Perfect forwarding in public APIs, move_if_noexcept in implementation for exception guarantee preservation.", "source": "perfect_forwarding_noexcept"}
{"id": "ce_048", "domain": "cpp_expert", "difficulty": "hard", "question": "In C++20 concepts, explain the difference between syntactic and semantic constraints. Write a conceptual constraint that prevents infinite recursion in template instantiation and discuss why compiler cannot verify semantic constraints statically.", "ground_truth": "Syntactic constraints (requires expressions) check compilability; semantic constraints document expected behavior (e.g., 'equality must be transitive'). Use depth-limiting or 'is not derived from self' syntactic checks to prevent recursion. Compilers cannot verify semantic constraints\u2014they require documentation and testing. Violating semantic constraints causes subtle bugs, not compiler errors. Good concept design minimizes semantic requirements or makes them checkable.", "source": "concepts_constraint_semantics"}
{"id": "ce_049", "domain": "cpp_expert", "difficulty": "hard", "question": "Analyze the performance implications of using std::ranges::views::lazy_split with a large container versus eager splitting. Explain how iterator invalidation, composition with other views, and memory allocation differ. When would eager splitting be safer?", "ground_truth": "lazy_split creates iterators on-demand without allocating; composing views chains transformations lazily, reducing intermediate allocations. However, lazy evaluation defers cost to iteration, complicating performance prediction and causing iterator invalidation on source mutation. Eager splitting (collect into vector) trades upfront allocation for guaranteed validity and predictable performance. Use eager splitting when source mutates, iterator lifetime spans uncontrolled code, or iteration happens multiple times.", "source": "ranges_lazy_evaluation_tradeoffs"}
{"id": "ce_050", "domain": "cpp_expert", "difficulty": "hard", "question": "Describe a scenario where std::shared_ptr causes a memory leak or dangling pointer despite being exception-safe. Include circular references, custom deleters throwing exceptions, and weak_ptr aliasing. How does std::make_shared mitigate some issues?", "ground_truth": "Circular references (A holds shared_ptr to B, B holds shared_ptr to A) prevent deallocation; use weak_ptr to break cycles. Custom deleters throwing exceptions during destruction cause leaks if exception escapes destructor (undefined behavior). shared_ptr aliasing (constructor taking get_ptr() of other shared_ptr) can create dangling pointers if control block outlives the aliased object's destructor. std::make_shared allocates control block and data together, improving cache locality and slightly reducing overhead, but does not solve cycles or custom deleter issues.", "source": "shared_ptr_pitfalls_lifecycle"}
