{"id": "fg_001", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What is Microsoft Fabric API for GraphQL?", "ground_truth": "Microsoft Fabric API for GraphQL is a GraphQL API service that enables you to query and interact with data stored in Microsoft Fabric, allowing applications to connect and retrieve data through standardized GraphQL operations.", "source": "fabric_graphql_overview"}
{"id": "fg_002", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What is the primary purpose of the Fabric API for GraphQL editor?", "ground_truth": "The Fabric API for GraphQL editor is a tool that allows users to write, test, and manage GraphQL queries and mutations directly within the Microsoft Fabric interface.", "source": "graphql_editor"}
{"id": "fg_003", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "How can you add data to a Fabric API for GraphQL?", "ground_truth": "You can add data to a Fabric API for GraphQL by creating a GraphQL schema that maps to your data sources and then using mutations or stored procedures to insert and modify data.", "source": "create_and_add_data"}
{"id": "fg_004", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What is GraphQL introspection in the context of Fabric API?", "ground_truth": "GraphQL introspection is a built-in feature that allows you to query the GraphQL schema itself to discover available types, fields, and operations, and Fabric API for GraphQL supports schema introspection and export capabilities.", "source": "introspection_and_schema_export"}
{"id": "fg_005", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "Can stored procedures be used with Fabric API for GraphQL?", "ground_truth": "Yes, stored procedures can be integrated with Fabric API for GraphQL, allowing you to execute database stored procedures through GraphQL operations.", "source": "stored_procedures"}
{"id": "fg_006", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What is the purpose of the Schema explorer in Fabric API for GraphQL?", "ground_truth": "The Schema explorer provides a visual interface to browse and understand your GraphQL schema structure, types, and relationships defined in your Fabric API for GraphQL.", "source": "schema_view_and_explorer"}
{"id": "fg_007", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "How do applications connect to Fabric API for GraphQL?", "ground_truth": "Applications connect to Fabric API for GraphQL by using the API endpoint URL and appropriate authentication credentials (such as service principals or user credentials) to send GraphQL queries and mutations.", "source": "connect_applications"}
{"id": "fg_008", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What are Service Principals used for in Fabric API for GraphQL?", "ground_truth": "Service Principals are used to authenticate and authorize applications to access Fabric API for GraphQL without requiring user credentials, enabling secure programmatic access.", "source": "service_principals"}
{"id": "fg_009", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What is the benefit of integrating Azure API Management with Fabric API for GraphQL?", "ground_truth": "Integrating Azure API Management (APIM) with Fabric API for GraphQL provides additional features such as rate limiting, authentication, API versioning, and monitoring capabilities for your GraphQL APIs.", "source": "apim_integration"}
{"id": "fg_010", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What is GraphQL operation logging in Fabric?", "ground_truth": "GraphQL operation logging records details about GraphQL queries and mutations executed against your Fabric API for GraphQL, providing visibility into API usage and performance.", "source": "graphql_operation_logs"}
{"id": "fg_011", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What does the GraphQL monitoring dashboard help you track?", "ground_truth": "The GraphQL monitoring dashboard provides insights into API performance, query execution times, error rates, and usage metrics for your Fabric API for GraphQL operations.", "source": "monitoring_dashboard"}
{"id": "fg_012", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "Can you create a GraphQL API from a SQL database in Fabric?", "ground_truth": "Yes, you can create a GraphQL API in your SQL database within Fabric by defining a GraphQL schema that maps to your SQL tables and relationships.", "source": "create_graphql_sql_database"}
{"id": "fg_013", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What is source control used for in Fabric API for GraphQL?", "ground_truth": "Source control in Fabric API for GraphQL allows you to version control your GraphQL schemas and API definitions, enabling collaboration and change tracking.", "source": "source_control"}
{"id": "fg_014", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What are deployment pipelines in Fabric API for GraphQL?", "ground_truth": "Deployment pipelines enable you to automatically deploy and promote your GraphQL API changes across different environments such as development, staging, and production.", "source": "deployment_pipelines"}
{"id": "fg_015", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What is mentioned in the FAQ about common questions regarding Fabric API for GraphQL?", "ground_truth": "The Fabric API for GraphQL FAQ addresses common questions about setup, configuration, authentication, performance, and best practices for using GraphQL APIs in Fabric.", "source": "faq"}
{"id": "fg_016", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What performance best practices are recommended for Fabric API for GraphQL?", "ground_truth": "Performance best practices for Fabric API for GraphQL include optimizing query structure, using indexes on data sources, limiting query depth, and monitoring execution times.", "source": "performance_best_practices"}
{"id": "fg_017", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "How does schema export work in Fabric API for GraphQL?", "ground_truth": "Schema export allows you to export your GraphQL schema definition from Fabric API for GraphQL, enabling you to use it in other tools or documentation.", "source": "schema_export"}
{"id": "fg_018", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What type of data sources can Fabric API for GraphQL connect to?", "ground_truth": "Fabric API for GraphQL can connect to various data sources including SQL databases, data warehouses, and other data stores within Microsoft Fabric.", "source": "data_sources"}
{"id": "fg_019", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "What is a GraphQL mutation in the context of Fabric API?", "ground_truth": "A GraphQL mutation in Fabric API for GraphQL is an operation that modifies data, allowing you to create, update, or delete records in your data sources.", "source": "graphql_mutations"}
{"id": "fg_020", "domain": "fabric_graph_gql_expert", "difficulty": "easy", "question": "How is authentication managed for Fabric API for GraphQL?", "ground_truth": "Authentication for Fabric API for GraphQL can be managed through multiple methods including Azure AD, service principals, and API keys, depending on your security requirements.", "source": "authentication"}
{"id": "fg_021", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What is the primary purpose of Microsoft Fabric API for GraphQL, and how does it differ from traditional REST APIs?", "ground_truth": "Fabric API for GraphQL provides a flexible query language that allows clients to request exactly the data they need, reducing over-fetching and under-fetching problems common in REST APIs. It enables efficient data retrieval from Microsoft Fabric data sources through a single endpoint.", "source": "What is Microsoft Fabric API for GraphQL"}
{"id": "fg_022", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "How do you create a GraphQL schema in Fabric API for GraphQL when working with SQL databases?", "ground_truth": "You define your GraphQL schema either manually in the editor or by connecting to a SQL database table/view, which auto-generates the schema based on the table structure. The schema defines the types, fields, and relationships available for querying.", "source": "Create GraphQL API in your SQL database"}
{"id": "fg_023", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What are the key benefits of using the Fabric API for GraphQL Schema explorer?", "ground_truth": "The Schema explorer provides a visual and interactive way to browse the available types, fields, and operations in your GraphQL API without needing to examine raw schema files. It helps developers understand the API structure and discover available queries.", "source": "Fabric API for GraphQL schema view and Schema explorer"}
{"id": "fg_024", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "How can Service Principals be used with Fabric API for GraphQL, and what security advantage do they provide?", "ground_truth": "Service Principals allow applications to authenticate and authorize API calls without user interaction, enabling automated and secure service-to-service communication. They provide enhanced security by avoiding credential exposure in application code.", "source": "Use Service Principals with Fabric API for GraphQL"}
{"id": "fg_025", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What role do Stored Procedures play in Fabric API for GraphQL, and when would you use them?", "ground_truth": "Stored Procedures can be called through GraphQL resolvers to execute complex database operations or business logic. Use them when you need to implement calculations, multi-step operations, or database-level validations within your GraphQL API.", "source": "Use Stored Procedures with Fabric API for GraphQL"}
{"id": "fg_026", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "How does Introspection work in Fabric API for GraphQL, and why is Schema Export important?", "ground_truth": "Introspection allows clients to query the GraphQL schema itself to discover available types and operations. Schema Export enables you to extract and document the complete schema definition, facilitating version control, CI/CD pipelines, and sharing with development teams.", "source": "Microsoft Fabric API for GraphQL Introspection and Schema Export"}
{"id": "fg_027", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What are the considerations for integrating Azure API Management (APIM) with Fabric API for GraphQL?", "ground_truth": "APIM integration provides centralized API management, including rate limiting, authentication policies, request/response transformation, and analytics. It enables you to govern API access, enforce policies, and monitor usage across multiple GraphQL APIs.", "source": "Integrate Azure API Management (APIM) with Fabric API for GraphQL"}
{"id": "fg_028", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What performance best practices should be followed when designing Fabric API for GraphQL queries?", "ground_truth": "Key practices include using field selection to limit returned data, implementing pagination for large datasets, optimizing resolver implementations, batching related queries, and avoiding deeply nested queries to reduce query complexity and execution time.", "source": "Fabric API for GraphQL Performance Best Practices"}
{"id": "fg_029", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "How do GraphQL operation logs assist in troubleshooting and monitoring API usage?", "ground_truth": "Operation logs record detailed information about each GraphQL query execution, including query text, execution time, errors, and client details. They help identify performance bottlenecks, debug failing queries, and track API usage patterns for optimization.", "source": "GraphQL operation logs"}
{"id": "fg_030", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What features does the GraphQL monitoring dashboard provide for API observability?", "ground_truth": "The monitoring dashboard provides real-time visibility into API performance metrics, query execution patterns, error rates, and resource consumption. It helps identify trends, performance issues, and usage anomalies for proactive management.", "source": "GraphQL monitoring dashboard and logging (preview)"}
{"id": "fg_031", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "How does the Microsoft Fabric API for GraphQL editor facilitate API development?", "ground_truth": "The editor provides a visual interface for creating and editing GraphQL schemas, writing and testing queries, and configuring resolvers. It includes syntax highlighting, validation, auto-completion, and query testing capabilities to streamline development.", "source": "Microsoft Fabric API for GraphQL editor"}
{"id": "fg_032", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What steps are involved in connecting applications to Fabric API for GraphQL?", "ground_truth": "Applications connect by obtaining the API endpoint URL, acquiring authentication credentials (tokens, keys, or service principal), and sending GraphQL queries via HTTP POST requests to the endpoint. The API endpoint and authentication method must be configured in the application.", "source": "Connect applications to Fabric API for GraphQL"}
{"id": "fg_033", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "How does source control integration enhance Fabric API for GraphQL deployment workflows?", "ground_truth": "Source control enables versioning of schema definitions and configurations, facilitates collaborative development, and supports CI/CD pipelines for automated testing and deployment. It allows teams to track changes, review modifications, and maintain audit trails.", "source": "Source control and deployment pipelines in API for GraphQL (preview)"}
{"id": "fg_034", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What are the key differences between using the GraphQL editor directly versus defining schemas programmatically?", "ground_truth": "The visual editor provides an interactive, user-friendly interface for schema creation and modification with real-time validation, while programmatic approaches enable automation, version control integration, and integration with development pipelines for larger deployments.", "source": "Microsoft Fabric API for GraphQL editor"}
{"id": "fg_035", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "How can you optimize resolver performance when implementing complex business logic in Fabric API for GraphQL?", "ground_truth": "Optimize by minimizing database calls through batching, caching frequently accessed data, using efficient queries, implementing pagination, and avoiding N+1 query problems through proper data loading strategies. Consider query complexity analysis to prevent resource exhaustion.", "source": "Fabric API for GraphQL Performance Best Practices"}
{"id": "fg_036", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What security considerations should be addressed when exposing a SQL database through Fabric API for GraphQL?", "ground_truth": "Implement field-level security to control which users access sensitive fields, validate and sanitize inputs to prevent injection attacks, use Service Principals for service authentication, enforce rate limiting through APIM, and audit access patterns through operation logs.", "source": "Use Service Principals with Fabric API for GraphQL"}
{"id": "fg_037", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "How do deployment pipelines in Fabric API for GraphQL support multi-environment workflows?", "ground_truth": "Deployment pipelines enable promotion of schema and configuration changes from development through staging to production environments, with validation and testing at each stage. They support rollback capabilities and maintain consistency across environments.", "source": "Source control and deployment pipelines in API for GraphQL (preview)"}
{"id": "fg_038", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What information is available in the FAQ regarding common challenges with Fabric API for GraphQL?", "ground_truth": "The FAQ addresses common questions about API limitations, authentication methods, schema design best practices, performance considerations, troubleshooting steps, and integration patterns to help developers overcome typical implementation challenges.", "source": "Microsoft Fabric API for GraphQL FAQ"}
{"id": "fg_039", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "How can you use Query Analysis and Cost Assessment features to improve API efficiency?", "ground_truth": "Query analysis tools examine query execution patterns and complexity, identifying inefficient queries and costly operations. Cost assessment helps predict resource consumption, allowing optimization of queries and resolver implementations before performance issues impact users.", "source": "Fabric API for GraphQL Performance Best Practices"}
{"id": "fg_040", "domain": "fabric_graph_gql_expert", "difficulty": "medium", "question": "What are the trade-offs between auto-generating a GraphQL schema from existing SQL tables versus manually defining custom schemas?", "ground_truth": "Auto-generated schemas provide quick API creation with minimal effort but expose all table structure. Custom schemas offer control over field exposure, naming conventions, and relationships, supporting better API design but requiring more development effort and maintenance.", "source": "Create GraphQL API in your SQL database"}
{"id": "fg_041", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "When using Service Principals with Fabric API for GraphQL, what authentication flow must be implemented to ensure secure token acquisition, and what are the implications for application-level permission scoping?", "ground_truth": "Service Principals use OAuth 2.0 client credentials flow to acquire bearer tokens from Azure AD, requiring proper configuration of app registrations and permissions at the workspace level. Permission scoping must be managed through workspace roles and dataset permissions, as Service Principals inherit access based on their assigned roles rather than individual user permissions.", "source": "service_principals_authentication"}
{"id": "fg_042", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "Explain the relationship between GraphQL schema introspection capabilities and security considerations when exposing a Fabric API for GraphQL endpoint. What schema information should be carefully controlled?", "ground_truth": "Introspection queries expose the complete GraphQL schema structure including all types, fields, and arguments available in the API. To prevent information disclosure vulnerabilities, introspection should be disabled in production environments, and schema access should be restricted through Azure API Management or application-level query filtering to prevent schema enumeration attacks.", "source": "schema_introspection_security"}
{"id": "fg_043", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "How does the schema view and Schema explorer in Fabric API for GraphQL aid in performance optimization, and what metrics should be monitored to identify problematic resolver patterns?", "ground_truth": "The Schema explorer visualizes data relationships and field dependencies, helping identify N+1 query problems and deeply nested field structures that degrade performance. Critical metrics to monitor include query execution time, resolver call counts per query, and field-level latency through GraphQL operation logs to detect queries with excessive resolver invocations.", "source": "schema_explorer_performance"}
{"id": "fg_044", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "When integrating Stored Procedures with Fabric API for GraphQL, what are the constraints and best practices for handling transactional consistency and error handling across multiple procedure calls within a single GraphQL mutation?", "ground_truth": "Stored Procedures called from GraphQL mutations execute within the database transaction context, but GraphQL-level error handling must account for partial failures. Best practices include wrapping multiple procedure calls in database transactions, implementing idempotent operations, and using GraphQL error extensions to surface database-specific errors while maintaining data consistency.", "source": "stored_procedures_transactions"}
{"id": "fg_045", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "Describe how source control and deployment pipelines in Fabric API for GraphQL differ from traditional CI/CD practices, and what challenges arise when managing schema versioning across development, staging, and production environments.", "ground_truth": "Fabric deployment pipelines require schema validation and workspace-level permissions management, as GraphQL schemas are workspace artifacts. Challenges include handling breaking schema changes, managing field deprecations, coordinating client updates with schema deployments, and ensuring backward compatibility across environments without maintaining multiple API versions.", "source": "source_control_deployment"}
{"id": "fg_046", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "How should Azure API Management (APIM) be configured when fronting a Fabric API for GraphQL to enforce rate limiting, and what are the implications for subscription-based or multi-tenant scenarios?", "ground_truth": "APIM applies rate limiting policies at the operation level, with GraphQL requiring policy configuration on the single POST endpoint. For multi-tenant scenarios, rate limits must account for token-based identification (claims in JWT), subscription-level throttling via APIM subscriptions, and potential request complexity analysis to prevent query-based DoS attacks rather than simple request counting.", "source": "apim_rate_limiting"}
{"id": "fg_047", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "What specific query complexity metrics should be tracked in the GraphQL monitoring dashboard to predict performance degradation, and how do timeout configurations interact with these metrics?", "ground_truth": "Critical metrics include query depth (field nesting levels), field selection count, resolver execution time distribution, and database query count per GraphQL operation. Timeout configurations at both GraphQL engine and database levels must be coordinated; insufficient timeouts mask performance issues while excessive timeouts mask resource exhaustion, requiring profiling via operation logs to establish baselines.", "source": "monitoring_dashboard_performance"}
{"id": "fg_048", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "When creating a GraphQL API in a SQL database through Fabric, what are the limitations of automatic schema generation from relational structures, and how should these be addressed for complex business logic?", "ground_truth": "Automatic schema generation cannot represent complex business logic, computed fields, or multi-table aggregations expressed as single GraphQL fields. These must be implemented through Stored Procedures or calculated columns in the underlying views, requiring additional schema customization beyond auto-generation and careful management of resolver mapping between GraphQL fields and database artifacts.", "source": "sql_schema_generation"}
{"id": "fg_049", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "Analyze the security trade-offs between exposing calculated fields directly in the GraphQL schema versus implementing them as Stored Procedures, considering permission boundaries and audit requirements.", "ground_truth": "Direct calculated fields execute within the GraphQL engine context with no separate audit trail for calculation logic, while Stored Procedures execute in database context with full audit logging and granular permission control. Stored Procedures are preferred for sensitive calculations requiring compliance auditing, but incur additional latency; direct fields optimize performance for non-sensitive calculations at the cost of reduced auditability.", "source": "calculated_fields_security"}
{"id": "fg_050", "domain": "fabric_graph_gql_expert", "difficulty": "hard", "question": "How should GraphQL operation logs be leveraged to diagnose and resolve production incidents involving slow queries or high error rates, and what post-incident optimization strategies align with Fabric API for GraphQL architecture?", "ground_truth": "Operation logs capture resolver-level execution times, field-by-field latency, and database query counts, enabling root cause analysis of slow queries through field-level profiling. Optimization strategies include adding database indexes identified through logs, implementing field-level caching for expensive resolvers, refactoring Stored Procedures identified as bottlenecks, and adjusting query complexity limits based on observed patterns.", "source": "operation_logs_troubleshooting"}
