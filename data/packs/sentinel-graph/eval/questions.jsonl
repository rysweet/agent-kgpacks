{"id": "sg_001", "domain": "sentinel_graph", "difficulty": "easy", "question": "What does KQL stand for in the context of Microsoft Sentinel?", "ground_truth": "KQL stands for Kusto Query Language. It is the query language used in Microsoft Sentinel to search, filter, and analyze security data stored in Log Analytics workspaces.", "source": "KQL"}
{"id": "sg_002", "domain": "sentinel_graph", "difficulty": "easy", "question": "What is the primary purpose of analytic rules in Microsoft Sentinel?", "ground_truth": "Analytic rules detect suspicious activities and generate alerts and incidents by running scheduled or near-real-time queries against ingested data. They form the foundation of threat detection in Sentinel.", "source": "analytic_rules"}
{"id": "sg_003", "domain": "sentinel_graph", "difficulty": "easy", "question": "Name two types of analytic rules available in Microsoft Sentinel.", "ground_truth": "Two common types are Scheduled rules (which run at regular intervals) and Microsoft Security rules (which are based on Microsoft security alerts and detections). Other types include Fusion and ML Behavior Analytics rules.", "source": "analytic_rules"}
{"id": "sg_004", "domain": "sentinel_graph", "difficulty": "easy", "question": "What Microsoft service does Microsoft Sentinel use to create automated workflows and responses?", "ground_truth": "Microsoft Sentinel uses Azure Logic Apps to create playbooks, which are automated workflows that respond to alerts and incidents with predefined actions such as notifications or remediation steps.", "source": "playbooks"}
{"id": "sg_005", "domain": "sentinel_graph", "difficulty": "easy", "question": "What are data connectors in Microsoft Sentinel?", "ground_truth": "Data connectors are integrations that ingest security data from external sources such as cloud services, on-premises systems, and third-party applications into Microsoft Sentinel for analysis and threat detection.", "source": "data_connectors"}
{"id": "sg_006", "domain": "sentinel_graph", "difficulty": "easy", "question": "Define threat hunting in the context of Microsoft Sentinel.", "ground_truth": "Threat hunting is the proactive process of searching through security data in Sentinel to discover undetected threats, compromises, or suspicious patterns that automated detection rules may have missed.", "source": "threat_hunting"}
{"id": "sg_007", "domain": "sentinel_graph", "difficulty": "easy", "question": "What is the difference between an alert and an incident in Microsoft Sentinel?", "ground_truth": "An alert is a single detection generated by an analytic rule, while an incident is a collection of related alerts that together indicate a potential security threat. Incidents group multiple alerts for investigation.", "source": "incidents_alerts"}
{"id": "sg_008", "domain": "sentinel_graph", "difficulty": "easy", "question": "What does UEBA stand for in Microsoft Sentinel?", "ground_truth": "UEBA stands for User and Entity Behavior Analytics. It is a Sentinel feature that uses machine learning to detect abnormal user and entity behavior that may indicate a security breach or insider threat.", "source": "UEBA"}
{"id": "sg_009", "domain": "sentinel_graph", "difficulty": "easy", "question": "What is the purpose of entity mapping in Microsoft Sentinel analytic rules?", "ground_truth": "Entity mapping links query results to known entities such as users, hosts, IP addresses, or files. This enriches alerts with context and enables the investigation graph to visualize relationships between entities.", "source": "entity_mapping"}
{"id": "sg_010", "domain": "sentinel_graph", "difficulty": "easy", "question": "What are watchlists used for in Microsoft Sentinel?", "ground_truth": "Watchlists are custom lists of entities such as IP addresses, users, or file hashes that can be imported and used in KQL queries and analytic rules to identify known bad actors, sensitive accounts, or assets.", "source": "watchlists"}
{"id": "sg_011", "domain": "sentinel_graph", "difficulty": "easy", "question": "What is the Microsoft Sentinel Content Hub?", "ground_truth": "The Content Hub is a centralized repository in Sentinel where users can discover, deploy, and manage pre-built solutions including data connectors, analytic rules, workbooks, and playbooks provided by Microsoft and partners.", "source": "content_hub"}
{"id": "sg_012", "domain": "sentinel_graph", "difficulty": "easy", "question": "What is the Microsoft Graph Security API used for in Sentinel integrations?", "ground_truth": "The Microsoft Graph Security API allows Sentinel and other security applications to query and retrieve security alerts and data from Microsoft security services, enabling unified threat intelligence and incident correlation.", "source": "Microsoft_Graph_Security_API"}
{"id": "sg_013", "domain": "sentinel_graph", "difficulty": "easy", "question": "What is the investigation graph in Microsoft Sentinel?", "ground_truth": "The investigation graph is a visual representation of entities and their relationships discovered during incident investigation. It displays connections between users, hosts, IP addresses, files, and other entities to help analysts understand the scope of a threat.", "source": "investigation_graph"}
{"id": "sg_014", "domain": "sentinel_graph", "difficulty": "easy", "question": "What are automation rules in Microsoft Sentinel used for?", "ground_truth": "Automation rules automatically execute actions such as changing incident status, assigning ownership, or triggering playbooks based on alert and incident conditions, reducing manual response time.", "source": "automation_rules"}
{"id": "sg_015", "domain": "sentinel_graph", "difficulty": "easy", "question": "What is a workbook in Microsoft Sentinel?", "ground_truth": "A workbook is an interactive, customizable dashboard that visualizes security data and KQL query results through charts, tables, and other visualizations to support monitoring, investigation, and reporting.", "source": "workbooks"}
{"id": "sg_016", "domain": "sentinel_graph", "difficulty": "easy", "question": "Name the two main components of Microsoft Sentinel's core functionality.", "ground_truth": "The two main components are SIEM (Security Information and Event Management) for data collection and analysis, and SOAR (Security Orchestration, Automation, and Response) for automated incident response and remediation.", "source": "sentinel_overview"}
{"id": "sg_017", "domain": "sentinel_graph", "difficulty": "easy", "question": "What type of deployment model is Microsoft Sentinel?", "ground_truth": "Microsoft Sentinel is a cloud-native solution, meaning it is hosted and managed entirely in Azure, eliminating the need for on-premises infrastructure or hardware.", "source": "sentinel_overview"}
{"id": "sg_018", "domain": "sentinel_graph", "difficulty": "easy", "question": "Which Azure service stores the data indexed and queried by Microsoft Sentinel?", "ground_truth": "Azure Log Analytics stores all security data ingested into Microsoft Sentinel. KQL queries are run against Log Analytics workspaces to retrieve and analyze the data.", "source": "data_connectors"}
{"id": "sg_019", "domain": "sentinel_graph", "difficulty": "easy", "question": "What is the main advantage of using playbooks in Microsoft Sentinel?", "ground_truth": "Playbooks enable automated, consistent responses to security alerts without manual intervention, reducing response time and human error while allowing security teams to focus on complex investigations.", "source": "playbooks"}
{"id": "sg_020", "domain": "sentinel_graph", "difficulty": "easy", "question": "Which feature in Microsoft Sentinel helps identify suspicious behavior by analyzing patterns of user activity?", "ground_truth": "User and Entity Behavior Analytics (UEBA) identifies suspicious behavior by using machine learning to establish baselines of normal user and entity activity and detecting deviations from those baselines.", "source": "UEBA"}
{"id": "sg_021", "domain": "sentinel_graph", "difficulty": "medium", "question": "When writing a KQL query to detect suspicious sign-in attempts, how would you use the 'let' statement to improve query performance and readability, and what is a key consideration when referencing user identities across multiple tables?", "ground_truth": "The 'let' statement creates reusable variables that improve query efficiency by reducing redundant calculations. When referencing user identities across tables like SigninLogs and AuditLogs, you must account for different identifier formats (UPN vs. ObjectId) and ensure consistent normalization to enable accurate joins.", "source": "kql_optimization"}
{"id": "sg_022", "domain": "sentinel_graph", "difficulty": "medium", "question": "Explain the relationship between analytic rules and automation rules in Microsoft Sentinel, specifically when you would use automation rules to suppress alerts rather than modifying the analytic rule itself.", "ground_truth": "Analytic rules generate alerts based on query logic, while automation rules execute actions post-alert creation. Use automation rules for suppression when you want context-dependent filtering (e.g., suppress for certain users during maintenance windows) without altering the underlying detection logic, preserving audit trails and enabling dynamic adjustments.", "source": "analytic_and_automation_rules"}
{"id": "sg_023", "domain": "sentinel_graph", "difficulty": "medium", "question": "How do data connectors in Microsoft Sentinel handle API rate limiting and data ingestion delays, and what configuration option allows you to balance between real-time detection and connector reliability?", "ground_truth": "Data connectors manage rate limiting through exponential backoff and retry mechanisms. The 'polling frequency' or 'pull interval' setting balances real-time ingestion against connector stability; more frequent pulls increase latency risk, while less frequent pulls improve reliability but delay threat detection.", "source": "data_connectors"}
{"id": "sg_024", "domain": "sentinel_graph", "difficulty": "medium", "question": "When configuring entity mapping in an analytic rule, what determines which entity types should be mapped, and how does entity mapping influence incident creation and investigation workflows?", "ground_truth": "Entity mapping should include all observable identifiers in your detection logic (user, host, IP, URL, file hash). Entity mapping populates the incident's entity relationships, enabling the investigation graph to visualize connections and enriches UEBA scoring; unmapped entities reduce investigative context.", "source": "entity_mapping"}
{"id": "sg_025", "domain": "sentinel_graph", "difficulty": "medium", "question": "Describe how UEBA (User and Entity Behavior Analytics) scores are calculated and how you would use UEBA anomaly alerts in conjunction with traditional rule-based detections to reduce false positives.", "ground_truth": "UEBA scores are calculated using machine learning baselines from historical behavior patterns (login locations, resource access, data transfers). Combining UEBA anomaly alerts with rule-based detections allows you to alert only when both behavioral deviation and suspicious activities occur, significantly reducing false positives while maintaining detection coverage.", "source": "ueba"}
{"id": "sg_026", "domain": "sentinel_graph", "difficulty": "medium", "question": "What are the key differences between a Scheduled, NRT (Near Real-Time), and Anomaly D\u00e9tection analytic rule, and when would you choose each type based on your data ingestion patterns?", "ground_truth": "Scheduled rules run at fixed intervals and suit high-volume data; NRT rules execute within 1-2 minutes of data arrival for faster detection; Anomaly rules use ML baselines. Choose Scheduled for high-frequency logs, NRT for critical low-volume events requiring speed, and Anomaly for behavioral deviations.", "source": "analytic_rule_types"}
{"id": "sg_027", "domain": "sentinel_graph", "difficulty": "medium", "question": "How would you use a watchlist in Microsoft Sentinel to implement dynamic threat intelligence, and what are the performance considerations when querying large watchlists in KQL?", "ground_truth": "Watchlists store reference data (malicious IPs, known threat actors) that can be updated externally via CSV upload or API. Query watchlists using the `_GetWatchlistItem()` function. Performance consideration: join watchlist data early in your query and use exact-match operators rather than substring searches to minimize scan overhead.", "source": "watchlists"}
{"id": "sg_028", "domain": "sentinel_graph", "difficulty": "medium", "question": "Explain how playbooks (Logic Apps) in Microsoft Sentinel handle authentication to external services, and what configuration step is critical to ensure playbook actions execute with proper permissions.", "ground_truth": "Playbooks authenticate to external services using connectors with OAuth tokens or API keys stored in Key Vault. The critical step is configuring the Logic App's managed identity with appropriate Azure RBAC roles and granting connector permissions before deploying, ensuring runtime execution doesn't fail due to permission denials.", "source": "playbooks_logic_apps"}
{"id": "sg_029", "domain": "sentinel_graph", "difficulty": "medium", "question": "When designing a playbook to automatically respond to a security incident, what is the difference between using a synchronous (blocking) vs. asynchronous (non-blocking) automation trigger, and how does this choice affect incident handling?", "ground_truth": "Synchronous triggers (automated actions) block incident creation until playbook completes, risk timing out; asynchronous triggers start playbook after incident creation. Use async for long-running actions (API enrichment, notifications) to avoid incident delays, and sync for critical immediate actions requiring validation before incident propagation.", "source": "playbook_triggers"}
{"id": "sg_030", "domain": "sentinel_graph", "difficulty": "medium", "question": "What role does the Microsoft Graph Security API play in Microsoft Sentinel's broader threat intelligence ecosystem, and how would you use it to enrich alerts with cross-tenant security context?", "ground_truth": "The Microsoft Graph Security API provides unified access to security alerts, threat intelligence, and signals across Microsoft 365 services (Defender, Compliance, etc.). Use it in playbooks to query cross-tenant security events and enrichment data, creating correlated context unavailable from a single Sentinel workspace.", "source": "microsoft_graph_api"}
{"id": "sg_031", "domain": "sentinel_graph", "difficulty": "medium", "question": "How does the investigation graph in Microsoft Sentinel construct entity relationships, and what configuration in your analytic rules determines the depth and accuracy of the investigation graph?", "ground_truth": "The investigation graph builds relationships from entity mappings in alerts; each mapped entity (user, host, IP) becomes a node with edges representing logs containing multiple entities. Accurate, comprehensive entity mapping with all relevant identifiers (user account, device name, source IP) creates deeper, more actionable investigation graphs.", "source": "investigation_graph"}
{"id": "sg_032", "domain": "sentinel_graph", "difficulty": "medium", "question": "Explain how to use KQL time-series functions (like `make_series` and `series_decompose`) to detect anomalous security event volumes, and what metric would you monitor to distinguish DDoS from legitimate traffic spikes?", "ground_truth": "`make_series` aggregates events into time buckets; `series_decompose` separates trend from anomalies. Monitor request patterns (volume, source IP diversity, payload sizes) over time\u2014DDoS shows uniform source/payload variation, while legitimate spikes show diverse sources and normal payload distribution.", "source": "kql_time_series"}
{"id": "sg_033", "domain": "sentinel_graph", "difficulty": "medium", "question": "When deploying a custom content solution from the Content Hub, what are the dependencies you must validate, and how would you test the solution in a non-production workspace before deploying to production?", "ground_truth": "Validate dependencies: required data connectors are enabled, tables are populated, user roles have sufficient permissions, and parameter values match your environment. Test in non-prod by verifying analytic rules trigger correctly, playbooks execute end-to-end, and workbooks display data without errors before production deployment.", "source": "content_hub"}
{"id": "sg_034", "domain": "sentinel_graph", "difficulty": "medium", "question": "What KQL aggregation strategy would you use to efficiently detect privilege escalation attempts across thousands of hosts, and how would you handle the challenge of correlating local and domain admin accounts with different naming conventions?", "ground_truth": "Use `summarize` with `arg_max()` to extract latest privilege changes per account, then `join` with a mapping watchlist that normalizes account naming conventions. Filter by sensitive groups post-normalization and aggregate failures-to-success within time windows to detect escalation patterns efficiently.", "source": "kql_aggregation"}
{"id": "sg_035", "domain": "sentinel_graph", "difficulty": "medium", "question": "How would you configure a workbook to display incident trends over time while allowing interactive filtering by severity and status, and what embedded KQL consideration ensures the workbook remains performant with large datasets?", "ground_truth": "Use time-series charts with KQL queries grouped by severity/status, add parameters for date range filtering. For performance, aggregate data at appropriate granularity (hourly/daily), use `| top` to limit result rows, and pre-filter by workspace time range to minimize table scans.", "source": "workbooks"}
{"id": "sg_036", "domain": "sentinel_graph", "difficulty": "medium", "question": "Describe the threat hunting workflow in Microsoft Sentinel: how would you use the investigation graph to pivot from an initial indicator of compromise (IoC) to discovering related incidents and compromised assets?", "ground_truth": "Start with an IoC (malicious IP) in the investigation graph; expand entity relationships to identify connecting hosts/users. Follow edges to related incidents, examine playback timelines, and pivot through correlated logs to identify additional compromised assets and the attack progression.", "source": "threat_hunting"}
{"id": "sg_037", "domain": "sentinel_graph", "difficulty": "medium", "question": "What is the difference between incident severity as calculated by Sentinel's automatic rules versus manually set severity, and in what scenario would you override automated severity assessment?", "ground_truth": "Automatic severity (based on alert severity and rule logic) provides baseline consistency; manual override captures business context (e.g., critical user compromised, sensitive data accessed). Override when automated assessment misses organizational risk (executive accounts, compliance-regulated systems).", "source": "incident_severity"}
{"id": "sg_038", "domain": "sentinel_graph", "difficulty": "medium", "question": "How does KQL's `externaldata` operator enable threat hunting using external threat intelligence feeds, and what data format and connection method would you use to securely reference a continuously updated malware hash list?", "ground_truth": "`externaldata` imports external data (CSV, JSON) from Azure Blob Storage or HTTP endpoint. Store malware hashes in an Azure Storage account with SAS token in KQL; refresh periodically. This allows joining logs against current threat intel without manual watchlist updates.", "source": "kql_externaldata"}
{"id": "sg_039", "domain": "sentinel_graph", "difficulty": "medium", "question": "When configuring automation rules to assign incidents to specific teams, what field mapping would ensure incidents are routed to the correct on-call analyst, and how would you handle timezone differences for SLA escalation?", "ground_truth": "Use the 'assign to owner' condition to match incident ownership by team/user; map using custom entity (user department/group). For timezone-aware SLA escalation, configure automation rules with time-based conditions referencing UTC timestamps, or use playbooks with timezone-aware escalation logic.", "source": "automation_rule_assignment"}
{"id": "sg_040", "question": "Explain how you would design a KQL-based anomaly detection rule to identify data exfiltration attempts by correlating unusual file access patterns with outbound network connections, and what false-positive filtering technique would you apply?", "ground_truth": "Correlate FileAccess events (rapid access to multiple sensitive files) with OutboundNetworkEvents to high-risk destinations using `join` on user/host. Filter false positives by excluding known legitimate bulk operations (backups, syncing) via watchlist, and require sustained pattern (multiple files + multiple connections within time window).", "source": "kql_exfiltration_detection", "difficulty": "medium", "domain": "sentinel_graph"}
{"id": "sg_041", "domain": "sentinel_graph", "difficulty": "hard", "question": "When writing a KQL query for threat hunting in Sentinel, what are the performance implications of using dynamic property accessors (bracket notation) versus strongly-typed columns when querying entities with hundreds of custom fields, and how does this impact query execution time on multi-terabyte datasets?", "ground_truth": "Dynamic property accessors (e.g., dynamic_field['property']) incur higher CPU overhead than strongly-typed columns because the query engine must resolve field names at runtime. On large datasets, this can increase execution time by 2-5x. Best practice is to use mv-expand with dynamic_to_json or pre-normalize schema when possible, and leverage materialized views for frequently-queried custom fields.", "source": "KQL_performance_optimization"}
{"id": "sg_042", "domain": "sentinel_graph", "difficulty": "hard", "question": "In Sentinel's entity mapping during incident creation, what is the correct precedence order when multiple analytic rules assign conflicting threat intelligence enrichments (TI indicators) to the same entity, and how does this affect investigation graph traversal?", "ground_truth": "Entity enrichment precedence follows: (1) most recent enrichment timestamp, (2) highest confidence TI source (as configured in data connector settings), (3) broadest scope indicator (domain > IP > file hash). Conflicting enrichments do not overwrite but instead create multiple entity instances in the investigation graph, allowing analysts to traverse all threat contexts simultaneously.", "source": "entity_mapping_enrichment_conflicts"}
{"id": "sg_043", "domain": "sentinel_graph", "difficulty": "hard", "question": "When configuring a playbook (Logic App) to auto-remediate incidents in Sentinel, what are the critical gotchas when using managed identity versus service principal authentication with Microsoft Graph Security API calls, particularly regarding scope expansion and token refresh intervals?", "ground_truth": "Managed identities require pre-defined Azure RBAC roles and cannot dynamically request new Graph API permissions; service principals require explicit app registration but allow fine-grained permission control via application permissions. Token refresh happens automatically but playbooks can experience 30-60 second latency if cached tokens expire mid-execution. Critical: managed identities fail silently if RBAC lacks required Graph API permissions, while service principals throw explicit auth errors.", "source": "playbook_authentication_patterns"}
{"id": "sg_044", "domain": "sentinel_graph", "difficulty": "hard", "question": "How does Sentinel's UEBA (User and Entity Behavior Analytics) baseline calculation handle sparse data scenarios (users with <10 daily sign-ins or entities with irregular activity patterns), and what are the implications for false-positive rates in anomaly detection rules?", "ground_truth": "UEBA baselines require minimum 14 days of historical data with sufficient activity density; for sparse entities, ML models fall back to peer-group baselines comparing against similar user/entity cohorts. Sparse entities typically see 3-7x higher false-positive rates. Mitigation: tune anomaly thresholds per entity type, increase lookback windows to 30-60 days, or exclude low-activity entities using watchlists.", "source": "UEBA_sparse_data_handling"}
{"id": "sg_045", "domain": "sentinel_graph", "difficulty": "hard", "question": "In an automation rule chain where multiple rules reference the same incident, under what conditions can duplicate or orphaned playbook executions occur, and how should you design idempotent playbooks to handle this scenario?", "ground_truth": "Duplicate executions occur when automation rules trigger on the same incident change event (e.g., severity update) if rules are not mutually exclusive via conditions. Orphaned executions happen if an earlier rule closes the incident while a subsequent rule still executes. Design idempotency via: (1) check incident status at playbook start and exit gracefully if closed, (2) store execution metadata in incident comments using unique identifiers, (3) use 'Run After' conditions in Logic Apps to enforce sequential execution.", "source": "automation_rule_execution_guarantees"}
{"id": "sg_046", "domain": "sentinel_graph", "difficulty": "hard", "question": "When designing watchlists in Sentinel for real-time threat intelligence correlation, what are the performance trade-offs between storing data as CSV imports versus external graph API lookups, and how does this impact analytic rule compilation and execution latency?", "ground_truth": "CSV-based watchlists offer <10ms lookup latency but require manual updates; external Graph API lookups enable real-time data but incur 200-500ms latency per query and consume API throttle quotas. For high-volume rules (1M+ events/hour), CSV watchlists are mandatory. Hybrid approach: cache Graph API data into watchlists via Logic App scheduled tasks (hourly) to balance freshness and performance.", "source": "watchlist_performance_architecture"}
{"id": "sg_047", "domain": "sentinel_graph", "difficulty": "hard", "question": "How should you configure data connectors to handle latency skew (where event ingestion timestamp differs significantly from event occurrence timestamp), and what are the consequences for time-based KQL queries and analytic rule windows?", "ground_truth": "Configure connectors to map both ingestion_time_utc and event_time_utc fields. Time-based rules should use event_time_utc for lookback windows to avoid missing late-arriving events. Latency skew >24 hours can cause missed detections if rules only use TimeGenerated. Best practice: add 'allow latency buffer' in analytic rules by extending lookback window by 1.5x expected connector SLA, then deduplicate results.", "source": "data_connector_timestamp_handling"}
{"id": "sg_048", "domain": "sentinel_graph", "difficulty": "hard", "question": "In the investigation graph, what is the maximum degrees of separation Sentinel will traverse by default, and how does enabling expansive entity relationships (via Content Hub threat intelligence packs) affect graph rendering performance and incident investigation time?", "ground_truth": "Default traversal is 3 degrees of separation; enabling advanced TI packs can expand this to 5-6 degrees. Each additional degree multiplies potential entity connections by 2-10x depending on data density. On large networks with dense relationships, graphs can render 30-60 seconds slower. Mitigation: set manual expansion limits in investigation settings, use 'pivot to entity' for targeted exploration, or enable 'compact mode' to hide transitive relationships.", "source": "investigation_graph_traversal"}
{"id": "sg_049", "domain": "sentinel_graph", "difficulty": "hard", "question": "When configuring content hub integration with custom analytic rule templates, what validation and security controls should be implemented to prevent malicious KQL injection or privilege escalation through adversary-controlled rule parameters?", "ground_truth": "Implement strict parameter validation: (1) use parameter placeholders (@param syntax) rather than string concatenation in KQL, (2) enforce allowlist of valid regex patterns for dynamic values, (3) test rules in isolated workspace before promotion to production, (4) audit rule modifications via Azure Activity Log, (5) require approval workflow for rules accepting external input. Never allow user input in table names or command operators.", "source": "content_hub_security_validation"}
{"id": "sg_050", "domain": "sentinel_graph", "difficulty": "hard", "question": "How does Sentinel handle incident correlation when multiple analytic rules fire within seconds of each other on the same entity, and what are the architectural constraints that prevent or enable grouping these into a single incident?", "ground_truth": "Sentinel uses a 5-minute aggregation window and entity matching (Account, Host, IP, URL, etc.) to group related alerts into single incidents. If rules have non-overlapping entity types or fire outside the window, separate incidents are created. Correlation strength depends on entity overlap; identical entities = high correlation. Limitation: rules with weak entity mappings (only 'Custom Entity' type) may not correlate. Design rule entities carefully to enable proper grouping.", "source": "incident_correlation_aggregation"}
{"id": "sg_051", "domain": "sentinel_graph", "difficulty": "hard", "question": "When migrating from a legacy SIEM to Sentinel, what are the critical data normalization challenges when mapping heterogeneous log sources to Sentinel's Advanced Security Information Model (ASIM), and how do schema mismatches impact downstream threat hunting and compliance queries?", "ground_truth": "ASIM normalization requires mapping source-specific fields to canonical columns (e.g., user ID -> TargetUsername, event code -> EventType). Partial mappings leave fields unpopulated, breaking downstream KQL queries that assume field presence. Compliance queries may fail if timestamp precision differs (milliseconds vs. seconds). Mitigation: implement KQL helper functions using parse operators for legacy sources, create data normalization watchlists for field value transformations, and test all downstream rules before cutover.", "source": "ASIM_schema_migration"}
