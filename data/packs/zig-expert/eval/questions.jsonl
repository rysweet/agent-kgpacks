{"id": "ze_001", "domain": "zig_expert", "difficulty": "easy", "question": "What is the primary purpose of the `comptime` keyword in Zig?", "ground_truth": "The `comptime` keyword forces code execution at compile-time rather than runtime, enabling metaprogramming, compile-time code generation, and generic type computation.", "source": "comptime_metaprogramming"}
{"id": "ze_002", "domain": "zig_expert", "difficulty": "easy", "question": "In Zig, what does an error union type look like, and what operator is used to denote it?", "ground_truth": "An error union is denoted using the `!` operator, for example `!MyErrorSet` or `MyErrorSet!ReturnType`, indicating a value that can be either an error or a successful result.", "source": "error_unions"}
{"id": "ze_003", "domain": "zig_expert", "difficulty": "easy", "question": "What is the `errdefer` statement used for in Zig error handling?", "ground_truth": "`errdefer` defers execution of a statement until the current scope exits with an error, allowing cleanup code to run only when an error occurs.", "source": "error_handling"}
{"id": "ze_004", "domain": "zig_expert", "difficulty": "easy", "question": "What is the explicit allocator pattern in Zig, and why is it important?", "ground_truth": "The explicit allocator pattern requires functions to accept an allocator parameter rather than using a global one, giving callers full control over memory management and enabling predictable resource usage.", "source": "explicit_allocator_pattern"}
{"id": "ze_005", "domain": "zig_expert", "difficulty": "easy", "question": "Name three allocator types provided by Zig's standard library.", "ground_truth": "Three common allocators are `ArenaAllocator` (groups allocations together), `FixedBufferAllocator` (allocates from a fixed buffer), and `page_allocator` (system page-based allocator).", "source": "allocator_types"}
{"id": "ze_006", "domain": "zig_expert", "difficulty": "easy", "question": "What file contains build configuration and compilation rules in a Zig project?", "ground_truth": "The `build.zig` file contains the build configuration, defining how the project should be compiled, dependencies, executable targets, and build steps.", "source": "build_system"}
{"id": "ze_007", "domain": "zig_expert", "difficulty": "easy", "question": "What is an optional type in Zig, and how is it denoted?", "ground_truth": "An optional type is denoted with the `?` prefix (e.g., `?i32`), representing a value that can be either null or of the specified type.", "source": "optionals"}
{"id": "ze_008", "domain": "zig_expert", "difficulty": "easy", "question": "What does payload capture do in Zig when unwrapping optionals or error unions?", "ground_truth": "Payload capture extracts the underlying value from an optional or error union using syntax like `if (optional_value) |value|`, binding the unwrapped value to a variable in the conditional block.", "source": "payload_captures"}
{"id": "ze_009", "domain": "zig_expert", "difficulty": "easy", "question": "What is a slice in Zig, and how does it differ from an array?", "ground_truth": "A slice is a pointer-and-length pair to a contiguous sequence of elements, denoted `[]T`, whereas an array is a fixed-size collection. Slices are dynamically sized views into data.", "source": "slices"}
{"id": "ze_010", "domain": "zig_expert", "difficulty": "easy", "question": "What is a packed struct in Zig, and what does the `packed` keyword achieve?", "ground_truth": "A `packed struct` uses the `packed` keyword to eliminate padding and guarantee a specific memory layout where fields are densely packed, useful for low-level binary formats.", "source": "packed_structs"}
{"id": "ze_011", "domain": "zig_expert", "difficulty": "easy", "question": "What is `@typeInfo` reflection in Zig used for?", "ground_truth": "`@typeInfo` is a built-in function that returns compile-time information about a type's structure, allowing generic code to inspect and adapt based on type properties.", "source": "typeInfo_reflection"}
{"id": "ze_012", "domain": "zig_expert", "difficulty": "easy", "question": "How does Zig import C code, and what built-in function is used for this?", "ground_truth": "Zig uses the `@cImport` built-in function to import C headers and code, translating C declarations into Zig equivalents automatically.", "source": "C_interoperability"}
{"id": "ze_013", "domain": "zig_expert", "difficulty": "easy", "question": "What is a labeled block in Zig, and what keyword introduces it?", "ground_truth": "A labeled block is introduced with a label name followed by `:` (e.g., `outer: {}`), allowing `break` and `continue` statements to target specific nested blocks.", "source": "labeled_blocks"}
{"id": "ze_014", "domain": "zig_expert", "difficulty": "easy", "question": "What are sentinel-terminated types in Zig?", "ground_truth": "Sentinel-terminated types are arrays or slices with a known sentinel value at the end (e.g., null-terminated strings), denoted with `:sentinel` syntax like `[:0]u8` for null-terminated strings.", "source": "sentinel_terminated_types"}
{"id": "ze_015", "domain": "zig_expert", "difficulty": "easy", "question": "What is undefined behavior (UB) in Zig, and what safety feature helps detect it?", "ground_truth": "Undefined behavior is code whose result is unpredictable; Zig's safety features and debug mode runtime checks help detect and prevent UB like out-of-bounds access and integer overflow.", "source": "safety_features"}
{"id": "ze_016", "domain": "zig_expert", "difficulty": "easy", "question": "What does the `ArenaAllocator` do, and what is its primary use case?", "ground_truth": "An `ArenaAllocator` groups multiple allocations and deallocates them all at once when the arena is freed, making it efficient for workloads requiring many temporary allocations.", "source": "arena_allocator"}
{"id": "ze_017", "domain": "zig_expert", "difficulty": "easy", "question": "What is the `page_allocator` in Zig's standard library?", "ground_truth": "The `page_allocator` is a simple allocator that requests memory directly from the operating system in page-sized chunks, typically used for testing or cases requiring minimal overhead.", "source": "page_allocator"}
{"id": "ze_018", "domain": "zig_expert", "difficulty": "easy", "question": "What is cross-compilation support in Zig, and how is it specified in build.zig?", "ground_truth": "Cross-compilation allows building for different target architectures and operating systems; in `build.zig` it is specified using target parameters like `target = b.standardTargetOptions()` or explicit target definitions.", "source": "cross_compilation"}
{"id": "ze_019", "domain": "zig_expert", "difficulty": "easy", "question": "What is `GeneralPurposeAllocator` in Zig's standard library, and how do you detect memory leaks with it?", "ground_truth": "`GeneralPurposeAllocator` is a safety-focused allocator that detects memory leaks, double frees, and use-after-free bugs at runtime. After use, call `deinit()` on it: if it returns `.leak`, memory was allocated but not freed. It is typically used in debug builds. Example: `var gpa = std.heap.GeneralPurposeAllocator(.{}){}; defer _ = gpa.deinit();`", "source": "general_purpose_allocator"}
{"id": "ze_020", "domain": "zig_expert", "difficulty": "easy", "question": "What is `FixedBufferAllocator` and what constraint does it have?", "ground_truth": "A `FixedBufferAllocator` allocates memory from a pre-allocated fixed buffer and cannot grow beyond its size, making it suitable for embedded systems or when the maximum memory requirement is known.", "source": "fixed_buffer_allocator"}
{"id": "ze_021", "domain": "zig_expert", "difficulty": "medium", "question": "When using @typeInfo for comptime introspection, what information does the .Struct field provide that allows you to conditionally generate different code paths for generic types?", "ground_truth": "@typeInfo on a struct type returns fields, decls, and layout information (packed, extern, etc.), allowing comptime code to iterate over field names, types, and attributes to generate specialized implementations based on the actual struct definition.", "source": "comptime_reflection_typeinfo"}
{"id": "ze_022", "domain": "zig_expert", "difficulty": "medium", "question": "Explain the key difference between ArenaAllocator and FixedBufferAllocator in terms of memory management strategy and when you would choose one over the other.", "ground_truth": "ArenaAllocator allocates from a backing allocator and deallocates all at once via deinit(), suitable for scoped lifetimes; FixedBufferAllocator uses a pre-allocated buffer with no backing allocator, ideal for deterministic embedded or no-alloc scenarios where the total size is known.", "source": "allocator_pattern_comparison"}
{"id": "ze_023", "domain": "zig_expert", "difficulty": "medium", "question": "In the context of error unions, what is the purpose of errdefer and how does it differ from defer in terms of when the deferred block executes?", "ground_truth": "errdefer executes only when the function returns an error (via try or explicit return), while defer always executes on scope exit; errdefer is commonly used to clean up partial state when an error occurs, preventing resource leaks in error paths.", "source": "error_handling_errdefer"}
{"id": "ze_024", "domain": "zig_expert", "difficulty": "medium", "question": "What does @cImport do and what are the safety considerations when importing C headers into Zig, particularly regarding undefined behavior from C code?", "ground_truth": "@cImport translates C headers into Zig types and functions at comptime, but C code may invoke undefined behavior that Zig's safety checks cannot catch; you must audit C semantics and may need unsafe blocks (@ptrCast, @intCast) to bridge incompatibilities.", "source": "c_interop_cimport"}
{"id": "ze_025", "domain": "zig_expert", "difficulty": "medium", "question": "How does the explicit allocator pattern in Zig improve code maintainability and testability compared to implicit global allocation?", "ground_truth": "By passing allocators as parameters, code becomes allocation-agnostic and testable with different allocator implementations (ArenaAllocator, FixedBufferAllocator, testing.allocator); this enables dependency injection and makes memory usage explicit and configurable.", "source": "allocator_pattern_explicit"}
{"id": "ze_026", "domain": "zig_expert", "difficulty": "medium", "question": "When using payload captures with error unions (e.g., if (x) |value| { ... }), what happens to the error value and how would you capture it instead?", "ground_truth": "Payload capture syntax captures the success value; to capture the error, use if (x) |value| { ... } else |err| { ... }, where the else branch receives the error payload; alternatively, use try or catch to handle errors differently.", "source": "error_union_payload_capture"}
{"id": "ze_027", "domain": "zig_expert", "difficulty": "medium", "question": "What is a sentinel-terminated type in Zig and provide an example of how it differs from a regular slice in terms of runtime guarantees.", "ground_truth": "A sentinel-terminated type (e.g., [:0]const u8 for null-terminated strings) includes a sentinel value at the end that is guaranteed to be present, allowing C-interop and safe iteration; regular slices lack this guarantee and require explicit length tracking.", "source": "sentinel_terminated_types"}
{"id": "ze_028", "domain": "zig_expert", "difficulty": "medium", "question": "In build.zig, how do you configure cross-compilation targets and what role does the target triple (or resolved target) play in the build process?", "ground_truth": "You set the target via b.standardTargetOptions() or explicit target specifications; the target triple determines CPU arch, OS, and ABI, which controls which libraries are linked, compiler flags applied, and which runtime behaviors are enabled during compilation.", "source": "build_system_cross_compilation"}
{"id": "ze_029", "domain": "zig_expert", "difficulty": "medium", "question": "What is a labeled block in Zig and how can it be used to implement early exit or complex control flow that is clearer than alternatives?", "ground_truth": "A labeled block (blk: { ... }) allows you to break out of nested loops or blocks directly with break :blk value, providing a clean way to exit from deeply nested structures without extra variables or flags, improving readability and eliminating control flow nesting.", "source": "labeled_blocks_control_flow"}
{"id": "ze_030", "domain": "zig_expert", "difficulty": "medium", "question": "Explain how comptime generics differ from runtime generics and provide an example of a situation where comptime specialization improves performance.", "ground_truth": "Comptime generics instantiate code at compile time for each type, eliminating runtime polymorphism overhead; for example, a comptime vector dot product can unroll loops and specialize for specific vector lengths, whereas runtime generics require dynamic dispatch or branching.", "source": "comptime_generics_specialization"}
{"id": "ze_031", "domain": "zig_expert", "difficulty": "medium", "question": "What undefined behavior checks does Zig provide by default, and how do they differ between safe and unsafe build modes?", "ground_truth": "Zig checks for undefined behavior (bounds, overflow, null dereference, etc.) in Debug and ReleaseSafe modes; ReleaseFast and ReleaseSmall disable these checks for performance; you can selectively use @setRuntimeSafety(bool) or unsafe blocks to override.", "source": "safety_features_undefined_behavior"}
{"id": "ze_032", "domain": "zig_expert", "difficulty": "medium", "question": "How does page_allocator differ from general-purpose allocators like ArenaAllocator, and in what scenarios would you use it directly?", "ground_truth": "page_allocator allocates memory in OS page-sized chunks with no deallocation, suitable for long-lived allocations where fragmentation is not a concern; it is typically used as a backing allocator for ArenaAllocator or for simple, one-shot allocations in tools or scripts.", "source": "page_allocator_usage"}
{"id": "ze_033", "domain": "zig_expert", "difficulty": "medium", "question": "When using packed structs, what memory layout guarantees does Zig provide and what are the performance implications of field access?", "ground_truth": "Packed structs have bit-level packing with no padding, guaranteeing a compact memory layout; however, accessing non-byte-aligned fields may require bit masking and shifting, making them slower than unpacked structs but essential for binary protocols and low-level data structures.", "source": "packed_structs_memory_layout"}
{"id": "ze_034", "domain": "zig_expert", "difficulty": "medium", "question": "How do optionals work in Zig and how do you handle the null case safely using payload capture or explicit checks?", "ground_truth": "An optional type (e.g., ?T) can be null or hold a value of type T; use if (opt) |value| { ... } for safe payload capture, or opt orelse defaultValue for default handling; attempting to use an optional as its base type without unwrapping is a compile error.", "source": "optionals_null_handling"}
{"id": "ze_035", "domain": "zig_expert", "difficulty": "medium", "question": "Describe the role of build.zig in controlling compilation: what build options, steps, and dependencies can you configure there?", "ground_truth": "build.zig is a Zig program that runs at build time; it configures compilation options, defines build steps (compile, run tests, install), manages dependencies, sets optimization levels, and generates build artifacts; it provides full programmatic control over the build process.", "source": "build_system_build_zig"}
{"id": "ze_036", "domain": "zig_expert", "difficulty": "medium", "question": "What is the relationship between slices and array pointers in Zig, and when would you use a slice over a pointer to an array?", "ground_truth": "A slice is a fat pointer (pointer + length) providing bounds safety, while an array pointer (*[N]T) includes fixed size; use slices for variable-length sequences and safety, array pointers when size is known and you need direct pointer semantics.", "source": "slices_array_pointers"}
{"id": "ze_037", "domain": "zig_expert", "difficulty": "medium", "question": "How can you use comptime to generate different serialization code for various struct types, and what @typeInfo introspection would you rely on?", "ground_truth": "@typeInfo on structs provides .fields array with name, type, and default values; you iterate over fields at comptime to generate encoding/decoding logic per type, allowing zero-overhead serialization that is both generic and specialized for each struct.", "source": "comptime_code_generation_serialization"}
{"id": "ze_038", "domain": "zig_expert", "difficulty": "medium", "question": "What are the key differences between error sets (error!T) and exceptions in other languages, and how does Zig's approach affect control flow?", "ground_truth": "Error sets are explicit type annotations that enumerate possible errors; they are not exceptions (no unwinding), so control flow is explicit via try/catch/errdefer; this makes error paths visible at compile time and easier to audit, but requires conscious error propagation.", "source": "error_unions_vs_exceptions"}
{"id": "ze_039", "domain": "zig_expert", "difficulty": "medium", "question": "How does the standard library's allocator interface enable composability, and what methods must all allocators implement?", "ground_truth": "All allocators implement alloc(), free(), and resize() methods on a Allocator interface; this enables wrapping allocators (ArenaAllocator wrapping page_allocator), mixing strategies, and testing with instrumented allocators, providing high flexibility without coupling.", "source": "stdlib_allocator_interface"}
{"id": "ze_040", "domain": "zig_expert", "difficulty": "medium", "question": "In Zig 0.13+, how do you add an external package dependency and import its module in your executable via `build.zig`?", "ground_truth": "Use `b.dependency(\"pkg_name\", .{ .target = target, .optimize = optimize })` to fetch the dependency declared in `build.zig.zon`, then call `.module(\"module_name\")` on the result to get the module. Add it to your executable with `exe.root_module.addImport(\"alias\", module)`. The older `addPackage` function was removed in Zig 0.12 in favor of this module-based API.", "source": "build_system_dependencies_0_13"}
{"id": "ze_041", "domain": "zig_expert", "difficulty": "hard", "question": "When using @typeInfo for comptime reflection on a struct containing optional fields, how would you distinguish between a null default value and an uninitialized optional, and what are the performance implications of using this reflection pattern in a generic allocator wrapper?", "ground_truth": "You cannot distinguish null defaults from uninitialized optionals via @typeInfo alone\u2014@typeInfo only reveals type structure, not runtime values. The performance implication is that reflection-based generic wrappers introduce comptime overhead but generate zero-cost abstractions at runtime since all decisions are resolved during compilation; however, excessive use can increase binary size and compile time significantly.", "source": "comptime_reflection_optionals"}
{"id": "ze_042", "domain": "zig_expert", "difficulty": "hard", "question": "Explain the interaction between errdefer and labeled blocks when handling nested error conditions, particularly when you need to unwind multiple allocators (e.g., ArenaAllocator wrapping a page_allocator). What happens to deferred cleanup if an error is captured via payload in an inner block?", "ground_truth": "errdefer executes when exiting a block via error return; if you use labeled blocks with payload capture, the errdefer for the inner block still executes before control transfers to the outer handler. When unwinding with nested allocators, each level's errdefer must properly call deinit() in reverse order; payload capture doesn't prevent errdefer execution\u2014it only determines which block receives control flow.", "source": "errdefer_labeled_blocks_unwinding"}
{"id": "ze_043", "domain": "zig_expert", "difficulty": "hard", "question": "In a build.zig system, how would you structure cross-compilation targets for both WASM and native x86_64 while ensuring that comptime code execution respects the build host's architecture, and what are the subtle differences in how @import and @cImport behave across targets?", "ground_truth": "@import resolves at compile-time on the host; cross-compilation doesn't change its behavior. @cImport is target-aware and uses the target's C ABI, so the same C header may generate different bindings for WASM vs x86_64. In build.zig, you must explicitly set exe.target for each target and ensure comptime functions don't assume host architecture; host-dependent comptime code must be isolated or feature-gated using builtin.target checks.", "source": "build_system_cross_compilation"}
{"id": "ze_044", "domain": "zig_expert", "difficulty": "hard", "question": "Design a generic error union handler that uses comptime introspection to automatically generate error payload destructuring for any error set, while maintaining type safety. What edge cases arise when error sets contain overlapping error types from different modules?", "ground_truth": "Use @typeInfo(ErrorType).ErrorSet to enumerate errors at comptime and generate match cases via inline loops. Edge cases: error sets from different modules can have identically-named errors that are distinct types; @typeInfo reveals only the error names, not their originating modules, so you must manually namespace or use fully-qualified names. Overlaps cause compilation errors unless explicitly handled via type coercion or separate branches.", "source": "comptime_error_union_generics"}
{"id": "ze_045", "domain": "zig_expert", "difficulty": "hard", "question": "Given a FixedBufferAllocator with a sentinel-terminated slice as its backing buffer, explain the memory safety guarantees and potential undefined behavior risks if the buffer is exhausted. How does this differ from using a page_allocator in terms of bounds checking and security?", "ground_truth": "FixedBufferAllocator with a sentinel-terminated buffer still has a fixed capacity; exhaustion causes out-of-memory errors (safe), but the sentinel only guarantees a null terminator for the slice itself, not for allocations within it. page_allocator backs with OS pages and handles overflow via OS-level protection (safer). Undefined behavior in FixedBufferAllocator occurs if you over-allocate or corrupt the backing slice's metadata; page_allocator prevents this via hardware MMU boundaries.", "source": "fixed_buffer_allocator_safety"}
{"id": "ze_046", "domain": "zig_expert", "difficulty": "hard", "question": "When using @cImport to bind to a C library with opaque types, how do you safely implement a wrapper that maintains Zig's ownership semantics while delegating to C functions? What are the pitfalls of mixing ArenaAllocator lifetimes with C-managed memory?", "ground_truth": "Wrap opaque C types in Zig structs with explicit deinit() methods that call corresponding C free functions; use errdefer to guarantee cleanup even on error. The pitfall is lifetime mismatch: ArenaAllocator deinit() frees all allocations at once, but C functions may expect per-object cleanup; mixing them risks double-free or use-after-free. Use a single allocator strategy: either all Zig-managed or all C-managed, with explicit translation boundaries.", "source": "cinterop_opaque_types_allocators"}
{"id": "ze_047", "domain": "zig_expert", "difficulty": "hard", "question": "Explain how packed structs interact with @typeInfo and what undefined behavior can occur if you rely on @sizeOf or @offsetOf for packed structs that contain comptime-conditionally-included fields. How should you validate this in a build.zig test step?", "ground_truth": "@typeInfo works on packed structs but fields are bit-packed, so @offsetOf returns bit offsets, not byte offsets\u2014caller must account for this. Comptime-conditionally-included fields via if (comptime condition) fields are fully excluded from @typeInfo, so @sizeOf changes accordingly. Undefined behavior occurs if you assume a fixed layout across conditions. Validate in build.zig with test steps that assert @sizeOf against expected bytes for all compile-time paths.", "source": "packed_structs_comptime_conditionals"}
{"id": "ze_048", "domain": "zig_expert", "difficulty": "hard", "question": "How do `comptime` interfaces work in Zig using `anytype` parameters, and how does compile-time duck typing differ from runtime polymorphism in terms of generated code and performance?", "ground_truth": "Zig uses `anytype` parameters for compile-time duck typing: a function accepting `anytype` is instantiated for each concrete type passed at call sites. The compiler checks at instantiation time that the type provides the required fields or methods (duck typing). Unlike runtime polymorphism (vtable dispatch), no virtual call overhead exists â€” the compiler generates fully specialized, inlineable code per concrete type. Use `@TypeOf(param)` and `@typeInfo` to introspect the type inside the function for further specialization.", "source": "comptime_anytype_interfaces"}
{"id": "ze_049", "domain": "zig_expert", "difficulty": "hard", "question": "Design a comptime generic function that uses @typeInfo and recursion to flatten a deeply nested error union type (e.g., error union of error unions) into a single flat error set. What are the compile-time performance costs and potential infinite recursion hazards?", "ground_truth": "Recurse on payloads: if the payload is itself an error union, extract its error set and union with the current level's errors; terminate when payload is non-error-union. Performance cost is O(depth) comptime work and binary size bloat for error set merging. Infinite recursion occurs if error unions are self-referential (rare but possible via opaque types or forward declarations); guard with a visited-types set using a comptime HashMap or by limiting recursion depth.", "source": "comptime_recursive_error_flattening"}
{"id": "ze_050", "domain": "zig_expert", "difficulty": "hard", "question": "When cross-compiling with build.zig, if a comptime function calls a C function via @cImport, on which target (host or cross-compile target) does that C function execute, and what safety issues arise if the C function has target-specific side effects or assumptions?", "ground_truth": "Comptime C functions via @cImport execute on the build host using host C ABIs; they do NOT execute on the cross-compile target. Safety issues: if the C function assumes target architecture (e.g., reading /proc/cpuinfo on Linux), it reflects the build host, not the target\u2014this can silently produce wrong comptime values. Avoid target-dependent logic in comptime @cImport calls; isolate target-specific C bindings to runtime-only code paths.", "source": "cimport_comptime_cross_compilation"}
