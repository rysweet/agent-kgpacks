{"id": "re_001", "domain": "react_expert", "difficulty": "easy", "question": "What does the `\"use client\"` directive do in React 19, and where must it appear?", "ground_truth": "Adding `\"use client\"` at the top of a file marks all components exported from it as Client Components. This creates a Server-to-Client boundary: Client Components can use browser APIs, state hooks, and event handlers, while the directive must be the very first statement in the file before any imports.", "source": "client_components_directive"}
{"id": "re_002", "domain": "react_expert", "difficulty": "easy", "question": "What is the `\"use server\"` directive used for in React 19?", "ground_truth": "`\"use server\"` marks async functions as Server Actions — functions that execute exclusively on the server and can be called from Client Components or HTML form `action` props. They enable secure server-side mutations (database writes, API calls) without creating explicit REST endpoints.", "source": "server_actions_directive"}
{"id": "re_003", "domain": "react_expert", "difficulty": "easy", "question": "What does the `use()` hook in React 19 allow you to do inside a component, and what makes it unique among React hooks?", "ground_truth": "The `use()` hook reads the value of a Promise or Context during render. For Promises, it integrates with Suspense: if the Promise is pending, the component suspends until resolved. Unlike all other React hooks, `use()` can be called conditionally (inside `if` statements or loops), making it more flexible for dynamic data fetching patterns.", "source": "use_hook"}
{"id": "re_004", "domain": "react_expert", "difficulty": "easy", "question": "What is `useFormStatus` in React 19 and what object does it return?", "ground_truth": "`useFormStatus` is a hook that reads the submission status of the nearest parent `<form>`. It returns `{ pending, data, method, action }` where `pending` is `true` while the form action is executing. It must be used inside a component that is a child of a `<form>` element, commonly used to disable submit buttons during submission.", "source": "use_form_status"}
{"id": "re_005", "domain": "react_expert", "difficulty": "easy", "question": "What is `useOptimistic` in React 19 and when should you use it?", "ground_truth": "`useOptimistic(state, updateFn)` allows showing an immediately updated (optimistic) UI while an async operation is in progress. Call the returned `addOptimistic(newValue)` function to display the optimistic state immediately; React reverts to the actual `state` once the async action completes or errors. It is used to make UIs feel faster by skipping loading states for predictable mutations.", "source": "use_optimistic"}
{"id": "re_006", "domain": "react_expert", "difficulty": "easy", "question": "How can you render document metadata like `<title>` and `<meta>` tags in React 19 components?", "ground_truth": "In React 19, you can render `<title>`, `<meta>`, and `<link>` tags directly inside any component — including Server Components and Client Components — without a third-party library. React automatically hoists these tags to the document `<head>`. If multiple components render the same `<title>`, the last one in the tree wins.", "source": "document_metadata"}
{"id": "re_007", "domain": "react_expert", "difficulty": "easy", "question": "What does the `preloadImage` function from `react-dom` do in React 19?", "ground_truth": "`preloadImage(href, options)` triggers the browser to begin downloading an image before it is needed for rendering, reducing perceived load time. It is part of React 19's Resource Loading APIs alongside `preload`, `prefetchDNS`, `preinit`, and `preloadModule`, which provide declarative resource hints directly from components.", "source": "asset_loading_apis"}
{"id": "re_008", "domain": "react_expert", "difficulty": "easy", "question": "How does React 19 simplify passing refs to function components compared to React 18?", "ground_truth": "In React 19, `ref` is passed as a regular prop to function components, so you can access it directly as `function MyInput({ ref }) { ... }`. This eliminates the need for `forwardRef`. The `forwardRef` wrapper is deprecated in React 19 and will be removed in a future version.", "source": "ref_as_prop"}
{"id": "re_009", "domain": "react_expert", "difficulty": "easy", "question": "What is `useActionState` in React 19 and how does it differ from the deprecated `useFormState`?", "ground_truth": "`useActionState(action, initialState, permalink?)` wraps an action function and returns `[state, dispatch, isPending]`. It replaces the deprecated `useFormState` from `react-dom` by adding the `isPending` boolean, which is `true` while the action is executing. It works with both Server Actions and client-side async functions.", "source": "use_action_state"}
{"id": "re_010", "domain": "react_expert", "difficulty": "easy", "question": "What is a React Server Component (RSC) and where does its code execute?", "ground_truth": "React Server Components render exclusively on the server and their code is never sent to the client as JavaScript. They can directly access databases, file systems, and server-only APIs. Their output is serialized as a React tree and streamed to the client, reducing client bundle size because RSC code is never included in the browser bundle.", "source": "server_components"}
{"id": "re_011", "domain": "react_expert", "difficulty": "easy", "question": "What is the Client-Server component boundary in React 19, and which direction can components be imported across it?", "ground_truth": "The boundary is defined by `\"use client\"` files. Server Components can import and render Client Components, but Client Components cannot import Server Components — they can only receive Server Components as props (e.g., `children`). This one-way import rule preserves the server-only execution environment of Server Components.", "source": "component_boundary"}
{"id": "re_012", "domain": "react_expert", "difficulty": "easy", "question": "What does the `cache()` function do in React Server Components?", "ground_truth": "`cache(fn)` memoizes the result of a server function per React render pass. Multiple Server Components calling a `cache()`-wrapped function with the same arguments share the cached result within a single request, preventing duplicate database queries or expensive computations. The cache is invalidated between requests.", "source": "cache_function_rsc"}
{"id": "re_013", "domain": "react_expert", "difficulty": "easy", "question": "How are Server Actions invoked from an HTML form in React 19?", "ground_truth": "Pass a Server Action function to the `action` prop of a `<form>` element: `<form action={myServerAction}>`. When the form is submitted, React calls the Server Action with the `FormData` object on the server. Progressive enhancement is supported: the form works even before client-side JavaScript has loaded.", "source": "server_actions_forms"}
{"id": "re_014", "domain": "react_expert", "difficulty": "easy", "question": "How does `<Suspense>` work with async Server Components in React 19?", "ground_truth": "Async Server Components can `await` data directly in their render function. Wrapping them in `<Suspense fallback={<Loading />}>` shows the fallback UI while the async component is resolving on the server. Multiple async components inside the same Suspense boundary are awaited concurrently before the boundary is revealed.", "source": "suspense_async_server_components"}
{"id": "re_015", "domain": "react_expert", "difficulty": "easy", "question": "What change did React 19 make to how Context providers are written?", "ground_truth": "React 19 allows rendering `<MyContext value={...}>` directly as a provider, replacing the older `<MyContext.Provider value={...}>` syntax. The `<Context.Provider>` form still works but is deprecated; the shorter direct form is the new recommended syntax.", "source": "context_provider_syntax"}
{"id": "re_016", "domain": "react_expert", "difficulty": "easy", "question": "How do you use `startTransition` with Server Actions in React 19?", "ground_truth": "Wrap a Server Action call inside `startTransition` to mark it as a non-urgent transition: `startTransition(async () => { await myServerAction(data); })`. This keeps the UI responsive during the server round-trip. The `isPending` boolean returned by `useTransition()` reflects whether the action is still in flight.", "source": "start_transition_server_actions"}
{"id": "re_017", "domain": "react_expert", "difficulty": "easy", "question": "What are ref cleanup functions in React 19, and what do they replace?", "ground_truth": "In React 19, a ref callback can return a cleanup function: `<div ref={(node) => { setup(node); return () => cleanup(); }}>`. The cleanup runs when the element is removed from the DOM. This replaces the previous pattern of checking `if (node === null)` inside the same callback to detect unmounting.", "source": "ref_cleanup_functions"}
{"id": "re_018", "domain": "react_expert", "difficulty": "easy", "question": "What does `prefetchDNS` from `react-dom` do in React 19?", "ground_truth": "`prefetchDNS(href)` triggers a DNS prefetch for the given hostname, reducing connection latency for resources that will be loaded later. It is one of React 19's resource preloading APIs alongside `preload`, `preloadImage`, `preinit`, and `preinitModule`, and can be called from any component or Server Action.", "source": "prefetch_dns"}
{"id": "re_019", "domain": "react_expert", "difficulty": "easy", "question": "What improvement did React 19 make to hydration error messages?", "ground_truth": "React 19 shows a single unified diff of the hydration mismatch, clearly indicating which server-rendered and client-rendered HTML differ. Previously, React emitted multiple separate error messages that were hard to correlate. The new diff format makes diagnosing hydration mismatches significantly faster.", "source": "hydration_error_messages"}
{"id": "re_020", "domain": "react_expert", "difficulty": "easy", "question": "What is `experimental_taintObjectReference` in React and what security problem does it solve?", "ground_truth": "`experimental_taintObjectReference(message, object)` prevents a sensitive server-side object (e.g., user credentials, private database rows) from being accidentally serialized and sent to a Client Component. If the tainted object crosses the server-client boundary, React throws an error with the provided message, acting as a security guardrail against accidental data exposure.", "source": "taint_api_security"}
{"id": "re_021", "domain": "react_expert", "difficulty": "medium", "question": "How does React 19's `use(promise)` behave when called with an already-resolved Promise versus a pending Promise, and can `use()` be called inside conditional branches?", "ground_truth": "When called with an already-resolved Promise, `use()` returns the resolved value synchronously without suspending. When the Promise is still pending, the component suspends and React shows the nearest `<Suspense>` fallback until the Promise resolves, then re-renders. Unlike all other React hooks, `use()` CAN be called conditionally — inside `if` blocks and loops — because it does not follow the fixed-order rules of other hooks.", "source": "use_hook_suspense_integration"}
{"id": "re_022", "domain": "react_expert", "difficulty": "medium", "question": "What is the difference between useCallback and useMemo, and when should you use each one?", "ground_truth": "useCallback memoizes a function reference and returns the same function if dependencies haven't changed, useful for passing callbacks to optimized child components. useMemo memoizes a computed value and is used to avoid expensive calculations on every render. Use useCallback for function dependencies, useMemo for computed values.", "source": "hooks_optimization"}
{"id": "re_023", "domain": "react_expert", "difficulty": "medium", "question": "In React 19, how do errors thrown by async Server Components propagate, and what constraint applies to error values that cross the server-client boundary?", "ground_truth": "Errors thrown by async Server Components are caught by the nearest `<ErrorBoundary>` component above them in the tree. In development React shows a detailed overlay; in production only the boundary's fallback is shown. Error values crossing the server-client boundary must be serializable (plain Error objects) — errors containing non-serializable data (class instances with methods, closures) are replaced with a generic message. Server Action errors are best returned as structured state rather than thrown, to provide user-friendly messages without exposing server details.", "source": "server_component_error_handling"}
{"id": "re_024", "domain": "react_expert", "difficulty": "medium", "question": "Explain the purpose of React.memo and under what conditions it prevents unnecessary re-renders.", "ground_truth": "React.memo wraps a functional component to perform shallow comparison of props; it prevents re-renders if props haven't changed. It only works with functional components and compares reference equality for objects/arrays, so inline object/array props will bypass memoization. It's useful for expensive components with stable props.", "source": "performance_optimization"}
{"id": "re_025", "domain": "react_expert", "difficulty": "medium", "question": "What is the purpose of the key prop in React lists, and what happens if you use array indices as keys?", "ground_truth": "The key prop helps React identify which items have changed, been added, or removed, enabling correct state preservation. Using array indices as keys causes issues when lists are reordered, filtered, or items are added/removed, as the index may map to different items, breaking component state and leading to bugs.", "source": "list_rendering"}
{"id": "re_026", "domain": "react_expert", "difficulty": "medium", "question": "How does React's concurrent rendering work, and what problems does it solve?", "ground_truth": "Concurrent rendering allows React to interleave rendering work with browser tasks, preventing main thread blocking. It enables features like Suspense and transitions to prioritize updates and maintain responsiveness. It solves the problem of long renders causing janky UI by yielding control back to the browser.", "source": "concurrent_rendering"}
{"id": "re_027", "domain": "react_expert", "difficulty": "medium", "question": "Explain the difference between controlled and uncontrolled components, and when to use each.", "ground_truth": "Controlled components have their state managed by React (value prop controlled by state), while uncontrolled components manage their own state via the DOM (accessed via refs). Use controlled components for validation, conditional rendering, or instant feedback; use uncontrolled for simple cases or integrating non-React code.", "source": "form_handling"}
{"id": "re_028", "domain": "react_expert", "difficulty": "medium", "question": "How do you prevent memory leaks when using useEffect with subscriptions or timers?", "ground_truth": "Return a cleanup function from useEffect that unsubscribes or clears timers when the component unmounts or before the effect runs again. Example: useEffect(() => { const timer = setTimeout(...); return () => clearTimeout(timer); }, []). Without cleanup, subscriptions persist and timers continue after unmounting.", "source": "hooks_cleanup"}
{"id": "re_029", "domain": "react_expert", "difficulty": "medium", "question": "What is the relationship between React.StrictMode and detecting side effects or unsafe lifecycle methods?", "ground_truth": "StrictMode intentionally double-invokes render functions, effects, and state updaters in development to help identify impure code and side effects. It highlights deprecated lifecycle methods and warns about unsafe patterns. It only runs in development mode and helps catch bugs caused by side effects.", "source": "strict_mode"}
{"id": "re_030", "domain": "react_expert", "difficulty": "medium", "question": "How do you optimize performance when rendering large lists in React?", "ground_truth": "Use windowing/virtualization libraries (like react-window) to render only visible items, implement proper keys, memoize list items with React.memo, use useCallback for handlers, and consider pagination. Combine with code splitting and lazy loading to reduce initial bundle and improve render performance.", "source": "list_performance"}
{"id": "re_031", "domain": "react_expert", "difficulty": "medium", "question": "Explain how Context API works and its performance implications compared to Redux.", "ground_truth": "Context API provides a way to pass data through the component tree without prop drilling. Performance issue: any Context value change re-renders all consumers, unlike Redux which allows fine-grained subscriptions. For complex, frequently-changing state, Redux is more efficient; for simpler state, Context is sufficient.", "source": "state_management"}
{"id": "re_032", "domain": "react_expert", "difficulty": "medium", "question": "What are the differences between useLayoutEffect and useEffect, and when should you use useLayoutEffect?", "ground_truth": "useEffect runs asynchronously after paint, while useLayoutEffect runs synchronously after DOM mutations but before paint. Use useLayoutEffect for DOM measurements, positioning calculations, or when you need to update DOM before the browser paints. Use useEffect for most cases to avoid blocking paint.", "source": "advanced_hooks"}
{"id": "re_033", "domain": "react_expert", "difficulty": "medium", "question": "How does React handle event delegation, and what is event pooling?", "ground_truth": "React uses event delegation to attach listeners at the root level, improving performance. Event pooling (React 16 and earlier) reused synthetic event objects to reduce garbage collection; React 17+ removed pooling for better async/await compatibility. Events are normalized across browsers through the SyntheticEvent wrapper.", "source": "event_handling"}
{"id": "re_034", "domain": "react_expert", "difficulty": "medium", "question": "What is the purpose of refs in React, and why should you avoid overusing them?", "ground_truth": "Refs allow direct access to DOM elements or class component instances, bypassing React's declarative model. Use them for managing focus, triggering animations, or integrating with third-party libraries. Overuse breaks React's declarative paradigm, makes components harder to reason about, and can cause state synchronization issues.", "source": "refs"}
{"id": "re_035", "domain": "react_expert", "difficulty": "medium", "question": "How does React's dependency array work in hooks, and what are common pitfalls?", "ground_truth": "The dependency array controls when the hook effect runs: empty array runs once, undefined/omitted runs every render, specific dependencies run when those values change (by reference equality). Pitfalls include missing dependencies (causing stale closures), including non-primitive values without memoization, and comparing by reference instead of value.", "source": "hooks_dependencies"}
{"id": "re_036", "domain": "react_expert", "difficulty": "medium", "question": "What is the purpose of Suspense, and what limitations does it currently have?", "ground_truth": "Suspense lets components pause rendering while data is being loaded and show a fallback UI. It works with lazy code splitting and async libraries that integrate with it. Limitations: doesn't catch errors (use Error Boundaries), only works with async libraries that support Suspense, server rendering support is partial.", "source": "suspense"}
{"id": "re_037", "domain": "react_expert", "difficulty": "medium", "question": "Explain the difference between shallow and deep equality checks, and how they affect component optimization.", "ground_truth": "Shallow equality checks only the top level of objects/arrays (reference comparison), while deep equality recursively compares all nested properties. Shallow checks are faster but miss nested changes; deep checks catch all changes but are slower. React.memo uses shallow by default; use custom comparators for deep checks.", "source": "equality_optimization"}
{"id": "re_038", "domain": "react_expert", "difficulty": "medium", "question": "How do you handle async operations in React, and what are the trade-offs between different approaches?", "ground_truth": "Approaches include useEffect with promises/async-await, libraries like react-query or SWR, or Suspense. useEffect is flexible but requires manual loading/error handling. Libraries abstract patterns and add caching. Suspense is newer but has limitations. Trade-offs: complexity vs. features, bundle size vs. functionality.", "source": "async_patterns"}
{"id": "re_039", "domain": "react_expert", "difficulty": "medium", "question": "What is the React Server Component (RSC) wire format, and what categories of values can and cannot be passed as props from a Server Component to a Client Component?", "ground_truth": "The RSC wire format is a JSON-based serialized tree describing Server Component output. Values that CAN cross the boundary: primitives (strings, numbers, booleans, null), arrays, plain objects, Dates, typed arrays (Uint8Array etc.), and Server Actions (serialized as opaque references). Values that CANNOT cross: functions (except Server Actions), class instances, Symbols, Maps, Sets, and any non-serializable JavaScript value — passing these throws an error during Server Component rendering.", "source": "rsc_wire_format_serialization"}
{"id": "re_040", "domain": "react_expert", "difficulty": "medium", "question": "How do you implement custom hooks, and what best practices should you follow?", "ground_truth": "Custom hooks are JavaScript functions that use React hooks internally, enabling logic reuse. Name them with 'use' prefix, call hooks unconditionally and only at the top level, and return state/functions. Best practices: keep them focused, document dependencies, use TypeScript for type safety, avoid complex nested logic.", "source": "custom_hooks"}
{"id": "re_041", "domain": "react_expert", "difficulty": "hard", "question": "When implementing concurrent rendering with useTransition, how does React prioritize state updates between urgent and non-urgent updates, and what are the performance implications of interrupting a non-urgent render?", "ground_truth": "React uses a priority-based scheduler where urgent updates (user input, animations) interrupt non-urgent transitions. Non-urgent renders can be abandoned mid-way without completing side effects, reducing main-thread blocking but requiring careful dependency management to avoid inconsistent state exposure.", "source": "concurrent_rendering_and_transitions"}
{"id": "re_042", "domain": "react_expert", "difficulty": "hard", "question": "Explain how `useActionState` in React 19 manages state across Server Action invocations, and what the `isPending` return value represents during execution.", "ground_truth": "`useActionState(action, initialState, permalink?)` returns `[state, dispatch, isPending]`. When `dispatch` is called with form data, React invokes `action(previousState, formData)` on the server and `isPending` is true while it executes. The value returned by the action becomes the new `state`, enabling form submission feedback without explicit `useState`. If the action throws, the previous state is retained. The optional `permalink` URL allows the form to work before JavaScript hydration via full-page navigation, supporting progressive enhancement.", "source": "use_action_state_server_actions"}
{"id": "re_043", "domain": "react_expert", "difficulty": "hard", "question": "What does React 19's `experimental_taintObjectReference` protect against, and what is the difference between `taintObjectReference` and `taintUniqueValue`?", "ground_truth": "`experimental_taintObjectReference(message, object)` marks a server-side object so React throws an error if it is serialized and sent to a Client Component, preventing accidental exposure of database rows or sessions. `experimental_taintUniqueValue(message, lifetime, value)` marks a specific scalar value (string, number, BigInt) like an API key. The key difference: `taintObjectReference` taints by object reference (the specific instance), while `taintUniqueValue` taints by value (any occurrence of that exact string/number anywhere). Both require the React 19 experimental channel.", "source": "taint_api_security"}
{"id": "re_044", "domain": "react_expert", "difficulty": "hard", "question": "How does React's fiber architecture handle error boundaries, and what happens when an error occurs during the render phase versus the commit phase?", "ground_truth": "Error boundaries catch errors during render and lifecycle methods but not during event handlers or asynchronous code. Render-phase errors are caught by nearest boundary and trigger fallback UI; commit-phase errors (useLayoutEffect, useEffect) aren't caught and propagate to the browser, requiring separate error handling.", "source": "error_boundaries_and_fiber"}
{"id": "re_045", "domain": "react_expert", "difficulty": "hard", "question": "In React 19 Server Components, how does the `cache()` function from 'react' differ from `useMemo` in a Client Component in terms of scope and persistence?", "ground_truth": "`cache(fn)` (from 'react') is server-only and memoizes a function's result per React render pass — multiple Server Components calling a `cache()`-wrapped function with identical arguments within a single request share the result, preventing duplicate database queries. The cache resets between requests. `useMemo` is a Client Component hook that caches within a single component's lifetime across renders but does NOT share results between component instances. `cache()` provides cross-component server-side deduplication within a request; `useMemo` provides per-instance render optimization.", "source": "cache_function_vs_use_memo"}
{"id": "re_046", "domain": "react_expert", "difficulty": "hard", "question": "Explain the batching behavior in React 18 and how automatic batching differs from React 17, including cases where batching may not occur.", "ground_truth": "React 18 automatically batches state updates inside event handlers, timeouts, and promises by default. However, batching doesn't occur for microtasks before React 18 or in some edge cases like flushSync calls. flushSync forces immediate synchronous updates, breaking batching when explicit sequential updates are needed.", "source": "react18_batching_behavior"}
{"id": "re_047", "domain": "react_expert", "difficulty": "hard", "question": "What is the purpose of the key prop in React reconciliation, and how can incorrect keys cause bugs with component state and form inputs?", "ground_truth": "Keys help React identify which items have changed, aiding efficient reconciliation. Incorrect keys (using array indices, random values) cause React to reuse component instances incorrectly, leading to state bleeding between list items, form input values appearing in wrong positions, and animation glitches.", "source": "reconciliation_and_keys"}
{"id": "re_048", "domain": "react_expert", "difficulty": "hard", "question": "How does React's context API handle performance optimization, and why can context consumer updates cause unnecessary re-renders even when using useMemo?", "ground_truth": "Context updates cause all consumers to re-render regardless of whether their subscribed value changed. Even with useMemo, child components re-render due to React's propagation model. Solutions include splitting contexts by update frequency, using useReducer for derived state, or third-party state management with selective subscriptions.", "source": "context_api_performance"}
{"id": "re_049", "domain": "react_expert", "difficulty": "hard", "question": "Explain the difference between shallow and deep equality in React, and describe how PureComponent and React.memo determine when to skip re-renders.", "ground_truth": "Shallow equality compares only top-level property references using Object.is, not nested values. PureComponent and React.memo use shallow comparison by default; if props contain new object/array references with identical contents, they still re-render. Custom comparators enable deep checks but add performance overhead.", "source": "equality_comparison_memoization"}
{"id": "re_050", "domain": "react_expert", "difficulty": "hard", "question": "What are the memory leak risks when using useEffect with subscriptions or event listeners, and how should cleanup functions be structured to prevent them?", "ground_truth": "Unmounted components with active subscriptions or listeners retain references, preventing garbage collection. Cleanup functions must unsubscribe and remove listeners on unmount. Failing to include dependencies causes stale closures; incorrect cleanup (removing only initial listener) causes duplicates. Proper dependencies and cleanup functions are essential.", "source": "useeffect_cleanup_memory_leaks"}
