{"id": "se_001", "domain": "swift_expert", "difficulty": "easy", "question": "What is the primary purpose of the @MainActor annotation in Swift?", "ground_truth": "The @MainActor annotation ensures that a type or method always executes on the main thread, preventing data races in UI code. It is commonly used for SwiftUI views and UI-related classes.", "source": "MainActor"}
{"id": "se_002", "domain": "swift_expert", "difficulty": "easy", "question": "What does the Sendable protocol guarantee in Swift 6 concurrency?", "ground_truth": "The Sendable protocol guarantees that a type can be safely shared across different concurrency domains (actors, tasks) without risk of data races. The compiler enforces this at compile-time.", "source": "sendable_types"}
{"id": "se_003", "domain": "swift_expert", "difficulty": "easy", "question": "What is the key difference between an actor and a class in Swift?", "ground_truth": "Actors provide automatic synchronization of their mutable state and ensure only one task can access their state at a time, preventing data races. Classes do not provide this protection.", "source": "actor_isolation"}
{"id": "se_004", "domain": "swift_expert", "difficulty": "easy", "question": "What does the ~Copyable marker indicate in Swift?", "ground_truth": "The ~Copyable marker declares a noncopyable type that cannot be implicitly copied. This is useful for types that manage exclusive resources like file handles or locks.", "source": "noncopyable_types"}
{"id": "se_005", "domain": "swift_expert", "difficulty": "easy", "question": "What is async/await in Swift and what problem does it solve?", "ground_truth": "async/await is a syntax for writing asynchronous code that reads like synchronous code. It solves the complexity of callback-based or promise-based concurrency by allowing sequential-looking code with suspension points.", "source": "async_await"}
{"id": "se_006", "domain": "swift_expert", "difficulty": "easy", "question": "What are task groups in Swift, and when would you use them?", "ground_truth": "Task groups allow you to spawn and manage multiple concurrent child tasks, collecting their results. Use them when you need to perform multiple async operations in parallel and wait for all results.", "source": "task_groups"}
{"id": "se_007", "domain": "swift_expert", "difficulty": "easy", "question": "What does 'typed throws' mean in Swift, and how does it differ from regular error handling?", "ground_truth": "Typed throws specify the exact error type a function can throw (e.g., throws(NetworkError)). Regular throws allow any Error type, providing stricter type safety and better error clarity.", "source": "typed_throws"}
{"id": "se_008", "domain": "swift_expert", "difficulty": "easy", "question": "What is an opaque type, and what keyword introduces it?", "ground_truth": "An opaque type hides the concrete type behind an abstract interface while preserving type identity at compile-time. The 'some' keyword introduces opaque types, commonly used in SwiftUI with 'some View'.", "source": "opaque_types"}
{"id": "se_009", "domain": "swift_expert", "difficulty": "easy", "question": "What is ARC and why is it important in Swift?", "ground_truth": "Automatic Reference Counting (ARC) automatically manages memory by tracking object references and deallocating objects when reference count reaches zero. It eliminates manual memory management and reduces memory leaks.", "source": "ARC"}
{"id": "se_010", "domain": "swift_expert", "difficulty": "easy", "question": "What is the purpose of property wrappers in Swift?", "ground_truth": "Property wrappers encapsulate property access logic and allow you to attach custom behavior like validation, lazy initialization, or state management. Common examples include @State and @Published in SwiftUI.", "source": "property_wrappers"}
{"id": "se_011", "domain": "swift_expert", "difficulty": "easy", "question": "What is protocol-oriented programming, and why is it emphasized in Swift?", "ground_truth": "Protocol-oriented programming uses protocols as the primary abstraction mechanism instead of inheritance. Swift emphasizes it because protocols are more flexible, enable value types to adopt behaviors, and support static dispatch.", "source": "protocol_oriented_programming"}
{"id": "se_012", "domain": "swift_expert", "difficulty": "easy", "question": "What are generics in Swift, and what advantage do they provide?", "ground_truth": "Generics allow functions and types to work with any type while maintaining type safety. They enable code reuse without sacrificing compile-time type checking.", "source": "generics"}
{"id": "se_013", "domain": "swift_expert", "difficulty": "easy", "question": "What is an optional in Swift, and how is it represented?", "ground_truth": "An optional is a type that can either hold a value or be nil. It is represented as Optional<T> or T?, providing type-safe null handling by requiring explicit unwrapping.", "source": "optionals"}
{"id": "se_014", "domain": "swift_expert", "difficulty": "easy", "question": "What are result builders, and what is their typical use case?", "ground_truth": "Result builders use the @resultBuilder attribute to convert sequences of statements into a single value. They are used in SwiftUI for the @ViewBuilder to compose UI elements cleanly.", "source": "result_builders"}
{"id": "se_015", "domain": "swift_expert", "difficulty": "easy", "question": "What is the main purpose of the Swift Package Manager (SPM)?", "ground_truth": "The Swift Package Manager is Swift's native dependency management and build system tool. It manages package dependencies, builds packages, and integrates with Xcode and command-line tools.", "source": "Swift_Package_Manager"}
{"id": "se_016", "domain": "swift_expert", "difficulty": "easy", "question": "What are async sequences, and how do they differ from regular sequences?", "ground_truth": "Async sequences produce values asynchronously over time, using AsyncSequence protocol. Unlike regular sequences, they can suspend and are used for stream processing, network requests, or real-time data.", "source": "async_sequences"}
{"id": "se_017", "domain": "swift_expert", "difficulty": "easy", "question": "What are macros in Swift, and what problem do they solve?", "ground_truth": "Macros are compile-time programs that generate code by manipulating the syntax tree. They eliminate boilerplate code, reduce duplication, and provide powerful metaprogramming capabilities.", "source": "macros"}
{"id": "se_018", "domain": "swift_expert", "difficulty": "easy", "question": "What does 'memory safety' mean in the context of Swift?", "ground_truth": "Memory safety means preventing undefined behavior like buffer overflows, use-after-free, and data races through compile-time checks. Swift enforces this through its type system and strict borrowing rules.", "source": "memory_safety"}
{"id": "se_019", "domain": "swift_expert", "difficulty": "easy", "question": "What are closures in Swift, and what is their primary use?", "ground_truth": "Closures are anonymous functions that can capture variables from their surrounding scope. They are used for callbacks, higher-order functions, and functional programming patterns.", "source": "closures"}
{"id": "se_020", "domain": "swift_expert", "difficulty": "easy", "question": "What is embedded Swift, and what target does it focus on?", "ground_truth": "Embedded Swift is a variant of Swift designed for embedded systems and resource-constrained devices. It removes dynamic features and runtime overhead, enabling Swift on microcontrollers and bare-metal systems.", "source": "embedded_swift"}
{"id": "se_021", "domain": "swift_expert", "difficulty": "medium", "question": "In Swift 6 strict concurrency, explain why a class without explicit MainActor annotation might still require @MainActor methods, and what compile-time guarantee this provides.", "ground_truth": "Classes inferred as MainActor-bound (e.g., those inheriting from UIViewController) require @MainActor methods to ensure thread-safe access to their mutable state. The compiler statically verifies that only MainActor-isolated code can mutate main-thread-dependent properties, preventing data races at compile time rather than runtime.", "source": "MainActor_strict_concurrency"}
{"id": "se_022", "domain": "swift_expert", "difficulty": "medium", "question": "What is the key difference between an actor's isolated state and a noncopyable type's ownership model, and when would you use each?", "ground_truth": "Actors provide mutual exclusion for mutable state via serial executor access, ensuring at most one task accesses isolated state; noncopyable types use exclusive ownership to prevent copying, giving one owner at a time. Use actors for shared mutable resources; use noncopyable (~Copyable) for resources like file handles that logically cannot be duplicated.", "source": "actors_vs_noncopyable"}
{"id": "se_023", "domain": "swift_expert", "difficulty": "medium", "question": "In Swift 6, why does a Sendable struct containing a non-Sendable field fail compilation, and what are the two primary ways to resolve this conflict?", "ground_truth": "Sendable requires all fields to be Sendable to guarantee safe transfer across isolation domains; mixing non-Sendable fields breaks that invariant. Solutions: (1) refactor the field to be Sendable, or (2) use @unchecked Sendable with manual verification that the field is actually safe (unsafe last resort).", "source": "Sendable_protocol"}
{"id": "se_024", "domain": "swift_expert", "difficulty": "medium", "question": "Explain why typed throws (throwing <ErrorType>) allows the compiler to prove exhaustiveness in catch blocks, and give an example scenario where this prevents a subtle bug.", "ground_truth": "Typed throws narrows the thrown error type, allowing the compiler to verify that all possible error cases are handled without a catch-all. Example: a function throwing only FileNotFoundError or PermissionError can be exhaustively matched; without typing, developers might forget to handle one case, which remains silent at compile time.", "source": "typed_throws"}
{"id": "se_025", "domain": "swift_expert", "difficulty": "medium", "question": "What problem does TaskGroup.addTask solve compared to spawning unstructured tasks, and why is this critical for memory safety in concurrent code?", "ground_truth": "TaskGroup ensures all child tasks complete before the group scope exits, providing structured lifetimes and preventing dangling task references. This guarantees that the parent task cannot deallocate shared state while child tasks are still accessing it, eliminating a class of memory safety violations.", "source": "structured_concurrency_task_groups"}
{"id": "se_026", "domain": "swift_expert", "difficulty": "medium", "question": "In Swift, why can a closure capturing `self` in an async context sometimes cause a data race even if the captured property is thread-safe, and how do @Sendable closures help?", "ground_truth": "A closure capturing self can hide the reference through an opaque closure type, allowing accidental cross-isolation access; the compiler cannot see the isolation context inside a non-Sendable closure. @Sendable closures enforce that all captures are Sendable and the closure itself is safe to send, statically proving no data races occur.", "source": "closures_sendable_isolation"}
{"id": "se_027", "domain": "swift_expert", "difficulty": "medium", "question": "Explain the memory semantics of Optional<T> in Swift, including why Optional is not just syntactic sugar and how it affects ARC behavior.", "ground_truth": "Optional<T> is an enum with cases .none and .some(T), storing T inline; this avoids an extra heap allocation compared to a nullable pointer. ARC counts the inner T reference, so Optional<SomeClass> uses the same ARC mechanism as T but adds nil-checking logic and the enum discriminant.", "source": "optionals_memory_arc"}
{"id": "se_028", "domain": "swift_expert", "difficulty": "medium", "question": "Why does SwiftUI's @State property wrapper require value semantics (structs), and what would happen if you used a reference type (class)?", "ground_truth": "@State relies on value semantics to track identity and detect mutations via identity comparison; using a class breaks this because multiple views could share the same class instance, causing mutations to bypass SwiftUI's change detection and lead to inconsistent UI updates.", "source": "swiftui_property_wrappers"}
{"id": "se_029", "domain": "swift_expert", "difficulty": "medium", "question": "In result builders (like SwiftUI's ViewBuilder), what is the purpose of the buildBlock overloads, and why must they exist for multiple arities?", "ground_truth": "buildBlock overloads combine N child results into a parent result; multiple arities (e.g., buildBlock(_:) for 1, buildBlock(_:_:) for 2) allow the compiler to type-check arbitrary-length sequences of statements. Each overload handles a different number of child elements to produce a single output.", "source": "result_builders"}
{"id": "se_030", "domain": "swift_expert", "difficulty": "medium", "question": "Explain how generic constraints using associated types (PATs) in Swift 5.7+ improve upon the limitations of existential types when modeling protocol-oriented designs.", "ground_truth": "Associated type constraints allow the compiler to preserve concrete types across generic boundaries, avoiding the performance penalty and feature loss of existential type erasure. Example: a generic function <T: Iterator where T.Element == Int> knows the exact type, while any Iterator existential loses Element type information.", "source": "generics_associated_types"}
{"id": "se_031", "domain": "swift_expert", "difficulty": "medium", "question": "In Swift Package Manager, what is the difference between a target's publicHeadersPath and umbrella headers, and when would you use each in a mixed Swift/C++ package?", "ground_truth": "publicHeadersPath exposes individual header files; umbrella headers are a single .h file that includes all public headers, simplifying the public API surface. Use umbrella headers for stable, well-defined C++ APIs; use publicHeadersPath for fine-grained control or when headers must remain separate.", "source": "spm_c_interop"}
{"id": "se_032", "domain": "swift_expert", "difficulty": "medium", "question": "How do macros in Swift differ from textual C preprocessor macros in terms of hygiene and type safety, and what compile-time guarantees do they provide?", "ground_truth": "Swift macros are syntactically hygienic (identifiers don't shadow outer scope) and type-checked after expansion, preventing silent type mismatches or name collisions. C preprocessor macros are textual and untyped, often causing subtle bugs; Swift macros expand in the compiler's semantic phase, giving full type guarantees.", "source": "swift_macros"}
{"id": "se_033", "domain": "swift_expert", "difficulty": "medium", "question": "Explain the difference between @escaping and @Sendable closure annotations in Swift 6 strict concurrency, and why both are needed.", "ground_truth": "@escaping allows a closure to outlive the function call (stored/delayed execution); @Sendable guarantees the closure is isolation-safe and can cross isolation boundaries. A closure can be both @escaping @Sendable (stored and safe) or neither (local, non-escaping, potentially non-Sendable).", "source": "closures_escaping_sendable"}
{"id": "se_034", "domain": "swift_expert", "difficulty": "medium", "question": "In embedded Swift, why are reference types and dynamic memory allocation limited, and what compile-time or runtime constraints enforce this?", "ground_truth": "Embedded Swift targets resource-constrained systems where heap fragmentation and dynamic allocation overhead are unacceptable; the runtime disables dynamic allocations and restricts reference types to enable predictable memory usage. Compile-time checks prevent use of unsupported features; runtime barriers prevent unsafe allocation.", "source": "embedded_swift"}
{"id": "se_035", "domain": "swift_expert", "difficulty": "medium", "question": "Why does the Swift compiler require explicit annotation of C++ types as Sendable when interoperating with C++ objects, and what memory-safety risk does this mitigate?", "ground_truth": "C++ objects may use thread-unsafe patterns (e.g., mutable static state, non-atomic writes) invisible to Swift's type system; explicit Sendable annotation forces developers to verify thread-safety manually. Without this, a non-Sendable C++ object could be passed across actor boundaries, causing data races.", "source": "cpp_interop_sendable"}
{"id": "se_036", "domain": "swift_expert", "difficulty": "medium", "question": "Explain how opaque return types (some T) differ from protocol existentials in terms of performance and ARC behavior, with a concrete example.", "ground_truth": "Opaque types fix the concrete type at compile time, allowing inlining and zero-cost abstraction; existentials erase the type at runtime, requiring v-table indirection and potential heap allocation. Example: returning some View from a SwiftUI builder inlines the View hierarchy; returning any View requires type erasure and dynamic dispatch.", "source": "opaque_types"}
{"id": "se_037", "domain": "swift_expert", "difficulty": "medium", "question": "In AsyncSequence, why is it necessary for conforming types to also conform to Sendable, and what guarantee does this provide in structured concurrency?", "ground_truth": "AsyncSequence often lives across await points and task boundaries; Sendable conformance ensures the sequence's state can safely be captured and accessed by multiple async contexts without data races. This allows iteration to span isolation domains without compiler warnings.", "source": "async_sequences"}
{"id": "se_038", "domain": "swift_expert", "difficulty": "medium", "question": "How do property wrappers implement the @State semantics in SwiftUI without breaking SwiftUI's change detection, and what role does the _modify coroutine play?", "ground_truth": "@State stores the actual value and wraps it in a Binding via projectedValue; _modify allows in-place mutation callbacks that notify SwiftUI of changes. When the wrapped value is modified, _modify triggers the change notification, updating views without relying on reference comparison.", "source": "property_wrappers_state"}
{"id": "se_039", "domain": "swift_expert", "difficulty": "medium", "question": "Explain the trade-off between using a generic constraint (e.g., <T: Equatable>) versus existential type (any Equatable) in a Swift function signature, including performance implications.", "ground_truth": "Generic constraints preserve concrete types and enable specialization for each caller, allowing inlining and zero-cost abstraction; existentials erase type at runtime, requiring indirection but allowing polymorphic collections. Use generics for performance-critical APIs; use existentials for heterogeneous containers.", "source": "generics_vs_existentials"}
{"id": "se_040", "domain": "swift_expert", "difficulty": "medium", "question": "In Swift 6, what prevents a non-isolated actor method from directly accessing isolated state, and how does the compiler enforce this isolation at compile time?", "ground_truth": "The compiler tracks isolation context; non-isolated methods run outside the actor's serial executor, so direct access to isolated properties is a compile error. To access isolated state, non-isolated code must use await to hop onto the actor's executor, enforcing that all mutations are serialized by the actor's isolation.", "source": "actor_isolation_enforcement"}
{"id": "se_041", "domain": "swift_expert", "difficulty": "hard", "question": "In Swift 6 with strict concurrency enabled, explain why a mutable struct containing an actor reference cannot conform to Sendable even if all its fields are individually Sendable. What is the architectural implication?", "ground_truth": "A mutable struct is not Sendable because mutation can create data races when the struct is passed across isolation boundaries\u2014the caller and callee could mutate overlapping memory simultaneously. Architecturally, this forces you to wrap mutable state in an actor or use value semantics with immutable snapshots, preventing accidental concurrent mutation.", "source": "sendable_types_mutability"}
{"id": "se_042", "domain": "swift_expert", "difficulty": "hard", "question": "You have a noncopyable type (marked with ~Copyable) that holds a file descriptor. How does its move-only semantics interact with closure capture semantics, and what compiler guarantees does Swift provide about its lifetime?", "ground_truth": "Noncopyable types cannot be implicitly copied; they must be explicitly moved or borrowed. When captured in closures, the compiler enforces that the closure takes exclusive ownership or borrows the value, preventing accidental copies. Swift guarantees the resource won't be duplicated and will be deallocated exactly once via RAII-like semantics.", "source": "noncopyable_types_move_semantics"}
{"id": "se_043", "domain": "swift_expert", "difficulty": "hard", "question": "In a scenario with nested task groups and structured concurrency, if a child task throws an error of a custom typed-throw type, how does error propagation work across task boundaries, and what happens to sibling tasks?", "ground_truth": "Typed throws require the error type to match the task's declared throw type. When a child task throws, the error propagates to the enclosing task group, which cancels all sibling tasks. If the error type doesn't match the group's constraint, the code won't compile; mismatches require explicit error type mapping or wrapper types.", "source": "typed_throws_task_groups"}
{"id": "se_044", "domain": "swift_expert", "difficulty": "hard", "question": "A macro generates code that creates a @MainActor-isolated property. If the macro is applied in a file with strict concurrency checking disabled in some modules but enabled in others, what potential issues arise during integration?", "ground_truth": "Modules without strict concurrency won't enforce @MainActor isolation at compile time, allowing data races to slip through. When integrated with strict-concurrency modules, the mismatch causes type-checking failures or forces unsafe bridging with nonisolated(unsafe). This breaks safety guarantees and requires consistent concurrency enforcement across the build.", "source": "macros_mainactor_module_integration"}
{"id": "se_045", "domain": "swift_expert", "difficulty": "hard", "question": "Explain the performance trade-off between using async sequences with AsyncIterator.next() versus collecting all values into an array upfront when dealing with high-frequency event streams. What memory and latency implications exist?", "ground_truth": "Async sequences stream values lazily, reducing memory footprint and enabling backpressure handling, but incur per-iteration async overhead. Collecting upfront uses more memory but eliminates async call overhead and enables parallel processing. For high-frequency events, streaming is better for memory-constrained systems; upfront collection suits low-latency, bounded workloads.", "source": "async_sequences_performance_tradeoffs"}
{"id": "se_046", "domain": "swift_expert", "difficulty": "hard", "question": "You're designing a protocol with associated types constrained by both Sendable and a custom protocol requirement. How does the compiler's conformance checking handle this, and what are edge cases with generic specialization?", "ground_truth": "The compiler requires concrete types to satisfy both constraints simultaneously. Edge cases arise when a generic specialization produces a non-Sendable type for a Sendable-constrained associated type\u2014the compiler rejects it. Protocol extension default implementations cannot assume Sendability unless explicitly constrained, requiring explicit where clauses for Sendable conformance.", "source": "protocols_associated_types_sendable_constraints"}
{"id": "se_047", "domain": "swift_expert", "difficulty": "hard", "question": "When using C++ interoperability with Swift, how does ARC interact with C++ reference counting (e.g., std::shared_ptr)? What happens if a Swift actor owns a C++ object with internal mutable state?", "ground_truth": "ARC and C++ reference counting operate independently; Swift cannot automatically manage C++ refcount. If a Swift actor owns a C++ object with mutable state, the actor must provide exclusive access through synchronized methods, as ARC doesn't prevent C++ code from mutating the object concurrently. This is a common data-race source requiring manual synchronization.", "source": "cpp_interop_arc_concurrency"}
{"id": "se_048", "domain": "swift_expert", "difficulty": "hard", "question": "A property wrapper for SwiftUI state uses a generic constraint on its wrapped value type. If that constraint includes Sendable, how does this interact with SwiftUI's main-thread requirement and what happens during property updates from background tasks?", "ground_truth": "Sendable-constrained wrapped values in @State must be main-thread-safe by definition. Updates from background tasks violate Swift concurrency rules\u2014the compiler forces updates through MainActor or DispatchQueue.main. This prevents race conditions but can cause deadlocks if the update logic re-enters the main thread.", "source": "property_wrappers_swiftui_sendable_constraints"}
{"id": "se_049", "domain": "swift_expert", "difficulty": "hard", "question": "In a Swift Package with multiple targets, if one target uses strict concurrency and another doesn't, and they share types through a public API, what specific compilation errors and runtime behavior should you expect? How do you bridge this safely?", "ground_truth": "The strict-concurrency target will flag cross-module types as non-Sendable, causing compilation errors. Runtime behavior is undefined\u2014race conditions may not manifest. Safe bridging requires wrapping non-Sendable types in actor-isolated APIs, using nonisolated(unsafe) only with documented thread-safety guarantees, or enforcing strict concurrency package-wide.", "source": "spm_cross_module_strict_concurrency"}
