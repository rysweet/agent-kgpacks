{"id": "te_001", "domain": "terraform_expert", "difficulty": "easy", "question": "What is the primary purpose of Terraform?", "ground_truth": "Terraform is an Infrastructure as Code (IaC) tool that enables users to define, provision, and manage cloud infrastructure using declarative configuration files written in HCL (HashiCorp Configuration Language).", "source": "core_purpose"}
{"id": "te_002", "domain": "terraform_expert", "difficulty": "easy", "question": "Which language does Terraform use for configuration files?", "ground_truth": "Terraform uses HCL (HashiCorp Configuration Language), a human-readable declarative language designed specifically for infrastructure provisioning and configuration management.", "source": "hcl_language"}
{"id": "te_003", "domain": "terraform_expert", "difficulty": "easy", "question": "What file extension is used for Terraform configuration files?", "ground_truth": "Terraform configuration files use the .tf file extension. Multiple .tf files in the same directory are automatically merged and treated as a single configuration.", "source": "file_extensions"}
{"id": "te_004", "domain": "terraform_expert", "difficulty": "easy", "question": "What is the Terraform state file and what is its default name?", "ground_truth": "The Terraform state file tracks the current state of managed infrastructure and maps configuration to real-world resources. The default name is terraform.tfstate, stored locally by default.", "source": "state_management"}
{"id": "te_005", "domain": "terraform_expert", "difficulty": "easy", "question": "Name three major cloud providers that Terraform supports.", "ground_truth": "Terraform supports AWS (Amazon Web Services), Azure (Microsoft Azure), and Google Cloud Platform (GCP), among many others through its provider ecosystem.", "source": "provider_support"}
{"id": "te_006", "domain": "terraform_expert", "difficulty": "easy", "question": "What does the 'terraform init' command do?", "ground_truth": "The 'terraform init' command initializes a Terraform working directory by downloading and installing required provider plugins and setting up the backend for state management.", "source": "terraform_init"}
{"id": "te_007", "domain": "terraform_expert", "difficulty": "easy", "question": "What is the purpose of the 'terraform plan' command?", "ground_truth": "The 'terraform plan' command creates an execution plan showing what changes Terraform will make to infrastructure without actually applying them, allowing review before deployment.", "source": "terraform_plan"}
{"id": "te_008", "domain": "terraform_expert", "difficulty": "easy", "question": "What does the 'terraform apply' command do?", "ground_truth": "The 'terraform apply' command executes the planned infrastructure changes by provisioning or modifying resources according to the Terraform configuration and current state.", "source": "terraform_apply"}
{"id": "te_009", "domain": "terraform_expert", "difficulty": "easy", "question": "What is a Terraform module and what is its basic purpose?", "ground_truth": "A Terraform module is a directory containing Terraform configuration files that encapsulates reusable infrastructure components, allowing code organization, reusability, and abstraction.", "source": "modules"}
{"id": "te_010", "domain": "terraform_expert", "difficulty": "easy", "question": "What are Terraform variables and how are they defined?", "ground_truth": "Terraform variables are input parameters that allow dynamic configuration values to be passed into Terraform configurations. They are defined using the 'variable' block in .tf files.", "source": "variables"}
{"id": "te_011", "domain": "terraform_expert", "difficulty": "easy", "question": "What is a Terraform output and what is its primary use?", "ground_truth": "A Terraform output is a value exported from a Terraform configuration using the 'output' block, used to display important resource attributes or pass values to other configurations.", "source": "outputs"}
{"id": "te_012", "domain": "terraform_expert", "difficulty": "easy", "question": "What is a Terraform provider?", "ground_truth": "A Terraform provider is a plugin that enables interaction with specific cloud platforms or services. It defines resource types and data sources available for that platform.", "source": "providers"}
{"id": "te_013", "domain": "terraform_expert", "difficulty": "easy", "question": "What is the purpose of the '.gitignore' file in a Terraform project?", "ground_truth": "The .gitignore file prevents sensitive files like terraform.tfstate, terraform.tfvars, and the .terraform directory from being committed to version control systems.", "source": "version_control"}
{"id": "te_014", "domain": "terraform_expert", "difficulty": "easy", "question": "What does 'terraform destroy' do?", "ground_truth": "The 'terraform destroy' command removes all infrastructure resources managed by Terraform, as defined in the current state file and configuration.", "source": "terraform_destroy"}
{"id": "te_015", "domain": "terraform_expert", "difficulty": "easy", "question": "What is remote state in Terraform and why is it used?", "ground_truth": "Remote state stores the terraform.tfstate file on a remote backend (like S3, Terraform Cloud) instead of locally, enabling team collaboration and reducing state file loss risks.", "source": "remote_state"}
{"id": "te_016", "domain": "terraform_expert", "difficulty": "easy", "question": "What is the difference between a resource and a data source in Terraform?", "ground_truth": "A resource creates and manages infrastructure components, while a data source reads information about existing infrastructure without creating or modifying it.", "source": "resources_datasources"}
{"id": "te_017", "domain": "terraform_expert", "difficulty": "easy", "question": "What is a Terraform backend?", "ground_truth": "A Terraform backend determines how and where state is stored and retrieved. Common backends include local, S3, Azure Storage, Google Cloud Storage, and Terraform Cloud.", "source": "backends"}
{"id": "te_018", "domain": "terraform_expert", "difficulty": "easy", "question": "What is the purpose of the 'terraform fmt' command?", "ground_truth": "The 'terraform fmt' command automatically formats Terraform configuration files to comply with standard HCL style conventions, improving code readability and consistency.", "source": "terraform_fmt"}
{"id": "te_019", "domain": "terraform_expert", "difficulty": "easy", "question": "What does the 'terraform validate' command check?", "ground_truth": "The 'terraform validate' command checks the syntax and structure of Terraform configuration files to ensure they are valid, without requiring provider authentication.", "source": "terraform_validate"}
{"id": "te_020", "domain": "terraform_expert", "difficulty": "easy", "question": "What is interpolation syntax in Terraform and provide a basic example.", "ground_truth": "Interpolation syntax allows referencing values from variables, resources, and data sources using ${} notation. Example: ${aws_instance.web.id} references an EC2 instance's ID attribute.", "source": "interpolation"}
{"id": "te_021", "domain": "terraform_expert", "difficulty": "medium", "question": "How does Terraform handle implicit dependencies versus explicit dependencies, and when would you use each?", "ground_truth": "Implicit dependencies are inferred from resource references (e.g., using another resource's ID), while explicit dependencies use the 'depends_on' argument. Use implicit dependencies for automatic ordering; use explicit dependencies when Terraform cannot detect resource relationships but one must be created before another.", "source": "dependencies_and_ordering"}
{"id": "te_022", "domain": "terraform_expert", "difficulty": "medium", "question": "What is the purpose of the terraform.tfstate file and why should it never be stored in version control?", "ground_truth": "The tfstate file stores the current state of managed infrastructure resources and their attributes. It should not be in version control because it contains sensitive data (passwords, API keys) and creates merge conflicts; instead, use remote state backends like S3, Terraform Cloud, or Consul.", "source": "state_management"}
{"id": "te_023", "domain": "terraform_expert", "difficulty": "medium", "question": "Explain the difference between count and for_each meta-arguments and describe a scenario where one is preferable to the other.", "ground_truth": "count uses numerical indices (0, 1, 2...) and is suitable for creating identical resources; for_each uses a map/set with meaningful keys and is preferable when you need stable, predictable keys and better readability. Use for_each when resource order matters or elements are removed from the middle.", "source": "meta_arguments"}
{"id": "te_024", "domain": "terraform_expert", "difficulty": "medium", "question": "What is a Terraform module and how does variable passing work between parent and child modules?", "ground_truth": "A module is a reusable container of Terraform configurations. Parent modules pass values to child modules via input variables defined in the child's variables.tf, and child modules expose outputs via outputs.tf that parent modules can reference using module.module_name.output_name.", "source": "modules"}
{"id": "te_025", "domain": "terraform_expert", "difficulty": "medium", "question": "How do workspaces function in Terraform, and what are the limitations of using them for environment management?", "ground_truth": "Workspaces allow multiple state files within a single configuration directory, selected via 'terraform workspace select'. However, they share the same Terraform code, making it risky for environment isolation; separate directories or modules with different backends are more robust for true environment separation.", "source": "workspaces"}
{"id": "te_026", "domain": "terraform_expert", "difficulty": "medium", "question": "Describe the purpose of the terraform validate command and how it differs from terraform plan.", "ground_truth": "terraform validate checks syntax and structural correctness without accessing remote APIs or requiring a backend; terraform plan connects to the backend, compares current state to desired configuration, and shows what changes will occur. Validate is faster and runs earlier in CI/CD pipelines.", "source": "terraform_commands"}
{"id": "te_027", "domain": "terraform_expert", "difficulty": "medium", "question": "What are data sources in Terraform and how do they differ from resources?", "ground_truth": "Data sources fetch information about existing infrastructure without managing it, while resources create, modify, or destroy infrastructure. Data sources are read-only and useful for referencing existing cloud resources (e.g., AMIs, VPCs) that aren't managed by Terraform.", "source": "data_sources"}
{"id": "te_028", "domain": "terraform_expert", "difficulty": "medium", "question": "How does the -target flag work in Terraform and what are the risks of using it in production?", "ground_truth": "The -target flag narrows operations to specific resources, useful for debugging or partial deployments. Risks include bypassing dependency checks, creating inconsistent state, and obscuring the full impact of changes, potentially breaking dependent resources.", "source": "terraform_flags"}
{"id": "te_029", "domain": "terraform_expert", "difficulty": "medium", "question": "Explain how Terraform handles sensitive data and what the sensitive = true argument does.", "ground_truth": "Setting sensitive = true on a variable or output prevents its value from displaying in CLI output or logs, masking it with '<sensitive>'. However, it's stored unencrypted in state files; encryption at rest requires backend-specific features or external secret management tools.", "source": "security_and_sensitive_data"}
{"id": "te_030", "domain": "terraform_expert", "difficulty": "medium", "question": "What is a Terraform provider and how does version pinning work for providers?", "ground_truth": "A provider is a plugin that interfaces with cloud APIs (AWS, Azure, GCP, etc.). Version pinning uses the required_providers block to specify exact versions (e.g., version = \"~> 5.0\"); tilde-greater (>=5.0, <6.0) allows patch updates, while = locks to exact versions.", "source": "providers"}
{"id": "te_031", "domain": "terraform_expert", "difficulty": "medium", "question": "How does Terraform's refresh operation work and when might you need to use terraform refresh?", "ground_truth": "terraform refresh updates the local state file to match the current real-world infrastructure without making changes. Use it when external changes occur outside Terraform (manual modifications) or when state becomes stale, but it's included in terraform plan by default.", "source": "state_operations"}
{"id": "te_032", "domain": "terraform_expert", "difficulty": "medium", "question": "Explain the difference between locals and variables in Terraform and provide an example of when to use each.", "ground_truth": "Variables are input values provided at runtime (via CLI, files, or environment); locals are fixed computed values within a module. Use variables for configuration that changes between deployments; use locals for derived values or repeated expressions to reduce duplication.", "source": "variables_and_locals"}
{"id": "te_033", "domain": "terraform_expert", "difficulty": "medium", "question": "What are provisioners in Terraform and why are they generally discouraged in favor of other approaches?", "ground_truth": "Provisioners execute actions on local or remote machines (e.g., running scripts). They're discouraged because they add complexity, are harder to debug, can mask configuration issues, and break idempotency; user_data, cloud-init, or configuration management tools are preferred.", "source": "provisioners"}
{"id": "te_034", "domain": "terraform_expert", "difficulty": "medium", "question": "How does Terraform determine resource naming conflicts and what happens when you rename a resource in code?", "ground_truth": "Terraform uses the resource type and logical name (e.g., aws_instance.web) as the unique identifier in state. Renaming in code without moving state causes Terraform to treat it as a deletion and new creation; use 'terraform state mv' to rename safely.", "source": "state_management"}
{"id": "te_035", "domain": "terraform_expert", "difficulty": "medium", "question": "What is the purpose of a .terraform.lock.hcl file and how does it affect reproducibility?", "ground_truth": "The lock file records exact provider and module versions used, ensuring consistent deployments across environments and team members. It should be committed to version control to guarantee reproducibility and prevent unexpected version upgrades.", "source": "dependency_lock"}
{"id": "te_036", "domain": "terraform_expert", "difficulty": "medium", "question": "How do you reference attributes from a resource created with count or for_each in Terraform?", "ground_truth": "With count: resource_type.name[0].attribute or resource_type.name[*].attribute for all. With for_each: resource_type.name[key].attribute. Using splat syntax with for_each (for_each uses maps) requires converting to a list first.", "source": "meta_arguments"}
{"id": "te_037", "domain": "terraform_expert", "difficulty": "medium", "question": "Explain conditional logic in Terraform using the ternary operator and provide a practical example.", "ground_truth": "The ternary operator uses the syntax: condition ? true_value : false_value. Example: var.environment == 'prod' ? 't3.large' : 't3.micro' selects instance type based on environment, allowing dynamic resource configuration.", "source": "expressions_and_conditionals"}
{"id": "te_038", "domain": "terraform_expert", "difficulty": "medium", "question": "What is a backend in Terraform and why would you choose a remote backend over local state?", "ground_truth": "A backend stores state remotely (S3, Terraform Cloud, Consul, etc.) instead of locally. Remote backends enable team collaboration, state locking to prevent concurrent modifications, encryption at rest, and centralized management of infrastructure state.", "source": "backends"}
{"id": "te_039", "domain": "terraform_expert", "difficulty": "medium", "question": "How does the lifecycle block work in Terraform and describe a use case for create_before_destroy?", "ground_truth": "The lifecycle block manages resource creation and destruction behavior. create_before_destroy = true creates the new resource before destroying the old one, useful for zero-downtime deployments of load-balanced services or databases requiring continuous availability.", "source": "lifecycle_rules"}
{"id": "te_040", "domain": "terraform_expert", "difficulty": "medium", "question": "Explain the terraform import command and what limitations exist when importing existing infrastructure.", "ground_truth": "terraform import brings existing cloud resources into Terraform state without creating them, updating state only. Limitations include: provider must support the resource type, manual configuration code writing is required, some attributes may not be importable, and relationships aren't automatically established.", "source": "terraform_import"}
{"id": "te_041", "domain": "terraform_expert", "difficulty": "hard", "question": "When using Terraform with remote state stored in S3 with DynamoDB locking, what race condition can occur if the DynamoDB table lacks a TTL policy, and how does this affect concurrent operations?", "ground_truth": "Without TTL, abandoned locks from crashed operations persist indefinitely, causing subsequent operations to fail with lock acquisition timeouts. This requires manual intervention to remove stale locks via the DynamoDB console or AWS CLI, blocking legitimate state modifications and breaking automation pipelines.", "source": "remote_state_locking"}
{"id": "te_042", "domain": "terraform_expert", "difficulty": "hard", "question": "Explain the implications of using `depends_on` with implicit dependencies already detected by Terraform's resource graph analysis, and when this creates technical debt.", "ground_truth": "Redundant explicit `depends_on` declarations obscure the actual dependency graph, making code harder to refactor and maintain. They can mask implicit dependencies that should be expressed through resource references, reducing code clarity and increasing the risk of introducing circular dependencies during future modifications.", "source": "dependency_management"}
{"id": "te_043", "domain": "terraform_expert", "difficulty": "hard", "question": "How does Terraform's `replace_triggered_by` meta-argument differ from using `triggers` in `null_resource`, and what performance impact does this choice have on large-scale infrastructure?", "ground_truth": "`replace_triggered_by` is a native, built-in mechanism that directly tracks resource attributes and causes recreation, while `null_resource` with triggers is a workaround requiring additional resources. The native approach has lower overhead, clearer intent, and avoids polluting the state with dummy resources, making it superior for performance and maintainability at scale.", "source": "resource_lifecycle"}
{"id": "te_044", "domain": "terraform_expert", "difficulty": "hard", "question": "When applying Terraform with `-parallelism=1` due to API rate limiting, what hidden costs does this introduce in terms of state consistency and operation duration?", "ground_truth": "Sequential execution exponentially increases total operation time and extends the window during which state can diverge from actual infrastructure. It also increases the risk of timeout failures for long-running operations and reduces the ability to detect and correct drift in parallel, potentially masking infrastructure inconsistencies.", "source": "performance_tuning"}
{"id": "te_045", "domain": "terraform_expert", "difficulty": "hard", "question": "Describe how `terraform console` interacts with state and variables, and what security risks exist when using it in production environments with sensitive data.", "ground_truth": "`terraform console` loads the current state and variables into memory, allowing interactive querying and evaluation of expressions. In production, this exposes sensitive values (passwords, API keys, PII) in the REPL session, shell history, and memory dumps, creating audit compliance violations and credential exposure risks if not strictly controlled.", "source": "state_security"}
{"id": "te_046", "domain": "terraform_expert", "difficulty": "hard", "question": "What happens to `output` values when using `terraform destroy` with outputs that reference destroyed resources, and how should this be handled in automated pipelines?", "ground_truth": "Outputs referencing destroyed resources will fail or return null/empty values during destroy. To prevent pipeline failures, use `sensitive = true` or conditional logic, or store critical outputs in external systems before destroy. This prevents broken dependencies in automation that relies on output values post-destruction.", "source": "output_management"}
{"id": "te_047", "domain": "terraform_expert", "difficulty": "hard", "question": "Explain the difference between `count.index` and `for_each` when recovering from a provider failure mid-apply, and why one approach is inherently safer for partial recovery.", "ground_truth": "`for_each` with map keys is safer because it uses stable, explicit identifiers that don't shift when items are added or removed, preserving resource identity across partial failures. `count.index` relies on array position, causing index misalignment if elements change, leading to incorrect resource mapping and potential data loss during recovery.", "source": "iteration_safety"}
{"id": "te_048", "domain": "terraform_expert", "difficulty": "hard", "question": "How does Terraform's `moved` block interact with `for_each` migrations, and what state validation must occur before applying such changes in production?", "ground_truth": "The `moved` block tracks resource refactoring to prevent unintended destruction and recreation. Before applying migrations with `for_each`, validate with `terraform plan`, verify no resource conflicts exist, backup state, and perform a dry-run on non-production first. Failures can cause resource churn and service disruption if the state mapping is incorrect.", "source": "refactoring_safety"}
{"id": "te_049", "domain": "terraform_expert", "difficulty": "hard", "question": "What are the architectural trade-offs between using a single monolithic root module versus multiple specialized modules with shared state, and how does this impact drift detection?", "ground_truth": "Monolithic modules offer atomic consistency but reduce reusability and increase blast radius for failures. Multiple modules improve isolation and reusability but require careful state management and explicit dependencies. Multi-module setups complicate drift detection since changes in one module may not trigger updates in dependent modules, requiring careful orchestration.", "source": "module_architecture"}
{"id": "te_050", "domain": "terraform_expert", "difficulty": "hard", "question": "When implementing a disaster recovery strategy using `terraform import`, what issues arise with importing large resource counts, and how should batch importing be structured?", "ground_truth": "Importing hundreds of resources sequentially is slow and error-prone; state file corruption can occur if the import fails mid-operation. Batch importing should use scripting with error handling, import to a temporary state file first, validate consistency, then merge. Large imports should be parallelized where possible and monitored for provider API rate limits and state locking contention.", "source": "disaster_recovery_import"}
