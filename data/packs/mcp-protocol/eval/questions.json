[
  {
    "id": "mp_001",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What is the underlying protocol that the Model Context Protocol is based on?",
    "ground_truth": "The Model Context Protocol is based on JSON-RPC 2.0, which is a stateless, lightweight remote procedure call protocol that uses JSON for encoding messages.",
    "source": "mcp_specification"
  },
  {
    "id": "mp_002",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "Name two official SDK implementations provided for MCP server development.",
    "ground_truth": "The two official SDK implementations are the Python SDK and the TypeScript SDK, which provide libraries and tools for building MCP-compliant servers.",
    "source": "server_development"
  },
  {
    "id": "mp_003",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What is the primary purpose of tool definitions in the MCP?",
    "ground_truth": "Tool definitions specify executable functions that the LLM can call to perform actions or retrieve information from external systems, including their name, description, and input schema.",
    "source": "tool_definitions"
  },
  {
    "id": "mp_004",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What mechanism does MCP use to expose data sources to clients?",
    "ground_truth": "MCP uses resource handlers that expose data sources through URI-based access, allowing clients to request and retrieve resources in a standardized way.",
    "source": "resource_handlers"
  },
  {
    "id": "mp_005",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What are prompt templates in the MCP context?",
    "ground_truth": "Prompt templates are reusable patterns for LLM interactions that can be defined and managed by MCP servers, enabling consistent and structured communication between clients and language models.",
    "source": "prompt_templates"
  },
  {
    "id": "mp_006",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What is sampling in the MCP protocol?",
    "ground_truth": "Sampling refers to server-initiated completions, where an MCP server can request the client to generate LLM completions based on specific prompts or contexts defined by the server.",
    "source": "sampling"
  },
  {
    "id": "mp_007",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "List three transport protocols supported by MCP for communication.",
    "ground_truth": "Three supported transport protocols are stdio (standard input/output), Streamable HTTP (bidirectional streaming over HTTP), and SSE (Server-Sent Events).",
    "source": "transport_setup"
  },
  {
    "id": "mp_008",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What are the main phases of the MCP lifecycle?",
    "ground_truth": "The main phases are initialization (handshake and exchange of capabilities), capability negotiation (agreeing on supported features and tools), and shutdown (graceful termination of the connection).",
    "source": "lifecycle_management"
  },
  {
    "id": "mp_009",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "Name one security best practice for MCP server implementations.",
    "ground_truth": "Input validation is a critical security best practice that ensures all incoming data from clients is checked for correctness and safety before processing.",
    "source": "security_best_practices"
  },
  {
    "id": "mp_010",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What is the purpose of authorization in MCP security?",
    "ground_truth": "Authorization ensures that clients and users only have access to the tools, resources, and operations they are permitted to use, preventing unauthorized access to sensitive data or functions.",
    "source": "security_best_practices"
  },
  {
    "id": "mp_011",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What are roots in the context of MCP client features?",
    "ground_truth": "Roots define the base directories or URIs that MCP clients can access for resources, establishing boundaries for resource discovery and access within the MCP system.",
    "source": "client_features"
  },
  {
    "id": "mp_012",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What is elicitation in MCP client features?",
    "ground_truth": "Elicitation is a client feature that enables the discovery and enumeration of available tools, resources, and prompts offered by an MCP server.",
    "source": "client_features"
  },
  {
    "id": "mp_013",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What does stdio transport mean in the context of MCP?",
    "ground_truth": "Stdio transport uses standard input and standard output streams to communicate between MCP clients and servers, making it suitable for local process-to-process communication.",
    "source": "transport_setup"
  },
  {
    "id": "mp_014",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What information does a tool definition typically include?",
    "ground_truth": "A tool definition typically includes the tool name, human-readable description, input schema (parameters and their types), and optionally example usage or additional metadata.",
    "source": "tool_definitions"
  },
  {
    "id": "mp_015",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "Why would an MCP server initiate a sampling request?",
    "ground_truth": "An MCP server initiates sampling to request the client to generate LLM completions for specific tasks, such as processing user input, generating text, or analyzing data within a server-defined context.",
    "source": "sampling"
  },
  {
    "id": "mp_016",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What is the advantage of using resource handlers in MCP?",
    "ground_truth": "Resource handlers provide a standardized, URI-based mechanism for exposing and accessing diverse data sources, enabling flexible integration of external data into LLM-driven applications.",
    "source": "resource_handlers"
  },
  {
    "id": "mp_017",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What occurs during the capability negotiation phase of MCP?",
    "ground_truth": "During capability negotiation, the client and server exchange information about their supported features, tools, resource types, and protocols, establishing a common understanding of available functionality.",
    "source": "lifecycle_management"
  },
  {
    "id": "mp_018",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "How does input validation contribute to MCP security?",
    "ground_truth": "Input validation prevents malicious or malformed data from being processed by checking that all incoming data conforms to expected formats, types, and constraints before execution.",
    "source": "security_best_practices"
  },
  {
    "id": "mp_019",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What is the primary difference between stdio and SSE transport in MCP?",
    "ground_truth": "Stdio transport uses standard input/output streams for bidirectional communication in local processes, while SSE (Server-Sent Events) is a unidirectional protocol primarily for pushing server events to web clients over HTTP.",
    "source": "transport_setup"
  },
  {
    "id": "mp_020",
    "domain": "mcp_protocol",
    "difficulty": "easy",
    "question": "What does initialization in the MCP lifecycle involve?",
    "ground_truth": "Initialization involves the handshake between client and server, where protocol versions are confirmed and each party communicates its name, version, and initial capabilities to establish a working connection.",
    "source": "lifecycle_management"
  },
  {
    "id": "mp_021",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "Why is JSON-RPC 2.0 used as the foundation for MCP, and what specific advantage does it provide for LLM tool integration compared to REST APIs?",
    "ground_truth": "JSON-RPC 2.0 provides bidirectional, asynchronous communication which allows servers to initiate requests to clients (e.g., sampling requests). REST APIs are unidirectional request-response only, making them unsuitable for server-initiated completions and real-time capability negotiation.",
    "source": "mcp_specification"
  },
  {
    "id": "mp_022",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "Describe the difference between tool definitions and resource handlers in MCP, and explain when you would use each one.",
    "ground_truth": "Tool definitions represent executable functions that perform actions and return results\u2014they are called by the LLM to accomplish tasks. Resource handlers expose data via URIs for the LLM to read; they provide access to information without performing actions. Use tools for dynamic operations and resource handlers for data retrieval.",
    "source": "tool_definitions_and_resources"
  },
  {
    "id": "mp_023",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "What is the purpose of the capability negotiation phase in MCP lifecycle management, and what happens if a client requests a capability the server does not support?",
    "ground_truth": "Capability negotiation occurs during initialization to establish which features both client and server support. If a client requests an unsupported capability, the server should return an error or decline the feature, allowing graceful degradation rather than silent failure.",
    "source": "lifecycle_management"
  },
  {
    "id": "mp_024",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "Compare stdio and Streamable HTTP as transport mechanisms for MCP. What are the trade-offs in terms of deployment complexity and real-time bidirectional communication?",
    "ground_truth": "Stdio is simpler for local/containerized deployments and supports full bidirectional communication naturally. Streamable HTTP requires more infrastructure but enables remote communication; however, HTTP/1.1 streaming can have latency issues, whereas HTTP/2 or SSE provides better bidirectional capability.",
    "source": "transport_setup"
  },
  {
    "id": "mp_025",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "Explain how input validation in MCP servers prevents security vulnerabilities when exposing tool definitions to LLMs.",
    "ground_truth": "Input validation ensures that parameters passed to tools match expected types, formats, and constraints before execution. This prevents injection attacks, resource exhaustion, and unauthorized operations by rejecting malformed or suspicious inputs at the server boundary.",
    "source": "security_best_practices"
  },
  {
    "id": "mp_026",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "What is sampling in the context of MCP, and why would a server initiate a sampling request to a client?",
    "ground_truth": "Sampling is a mechanism where an MCP server requests LLM completions from the client. A server uses sampling to generate dynamic responses, format data intelligently, or make decisions based on LLM reasoning without having the LLM directly invoke a tool.",
    "source": "sampling"
  },
  {
    "id": "mp_027",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "How do prompt templates in MCP improve consistency and reusability compared to embedding prompt instructions directly in tool definitions?",
    "ground_truth": "Prompt templates are reusable, server-defined patterns that the client can invoke. This separates prompt logic from tool logic, allows version control of prompts independently, enables context injection, and ensures consistent LLM interaction patterns across multiple tools.",
    "source": "prompt_templates"
  },
  {
    "id": "mp_028",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "What is the role of authorization in MCP server security, and how should a server determine whether a client has permission to call a specific tool?",
    "ground_truth": "Authorization controls which clients can access which resources. A server should implement access control checks before executing any tool, possibly using credentials passed during initialization, authentication tokens, or predefined access policies based on the client identity.",
    "source": "security_best_practices"
  },
  {
    "id": "mp_029",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "Explain the difference between the Python SDK and TypeScript SDK for MCP server development, and discuss scenarios where each might be preferred.",
    "ground_truth": "The Python SDK is suitable for data science, ML, and script-heavy integrations; TypeScript SDK is better for Node.js environments and JavaScript ecosystems. Choice depends on existing codebase language, ecosystem libraries needed, and deployment environment compatibility.",
    "source": "server_development"
  },
  {
    "id": "mp_030",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "How do roots in MCP client configuration affect resource discovery, and what happens if a client specifies a root that the server does not recognize?",
    "ground_truth": "Roots define the base paths or namespaces for resource access in the client. If a client specifies an unknown root, the server typically returns an error or ignores it, preventing access to resources under that root; this ensures scoping and prevents unauthorized resource exposure.",
    "source": "client_features"
  },
  {
    "id": "mp_031",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "Describe how elicitation works in MCP and why it is important for generating contextually relevant tool invocations.",
    "ground_truth": "Elicitation is the process of prompting or suggesting to the LLM which tools or resources might be relevant in a given context. It helps guide the LLM toward appropriate tool selection without forcing it, improving accuracy and reducing irrelevant function calls.",
    "source": "client_features"
  },
  {
    "id": "mp_032",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "In an MCP server, how would you implement a resource handler that exposes file system data safely without allowing path traversal attacks?",
    "ground_truth": "Implement validation to normalize and restrict URIs to allowed directories using canonical path resolution. Reject relative paths like '../' and validate that resolved paths remain within the allowed root directory, preventing access to unintended files.",
    "source": "resource_handlers"
  },
  {
    "id": "mp_033",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "What are the lifecycle states of an MCP connection, and what must happen during initialization before tools can be invoked?",
    "ground_truth": "MCP lifecycle includes connection establishment, initialization (handshake and capability negotiation), active tool/resource serving, and shutdown. Before tools are invoked, both client and server must complete initialization and agree on supported capabilities.",
    "source": "lifecycle_management"
  },
  {
    "id": "mp_034",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "Explain the trade-offs between defining many fine-grained tools versus fewer coarse-grained tools in an MCP server.",
    "ground_truth": "Fine-grained tools give the LLM precise control and flexibility but increase complexity and decision-making overhead. Coarse-grained tools reduce choices and are simpler but limit LLM precision and may require passing more parameters, affecting usability and accuracy.",
    "source": "tool_definitions_and_resources"
  },
  {
    "id": "mp_035",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "How does SSE (Server-Sent Events) improve upon traditional HTTP for MCP transport, and what are its limitations?",
    "ground_truth": "SSE provides server-to-client streaming over HTTP without polling, enabling real-time updates and reducing latency. Limitations include unidirectional communication (client must use separate HTTP requests to send data) and potential issues with proxies/firewalls that buffer streams.",
    "source": "transport_setup"
  },
  {
    "id": "mp_036",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "Describe how prompt templates can be parameterized in MCP to inject runtime context while maintaining security.",
    "ground_truth": "Prompt templates should use placeholders or variable substitution for dynamic content. Parameterization must sanitize inputs to prevent prompt injection attacks, and templates should be defined server-side to prevent clients from injecting arbitrary instructions into prompts.",
    "source": "prompt_templates"
  },
  {
    "id": "mp_037",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "In the context of MCP server development with the Python SDK, what is the purpose of implementing error handling for tool execution, and what information should be included in error responses?",
    "ground_truth": "Error handling ensures graceful failure and provides feedback to the client. Error responses should include error codes, human-readable messages, and optional details about the failure cause, enabling proper client-side handling and debugging without exposing sensitive internal information.",
    "source": "server_development"
  },
  {
    "id": "mp_038",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "How should an MCP server handle rate limiting or resource exhaustion to prevent denial-of-service attacks without rejecting legitimate requests?",
    "ground_truth": "Implement rate limiting per client or globally with configurable thresholds, queue requests during spikes, return rate-limit error codes with retry-after headers, and monitor resource usage. Distinguish between normal load and abuse patterns using metrics.",
    "source": "security_best_practices"
  },
  {
    "id": "mp_039",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "Explain how resource URIs in MCP enable flexible data exposure, and what naming scheme best supports client discovery and scalability.",
    "ground_truth": "Resource URIs act as identifiers for data sources, allowing servers to expose diverse data types uniformly. A hierarchical naming scheme (e.g., 'database://schema/table', 'file://docs/manual') improves discoverability, enables filtering, and makes client-side logic scalable.",
    "source": "resource_handlers"
  },
  {
    "id": "mp_040",
    "domain": "mcp_protocol",
    "difficulty": "medium",
    "question": "What considerations should guide the decision to implement a tool versus a resource in an MCP server when functionality could be done either way?",
    "ground_truth": "Use tools for operations that change state, have side effects, require complex logic, or need user confirmation. Use resources for read-only data access, lookups, or information retrieval. If data must be accessed multiple times efficiently, resources are preferable; if actions must be performed, use tools.",
    "source": "tool_definitions_and_resources"
  },
  {
    "id": "mp_041",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "When implementing an MCP server using the Python SDK, how should you handle concurrent tool invocations that depend on shared mutable state, and what are the implications for the JSON-RPC 2.0 message ordering guarantee?",
    "ground_truth": "MCP servers should implement thread-safe mechanisms (locks, queues, or async/await patterns) around shared state since JSON-RPC 2.0 doesn't guarantee message ordering across concurrent requests. The server must ensure that tool execution serialization doesn't block other concurrent operations, typically using async Python patterns with proper context isolation per request.",
    "source": "server_development_concurrency"
  },
  {
    "id": "mp_042",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "Explain the security implications of exposing resources via URI handlers in MCP and how you would implement authorization to prevent unauthorized resource access across different client sessions.",
    "ground_truth": "Resource URIs can be exploited for directory traversal or unauthorized data access if not properly validated. Authorization should be enforced at the resource handler level using session tokens, capability-based access control, or cryptographic signatures embedded in URIs. Each client session should have isolated permissions enforced through the server's initialization handshake.",
    "source": "resource_handlers_security"
  },
  {
    "id": "mp_043",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "In a production MCP deployment using SSE transport, what are the performance bottlenecks when handling high-frequency sampling requests initiated by the server, and how would you optimize for latency-sensitive applications?",
    "ground_truth": "SSE transport serializes responses sequentially, creating head-of-line blocking for rapid sampling requests. Optimization strategies include: batching multiple completion requests, implementing server-side request prioritization, using HTTP/2 multiplexing where possible, and considering stdio or Streamable HTTP for lower-latency bidirectional communication in latency-critical scenarios.",
    "source": "sampling_transport_optimization"
  },
  {
    "id": "mp_044",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "How would you design an MCP server that safely delegates tool execution to untrusted external processes while maintaining security and preventing resource exhaustion attacks?",
    "ground_truth": "Implement sandboxing with resource limits (CPU, memory, timeout) using OS-level isolation (containers, seccomp) or language-level restrictions. Validate all tool inputs using strict allowlists, separate privilege levels for tool invocation, and implement circuit breakers to prevent cascading failures. Monitor resource consumption per tool and enforce quotas.",
    "source": "tool_definitions_security"
  },
  {
    "id": "mp_045",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "When capability negotiation fails during MCP initialization, what specific fields in the server capabilities response should be examined to diagnose incompatibility, and how would you implement graceful degradation?",
    "ground_truth": "Inspect the capabilities response for mismatches in: supported protocol versions, transport types, available tools, resource URI schemes, and prompt template formats. Implement graceful degradation by maintaining a baseline feature set (e.g., core tools only), offering alternative transport mechanisms, or returning a negotiation error with detailed capability requirements to guide client adaptation.",
    "source": "lifecycle_management_initialization"
  },
  {
    "id": "mp_046",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "Describe a scenario where a Streamable HTTP transport configuration creates deadlock conditions in request/response cycles, and explain how to detect and prevent it.",
    "ground_truth": "Deadlock occurs when a server-initiated sampling request awaits a client response while the client simultaneously awaits server completion for a tool invocation on the same connection. Prevent this by: using separate logical channels for bidirectional messaging, implementing request IDs to correlate async responses, setting aggressive timeouts, or switching to full-duplex transports like stdio.",
    "source": "transport_setup_streamable_http"
  },
  {
    "id": "mp_047",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "How should you version and evolve prompt templates in an MCP server to maintain backward compatibility while introducing new template variables that older clients cannot interpret?",
    "ground_truth": "Use semantic versioning for template schemas and include a 'template_version' field in each prompt definition. Old clients should gracefully ignore unknown variables (fail-safe defaults), while new clients can request template versions via capability negotiation. Maintain template registries that map versions to implementations and provide migration guides.",
    "source": "prompt_templates_versioning"
  },
  {
    "id": "mp_048",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "In TypeScript SDK, how would you implement a tool definition that accepts complex nested JSON Schema structures as input and ensure runtime validation doesn't introduce significant latency for high-throughput tool invocations?",
    "ground_truth": "Use precompiled JSON Schema validators (e.g., Ajv with code generation) rather than runtime compilation. Cache validator instances at tool initialization time. For performance-critical tools, implement schema caching strategies and consider lazy validation for deeply nested structures. Profile validator performance using benchmarks and offload heavy validation to worker threads if needed.",
    "source": "tool_definitions_json_schema"
  },
  {
    "id": "mp_049",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "Explain how 'roots' in MCP client features function and why they are critical for resource discovery and sandboxing. What happens if a server exposes resources outside the declared roots?",
    "ground_truth": "Roots define the filesystem boundaries and data scopes that clients are authorized to access. They act as sandbox boundaries\u2014resources outside declared roots should be rejected by compliant servers. Roots enable clients to implement least-privilege access policies and help prevent directory traversal attacks. Non-compliance can lead to unauthorized data exposure.",
    "source": "client_features_roots"
  },
  {
    "id": "mp_050",
    "domain": "mcp_protocol",
    "difficulty": "hard",
    "question": "Design a strategy for implementing input validation in an MCP server that prevents both common injection attacks (SQL, command injection) and MCP-specific attacks (JSON-RPC protocol manipulation, resource URI exploitation). What validation layers would you implement?",
    "ground_truth": "Implement multi-layered validation: (1) JSON Schema validation at protocol level for all messages, (2) whitelist-based input sanitization for tool arguments, (3) parameterized queries/commands to prevent injection, (4) URI normalization and path canonicalization for resource handlers, (5) rate limiting and request signature verification. Each layer targets different attack vectors specific to MCP's JSON-RPC architecture.",
    "source": "security_input_validation"
  }
]
