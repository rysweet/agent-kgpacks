{"id": "pe_001", "domain": "python_expert", "difficulty": "easy", "question": "What is the primary purpose of the match/case statement introduced in Python 3.10 (PEP 636)?", "ground_truth": "The match/case statement provides structural pattern matching, allowing you to match complex data structures and destructure them in a single expression, replacing multiple if/elif chains with more readable and expressive code.", "source": "structural_pattern_matching_pep636"}
{"id": "pe_002", "domain": "python_expert", "difficulty": "easy", "question": "In Python 3.12+, what syntax does PEP 695 introduce for defining type parameters?", "ground_truth": "PEP 695 introduces the `type` statement syntax for defining type parameters, allowing you to write `type Point = tuple[float, float]` instead of using TypeVar with class definitions.", "source": "modern_typing_pep695"}
{"id": "pe_003", "domain": "python_expert", "difficulty": "easy", "question": "What does the Self type (PEP 673) allow you to do in method signatures?", "ground_truth": "The Self type allows methods to reference the enclosing class without explicitly naming it, enabling proper type hints for methods that return instances of the same class, which is especially useful for subclasses.", "source": "self_type_pep673"}
{"id": "pe_004", "domain": "python_expert", "difficulty": "easy", "question": "What is the main advantage of using dataclasses with the slots=True parameter?", "ground_truth": "Using slots=True in dataclasses reduces memory overhead by preventing the creation of __dict__ for instances and restricts attributes to only those defined in the dataclass.", "source": "dataclasses_slots"}
{"id": "pe_005", "domain": "python_expert", "difficulty": "easy", "question": "What does KW_ONLY do when used in a dataclass field definition?", "ground_truth": "KW_ONLY makes all fields following it keyword-only arguments in the generated __init__ method, requiring them to be passed by name rather than positionally.", "source": "dataclasses_kw_only"}
{"id": "pe_006", "domain": "python_expert", "difficulty": "easy", "question": "In Python 3.11+, what module is used to parse and manipulate TOML configuration files?", "ground_truth": "The tomllib module (part of the standard library) is used to parse TOML files, commonly used with pyproject.toml for modern Python project configuration.", "source": "packaging_tomllib"}
{"id": "pe_007", "domain": "python_expert", "difficulty": "easy", "question": "What is the purpose of asyncio.TaskGroup introduced in Python 3.11?", "ground_truth": "TaskGroup provides a context manager for managing multiple async tasks, automatically waiting for all tasks to complete and properly handling exceptions from any task in the group.", "source": "asyncio_taskgroup"}
{"id": "pe_008", "domain": "python_expert", "difficulty": "easy", "question": "What does functools.cache do differently from functools.lru_cache?", "ground_truth": "functools.cache provides unlimited caching with no size limit, while lru_cache has a configurable maximum size and evicts least-recently-used items when the cache is full.", "source": "functools_cache"}
{"id": "pe_009", "domain": "python_expert", "difficulty": "easy", "question": "What is the purpose of contextlib.suppress()?", "ground_truth": "contextlib.suppress() is a context manager that suppresses specified exceptions, allowing code to continue execution without raising an error when those exceptions occur.", "source": "contextlib_suppress"}
{"id": "pe_010", "domain": "python_expert", "difficulty": "easy", "question": "What does the pathlib module provide as an alternative to os.path?", "ground_truth": "pathlib provides an object-oriented interface to filesystem paths through the Path class, offering more intuitive path manipulation methods and cross-platform compatibility.", "source": "pathlib"}
{"id": "pe_011", "domain": "python_expert", "difficulty": "easy", "question": "What is the primary use case for collections.Counter?", "ground_truth": "collections.Counter is a dict subclass designed for counting hashable objects, providing convenient methods like most_common() to find the most frequent elements in an iterable.", "source": "collections_counter"}
{"id": "pe_012", "domain": "python_expert", "difficulty": "easy", "question": "How does collections.defaultdict differ from a regular dictionary?", "ground_truth": "defaultdict automatically creates default values for missing keys using a provided factory function, eliminating the need for KeyError exceptions or manual key checking.", "source": "collections_defaultdict"}
{"id": "pe_013", "domain": "python_expert", "difficulty": "easy", "question": "What does functools.partial do?", "ground_truth": "functools.partial creates a new callable by fixing some arguments of an existing function, allowing you to create specialized versions of functions with predetermined arguments.", "source": "functools_partial"}
{"id": "pe_014", "domain": "python_expert", "difficulty": "easy", "question": "What is the purpose of the @functools.wraps decorator?", "ground_truth": "functools.wraps copies metadata (name, docstring, annotations) from the original function to the wrapper function, preserving function identity and documentation.", "source": "functools_wraps"}
{"id": "pe_015", "domain": "python_expert", "difficulty": "easy", "question": "What does the per-interpreter GIL feature in Python 3.13 enable?", "ground_truth": "The per-interpreter GIL allows each Python interpreter instance to have its own GIL, enabling true parallelism when using multiple interpreters in the same process.", "source": "per_interpreter_gil"}
{"id": "pe_016", "domain": "python_expert", "difficulty": "easy", "question": "What is free-threaded CPython and when would you use it?", "ground_truth": "Free-threaded CPython is a build of Python without a GIL, allowing true multi-threaded parallelism; it is used when you need threads to run truly in parallel without GIL contention.", "source": "free_threaded_cpython"}
{"id": "pe_017", "domain": "python_expert", "difficulty": "easy", "question": "What does PEP 692 (TypedDict kwargs) allow you to do?", "ground_truth": "PEP 692 allows using TypedDict as **kwargs in function signatures with the Unpack operator, enabling type checking for keyword arguments that conform to a specific TypedDict structure.", "source": "typeddict_kwargs_pep692"}
{"id": "pe_018", "domain": "python_expert", "difficulty": "easy", "question": "What is the purpose of contextlib.asynccontextmanager?", "ground_truth": "contextlib.asynccontextmanager is a decorator that allows defining async context managers using async generators, similar to how contextmanager works for synchronous code.", "source": "contextlib_asynccontextmanager"}
{"id": "pe_019", "domain": "python_expert", "difficulty": "easy", "question": "What improvement do f-strings provide in Python 3.12+ for debugging?", "ground_truth": "Python 3.12+ f-strings support the `=` specifier for debugging, allowing `f'{variable=}'` to automatically print both the variable name and its value.", "source": "fstring_improvements"}
{"id": "pe_020", "domain": "python_expert", "difficulty": "easy", "question": "What does the @dataclass_transform decorator (PEP 681) indicate about a class?", "ground_truth": "The @dataclass_transform decorator signals to type checkers that a class behaves like a dataclass by auto-generating methods, allowing custom class factories to provide dataclass-like functionality with proper type hints.", "source": "dataclass_transform_pep681"}
{"id": "pe_021", "domain": "python_expert", "difficulty": "medium", "question": "In PEP 636 structural pattern matching, explain the difference between a class pattern with positional arguments versus a mapping pattern, and when you would use each.", "ground_truth": "Class patterns match positional attributes via __match_args__ or __dataclass_fields__, while mapping patterns match dictionary keys and work with dict-like objects. Use class patterns for structured objects (dataclasses, named tuples) and mapping patterns for dictionary-like data or when attribute order is unknown.", "source": "structural_pattern_matching_pep636"}
{"id": "pe_022", "domain": "python_expert", "difficulty": "medium", "question": "What is the purpose of PEP 695 type parameter syntax, and how does it improve upon the previous typing.TypeVar approach for generic types?", "ground_truth": "PEP 695 introduces a cleaner syntax using 'type' keyword and square brackets (e.g., 'type ListOrSet[T]') instead of scattered TypeVar declarations. It provides better scoping, readability, and allows type parameters to be locally bound within class/function definitions.", "source": "type_parameter_syntax_pep695"}
{"id": "pe_023", "domain": "python_expert", "difficulty": "medium", "question": "When should you use PEP 673 Self type instead of returning the class name directly in method type hints, and what problem does it solve?", "ground_truth": "Use Self in methods that return instances of the class (e.g., __init__, factory methods, builder patterns) when dealing with inheritance. It ensures subclasses get the correct return type annotation without hardcoding the parent class name, solving type-checking issues with polymorphic returns.", "source": "self_type_pep673"}
{"id": "pe_024", "domain": "python_expert", "difficulty": "medium", "question": "Explain how TaskGroup in asyncio (Python 3.11+) improves upon traditional asyncio.gather() for managing multiple concurrent tasks.", "ground_truth": "TaskGroup provides structured concurrency with automatic cleanup and proper exception handling. Unlike gather(), TaskGroup cancels remaining tasks if one fails, prevents silent failures, and ensures all tasks complete or are cancelled when exiting the context manager.", "source": "asyncio_taskgroup"}
{"id": "pe_025", "domain": "python_expert", "difficulty": "medium", "question": "What is the difference between a coroutine, a task, and a future in asyncio, and when would you explicitly convert a coroutine to a task?", "ground_truth": "A coroutine is a function defined with async def; a future is a low-level placeholder for a result; a task is a scheduled coroutine (subclass of future). Convert coroutines to tasks with asyncio.create_task() when you need scheduling without awaiting immediately, or to enable cancellation and status checking.", "source": "asyncio_coroutines_tasks"}
{"id": "pe_026", "domain": "python_expert", "difficulty": "medium", "question": "When using dataclass fields with KW_ONLY, what happens to field ordering and how does it interact with default values?", "ground_truth": "KW_ONLY fields must be passed as keyword arguments and can appear after positional fields without requiring defaults on earlier positional fields. Fields marked KW_ONLY are grouped together in __init__ signature and maintain their definition order within the KW_ONLY section.", "source": "dataclass_kw_only"}
{"id": "pe_027", "domain": "python_expert", "difficulty": "medium", "question": "Explain the trade-offs between using @functools.cache versus @functools.lru_cache(maxsize=None) for memoization.", "ground_truth": "cache (Python 3.9+) is simpler and unbounded, suitable for functions with finite argument sets. lru_cache offers bounded memory with configurable maxsize, typed flag for argument type separation, and cache statistics via cache_info(). Use cache for convenience, lru_cache when memory control or statistics are needed.", "source": "functools_cache"}
{"id": "pe_028", "domain": "python_expert", "difficulty": "medium", "question": "What does PEP 692 TypedDict kwargs enable, and how does it differ from **kwargs in traditional type hints?", "ground_truth": "PEP 692 allows using TypedDict as **kwargs type hint via Unpack[] syntax, enabling precise type checking of keyword arguments with specific required and optional keys. This replaces generic **Any kwargs with structured, validated keyword arguments.", "source": "typeddict_kwargs_pep692"}
{"id": "pe_029", "domain": "python_expert", "difficulty": "medium", "question": "Describe how pathlib.Path methods handle different operating systems differently, and when you might still need to use os.path instead.", "ground_truth": "Path automatically handles OS separators (/ vs \\\\) and path normalization. Use os.path only for legacy code compatibility; pathlib is preferred modern approach. Rare cases: when interfacing with C libraries expecting specific path formats, or in performance-critical code with millions of path operations.", "source": "pathlib"}
{"id": "pe_030", "domain": "python_expert", "difficulty": "medium", "question": "What is the purpose of PEP 696 type defaults, and how do they interact with generic type constraints?", "ground_truth": "PEP 696 allows type parameters to have default types using '= SomeType' syntax, enabling optional generic parameters. Defaults work with constraints and bounds; a constrained parameter uses the first constraint as implicit default, while unconstrained parameters use the explicit default.", "source": "type_defaults_pep696"}
{"id": "pe_031", "domain": "python_expert", "difficulty": "medium", "question": "Explain how contextlib.suppress differs from try/except blocks and when it's appropriate to use for exception handling.", "ground_truth": "suppress() is more concise for ignoring specific exceptions in simple cases (e.g., removing optional files). Use try/except when: needing logging, different handling per exception, or resource cleanup with finally. suppress is cleaner for one-off exception silencing.", "source": "contextlib_suppress"}
{"id": "pe_032", "domain": "python_expert", "difficulty": "medium", "question": "How does asyncio.StreamReader.read() differ from asyncio.StreamReader.readexactly() in handling EOF and partial reads?", "ground_truth": "read() returns up to max_bytes (possibly less if EOF reached) and raises IncompleteReadError if EOF occurs before any bytes. readexactly() reads exactly n bytes or raises IncompleteReadError if EOF found before reaching n bytes. Use read() for variable-length data, readexactly() for fixed protocol frames.", "source": "asyncio_streams"}
{"id": "pe_033", "domain": "python_expert", "difficulty": "medium", "question": "What is the relationship between per-interpreter GIL (Python 3.13) and free-threaded CPython, and what are the implications for code compatibility?", "ground_truth": "Per-interpreter GIL isolates the GIL to each interpreter instance within a process, allowing true parallelism for CPU-bound code across interpreters. Free-threaded CPython removes GIL entirely. Both require careful handling of shared state; existing GIL-aware code may have unexpected behavior changes.", "source": "gil_free_threading"}
{"id": "pe_034", "domain": "python_expert", "difficulty": "medium", "question": "When using collections.Counter, explain the difference between count.most_common(n) and the behavior when n is larger than the number of elements.", "ground_truth": "most_common(n) returns list of (element, count) tuples sorted by count descending. If n exceeds total elements, it returns all elements sorted by count. If n is None or omitted, returns all elements; if n <= 0, returns empty list.", "source": "collections_counter"}
{"id": "pe_035", "domain": "python_expert", "difficulty": "medium", "question": "Explain how functools.partial differs from lambda in terms of identity, pickling, and performance, with guidance on when to use each.", "ground_truth": "partial creates a callable object with reduced arguments, preserving function metadata better than lambda; partial is picklable while lambdas are not. partial has minimal overhead; lambda is more flexible for complex expressions. Use partial for callbacks and serialization, lambda for simple one-off operations.", "source": "functools_partial"}
{"id": "pe_036", "domain": "python_expert", "difficulty": "medium", "question": "How does tomllib (Python 3.11+) handle encoding and what limitations does it have compared to third-party TOML libraries?", "ground_truth": "tomllib is read-only and supports UTF-8 encoded TOML files. It lacks write capability (use third-party libraries for serialization) and has no custom type hooks. Use for simple configuration reading; use external libraries like toml for writing or custom serialization.", "source": "tomllib_packaging"}
{"id": "pe_037", "domain": "python_expert", "difficulty": "medium", "question": "What is the purpose of @dataclasses.dataclass_transform (PEP 681), and how does it improve type checking for classes and methods that generate dataclass-like objects?", "ground_truth": "dataclass_transform marks functions/classes that return dataclass-like objects, enabling type checkers to understand their generated __init__ signatures and field attributes. Used by ORMs and frameworks to provide IDE autocomplete and type safety for dynamically created dataclass-like classes.", "source": "dataclass_transform_pep681"}
{"id": "pe_038", "domain": "python_expert", "difficulty": "medium", "question": "Explain how asyncio synchronization primitives like Lock, Semaphore, and Condition differ in their use cases and fairness guarantees.", "ground_truth": "Lock provides mutual exclusion for one resource; Semaphore allows N concurrent accesses; Condition combines locking with wait/notify for coordination. All use FIFO fairness (waiters released in order). Use Lock for simple critical sections, Semaphore for resource pools, Condition for producer-consumer patterns.", "source": "asyncio_synchronization"}
{"id": "pe_039", "domain": "python_expert", "difficulty": "medium", "question": "What happens when you use itertools.islice with negative indices or step values, and what is the correct behavior?", "ground_truth": "islice does not support negative indices or negative step values\u2014using them raises ValueError. islice requires non-negative start/stop/step. For reverse iteration, use reversed() on sequences or chain with other itertools patterns; for negative slicing, convert iterator to list first.", "source": "itertools"}
{"id": "pe_040", "domain": "python_expert", "difficulty": "medium", "question": "How do improved error messages in Python 3.10+ (PEP 657) affect debugging, and what information do they provide beyond traditional tracebacks?", "ground_truth": "PEP 657 adds precise error locations using 'caret' positioning on the exact problematic expression (not just the line), helping identify issues in complex multi-part statements. Shows which part of chained operations or subscripts failed, reducing cognitive load for debugging.", "source": "improved_error_messages"}
{"id": "pe_041", "domain": "python_expert", "difficulty": "hard", "question": "In Python 3.12, when using structural pattern matching with class patterns, what is the critical difference between matching against dataclass fields versus regular class attributes, and how does the guard clause interact with the pattern matching engine's backtracking behavior?", "ground_truth": "Dataclass patterns match by position or by name using attribute access, while class patterns require positional-only parameters in __match_args__. Guard clauses are evaluated after pattern matching succeeds, and the matching engine does not backtrack into alternative patterns if a guard fails\u2014the entire match statement exits without trying subsequent case blocks.", "source": "structural_pattern_matching_advanced"}
{"id": "pe_042", "domain": "python_expert", "difficulty": "hard", "question": "Explain the performance and memory implications of using PEP 695 type parameter syntax (TypeVar via 'type' statement) versus the traditional functools.generic approach, particularly in scenarios with deeply nested generic types and runtime introspection.", "ground_truth": "PEP 695 type parameters are defined at function/class scope with cleaner syntax and enable better static analysis; they reduce memory overhead compared to module-level TypeVar declarations and improve IDE support. At runtime, both approaches create similar descriptor objects, but PEP 695 allows the type system to optimize constraint checking without explicit TypeVar replication across generic definitions.", "source": "pep_695_type_parameters"}
{"id": "pe_043", "domain": "python_expert", "difficulty": "hard", "question": "In asyncio, when using TaskGroup (PEP 654) versus manually managing tasks with create_task() and gather(), what are the exception handling semantics differences, and why does TaskGroup guarantee that all tasks are awaited even if an exception occurs?", "ground_truth": "TaskGroup collects all exceptions (ExceptionGroup) and ensures all tasks complete before re-raising, providing atomic cancellation semantics. Manual gather() stops at the first exception unless return_exceptions=True, potentially leaving tasks running. TaskGroup's async context manager guarantees cleanup via __aexit__, whereas gather() requires explicit exception handling to prevent dangling tasks.", "source": "asyncio_taskgroup_exception_handling"}
{"id": "pe_044", "domain": "python_expert", "difficulty": "hard", "question": "When implementing a frozen dataclass with slots=True and KW_ONLY fields that contain mutable default_factory objects, what are the potential race conditions in multi-threaded scenarios with the free-threaded CPython (PEP 703), and how does per-interpreter GIL isolation affect this?", "ground_truth": "In standard CPython, the GIL protects default_factory calls during instance creation, but frozen dataclasses with mutable defaults still allow mutation of the field's contents (not the field reference). Free-threaded CPython removes GIL protection, requiring explicit locks around factory functions. Per-interpreter GIL isolation only protects within one interpreter; cross-interpreter shared objects still need synchronization.", "source": "dataclass_freezing_threading_safety"}
{"id": "pe_045", "domain": "python_expert", "difficulty": "hard", "question": "Describe the interaction between PEP 692 TypedDict unpacking (**kwargs syntax) and PEP 695 type parameters when used together in a generic function signature. What are the type-checking constraints and runtime behavior differences?", "ground_truth": "PEP 692 allows TypedDict to be unpacked as **kwargs in function signatures for static type checking; combined with PEP 695 type parameters, you can define generic TypedDicts with constrained type variables. At runtime, **kwargs unpacking is unchanged, but static checkers enforce that all required TypedDict keys are present and that optional keys match expected types.", "source": "pep_692_typeddict_kwargs"}
{"id": "pe_046", "domain": "python_expert", "difficulty": "hard", "question": "In functools, when using @cache versus @lru_cache(maxsize=None), explain the garbage collection and reference cycle implications, particularly when decorating methods in cyclic object graphs and considering the free-threaded CPython model.", "ground_truth": "@cache (Python 3.9+) holds strong references indefinitely with no eviction, causing reference cycles if cached results reference the instance; @lru_cache(maxsize=None) behaves identically but allows weakref handling in some contexts. In free-threaded CPython, both require careful synchronization if the decorated function modifies shared state, as the cache lock is per-function, not global.", "source": "functools_caching_memory_management"}
{"id": "pe_047", "domain": "python_expert", "difficulty": "hard", "question": "When using asyncio.StreamReader and StreamWriter with asyncio.open_connection() for binary protocol parsing, what are the edge cases around backpressure handling, and how does the internal buffer size relate to the event loop's responsiveness?", "ground_truth": "StreamReader has an internal buffer (default 2KB per chunk) that can cause memory issues if data arrives faster than read() is called; backpressure is handled via pause_reading()/resume_reading() on the transport. If the buffer fills, the transport automatically pauses, but custom protocols must explicitly call these methods. Undersized buffers increase context switches; oversized buffers delay backpressure signaling.", "source": "asyncio_stream_backpressure"}
{"id": "pe_048", "domain": "python_expert", "difficulty": "hard", "question": "Explain the security implications of using contextlib.suppress() in exception handling chains, particularly when combined with walrus operators and f-string formatting of untrusted input in logging contexts.", "ground_truth": "suppress() silently swallows exceptions, potentially hiding AttributeError or IndexError from malformed untrusted data, masking injection attacks or data corruption. When combined with := (walrus) in conditionals and f-strings formatting unsanitized input, errors may go unnoticed. Best practice: use suppress() only for expected, documented exceptions; avoid suppressing broad exception types near security boundaries.", "source": "contextlib_suppress_security"}
{"id": "pe_049", "domain": "python_expert", "difficulty": "hard", "question": "In Python 3.12's improved error messages with fine-grained exception locations, how does the traceback module's source code caching mechanism interact with dynamically modified or bytecode-only modules, and what are the implications for REPL and JIT-compiled environments?", "ground_truth": "The traceback module caches source lines via linecache; dynamically modified code or bytecode-only modules cannot be recovered from cache, resulting in '<source unavailable>' messages. In REPLs, each input is a separate module, so line numbers may not align with user expectations. JIT-compiled code (future) will require custom source providers to integrate with the traceback system.", "source": "error_messages_traceback_caching"}
{"id": "pe_050", "domain": "python_expert", "difficulty": "hard", "question": "When using itertools.islice() with negative indices or step values in a generator chain, what undefined behaviors or surprising performance characteristics can occur, and how does this differ from slicing lists with similar indices?", "ground_truth": "islice() does not support negative indices or negative steps\u2014using them raises ValueError. Unlike list slicing, islice() consumes the iterator regardless, potentially exhausting infinite generators before raising the error. For bidirectional slicing, you must buffer the entire sequence, defeating the memory efficiency of generators.", "source": "itertools_advanced_slicing"}
{"id": "pe_051", "domain": "python_expert", "difficulty": "hard", "question": "When packaging with pyproject.toml and tomllib (PEP 680), describe the security implications of dynamic version string interpolation in the [project] section and how this interacts with reproducible builds and supply chain security.", "ground_truth": "tomllib is read-only and parses TOML statically without executing code, so dynamic version strings require external tools (build backends like hatchling). Hardcoded versions in pyproject.toml are deterministic and reproducible, but dynamic schemes (via build backend hooks) can introduce non-determinism if they depend on environment state, git metadata, or timestamps. Version tampering during packaging can be detected via PEP 658 file hashes.", "source": "pyproject_tomllib_security"}
