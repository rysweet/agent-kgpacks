[
  {
    "id": "je_001",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What is the primary purpose of virtual threads introduced in Project Loom?",
    "ground_truth": "Virtual threads are lightweight threads that reduce the overhead of platform threads, allowing applications to create millions of concurrent tasks without exhausting system resources. They enable high-throughput, low-latency server applications with simpler synchronous programming models.",
    "source": "virtual_threads_loom"
  },
  {
    "id": "je_002",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "How do you create a virtual thread using the Java 21+ API?",
    "ground_truth": "Use Thread.ofVirtual().start(runnable) to create and start a virtual thread, or Thread.ofVirtual().unstarted(runnable) to create it without starting. Virtual threads are created with the Thread.ofVirtual() builder method.",
    "source": "virtual_threads_creation"
  },
  {
    "id": "je_003",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What does Executors.newVirtualThreadPerTaskExecutor() return?",
    "ground_truth": "It returns an ExecutorService that creates a new virtual thread for each submitted task. This executor automatically completes when all submitted tasks finish, making it ideal for high-concurrency scenarios.",
    "source": "virtual_threads_executor"
  },
  {
    "id": "je_004",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "In pattern matching for switch statements, what are type patterns?",
    "ground_truth": "Type patterns match instances based on their type and automatically cast them within the case block. For example, `case String s` matches String objects and binds the variable s without requiring explicit casting.",
    "source": "pattern_matching_switch"
  },
  {
    "id": "je_005",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What is a record pattern and when would you use it?",
    "ground_truth": "A record pattern destructures a record into its components within a switch case, like `case Point(int x, int y)`. Use it to extract and match on record field values directly in pattern matching expressions.",
    "source": "pattern_matching_records"
  },
  {
    "id": "je_006",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What is a guarded pattern in Java pattern matching?",
    "ground_truth": "A guarded pattern adds a boolean condition to a pattern using the `when` keyword, like `case String s when s.length() > 5`. It allows refining pattern matches with additional runtime conditions.",
    "source": "pattern_matching_guarded"
  },
  {
    "id": "je_007",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What is a compact constructor in a Java record?",
    "ground_truth": "A compact constructor is a simplified constructor syntax for records that automatically assigns parameters to fields without explicit parameter declarations. It receives the same parameters as record fields and can validate input before implicit field assignment.",
    "source": "records_compact_constructor"
  },
  {
    "id": "je_008",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "Can you declare a record inside a method in Java 21+?",
    "ground_truth": "Yes, local records can be declared inside methods or code blocks. They have the same capabilities as top-level records but are scoped to the enclosing method or block.",
    "source": "records_local"
  },
  {
    "id": "je_009",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What does the `permits` clause do in a sealed class?",
    "ground_truth": "The `permits` clause explicitly specifies which classes are allowed to extend or implement a sealed class or interface. It restricts inheritance to a known set of subtypes, enabling exhaustive pattern matching.",
    "source": "sealed_classes_permits"
  },
  {
    "id": "je_010",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "Why is pattern matching with sealed classes beneficial for switch statements?",
    "ground_truth": "Sealed classes restrict subtypes to a known set, allowing the compiler to verify exhaustiveness in switch statements. This means the compiler can confirm all possible subtype cases are covered, eliminating the need for a default case.",
    "source": "sealed_classes_switch"
  },
  {
    "id": "je_011",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What is a MemorySegment in the Foreign Function & Memory API?",
    "ground_truth": "A MemorySegment represents a contiguous region of memory that can be accessed safely in Java. It encapsulates a memory address and size, providing controlled access to off-heap or on-heap memory with bounds checking.",
    "source": "ffm_memory_segment"
  },
  {
    "id": "je_012",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What role does an Arena play in the Foreign Function & Memory API?",
    "ground_truth": "An Arena manages the lifecycle of MemorySegments, controlling memory allocation and deallocation. It ensures safe cleanup of native memory resources, available in variants like Arena.ofAuto() for automatic cleanup or Arena.allocateNative() for manual management.",
    "source": "ffm_arena"
  },
  {
    "id": "je_013",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What is a Linker in the Foreign Function & Memory API context?",
    "ground_truth": "A Linker is used to link Java code with native functions, enabling calling C or other native library functions from Java. It uses MethodHandle to invoke foreign functions with proper parameter marshaling.",
    "source": "ffm_linker"
  },
  {
    "id": "je_014",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What is generational ZGC and what problem does it solve?",
    "ground_truth": "Generational ZGC partitions heap objects into young and old generations, reducing GC pause times by collecting young generation more frequently. This improves latency for applications with short-lived object churn.",
    "source": "zgc_generational"
  },
  {
    "id": "je_015",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What is StructuredTaskScope and what does it enable?",
    "ground_truth": "StructuredTaskScope is part of structured concurrency that manages related subtasks within a defined scope. It ensures all subtasks complete or fail together, simplifying cancellation and error handling in concurrent programs.",
    "source": "structured_concurrency"
  },
  {
    "id": "je_016",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "How do ScopedValues improve upon ThreadLocal in Java 21+?",
    "ground_truth": "ScopedValues are immutable thread-local replacements that work better with virtual threads and structured concurrency. They are automatically inherited by child threads and provide cleaner semantics for sharing data within a scope.",
    "source": "scoped_values"
  },
  {
    "id": "je_017",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What are sequenced collections and what guarantee do they provide?",
    "ground_truth": "Sequenced collections (SequencedCollection interface) provide a guaranteed encounter order for elements and operations like getFirst(), getLast(), and reversed(). They unify List, Deque, and SortedSet under a common contract.",
    "source": "sequenced_collections"
  },
  {
    "id": "je_018",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What are text blocks and what problem do they solve?",
    "ground_truth": "Text blocks (multi-line string literals using triple quotes) eliminate the need for string concatenation or escape sequences in multi-line strings. They preserve indentation intelligently and are particularly useful for JSON, SQL, and HTML.",
    "source": "text_blocks"
  },
  {
    "id": "je_019",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "How does local variable type inference with `var` improve code readability?",
    "ground_truth": "The `var` keyword allows the compiler to infer the type of a local variable from its initializer, reducing boilerplate type declarations. It improves readability when types are obvious from context, like `var list = new ArrayList<String>()`.",
    "source": "local_var_type_inference"
  },
  {
    "id": "je_020",
    "domain": "java_expert",
    "difficulty": "easy",
    "question": "What is exhaustiveness checking in Java pattern matching and why is it important?",
    "ground_truth": "Exhaustiveness checking ensures that all possible values are handled in a switch expression or statement. With sealed classes and patterns, the compiler can verify completeness at compile time, preventing unhandled cases and improving code safety.",
    "source": "pattern_matching_exhaustiveness"
  },
  {
    "id": "je_021",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "When using Project Loom's virtual threads with Executors.newVirtualThreadPerTaskExecutor(), what is the primary advantage over using a traditional thread pool for I/O-bound workloads, and what is a potential limitation?",
    "ground_truth": "Virtual threads allow millions of lightweight threads to be created without the OS thread overhead, enabling better scalability for I/O-bound tasks. However, virtual threads are pinned to carrier threads when executing synchronized blocks or native methods, reducing concurrency benefits in those scenarios.",
    "source": "virtual_threads_project_loom"
  },
  {
    "id": "je_022",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "In Java 21+ pattern matching for switch, what is the difference between type patterns and guarded patterns, and when would you use each?",
    "ground_truth": "Type patterns (e.g., `case String s`) match and bind values based on type alone. Guarded patterns add a boolean condition (e.g., `case String s when s.length() > 5`) for additional filtering. Use type patterns for simple type-based dispatch and guarded patterns when you need to refine matches based on value properties.",
    "source": "pattern_matching_switch"
  },
  {
    "id": "je_023",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "How do compact constructors in Java records differ from canonical constructors, and what validations can you perform in a compact constructor that you cannot in a canonical constructor?",
    "ground_truth": "Compact constructors have implicit parameter list and field assignments, allowing you to validate/transform input before field assignment. Canonical constructors explicitly declare all parameters and assign fields manually. In compact constructors, you can use `this` to reference fields after implicit assignment, and validations happen before automatic field assignment completes.",
    "source": "records_compact_constructors"
  },
  {
    "id": "je_024",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "When using sealed classes with the permits clause, what happens if a permitted subclass is not final and permits further subclasses?",
    "ground_truth": "If a permitted subclass is not marked final, it can have its own subclasses, but those subclasses must also be part of a sealed hierarchy. The sealed constraint is inherited down the hierarchy, requiring each intermediate class to explicitly permit its own subclasses.",
    "source": "sealed_classes_permits"
  },
  {
    "id": "je_025",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "In the Foreign Function & Memory API, what is the relationship between Arena and MemorySegment, and why is proper Arena management critical for memory safety?",
    "ground_truth": "Arena manages the lifecycle of memory allocated to MemorySegments. When an Arena is closed, all its associated MemorySegments become invalid, preventing use-after-free errors. Proper Arena scoping ensures memory is deallocated timely and prevents memory leaks.",
    "source": "foreign_function_memory_api"
  },
  {
    "id": "je_026",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "What is the key difference between generational and non-generational ZGC, and what workload characteristics favor enabling generational ZGC in Java 21+?",
    "ground_truth": "Generational ZGC segregates young and old objects, allowing more frequent collection of young objects with lower latency. It is favored for workloads with high allocation rates and short-lived objects, where generational collection reduces full heap scans and pause times.",
    "source": "zgc_generational"
  },
  {
    "id": "je_027",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "How does StructuredTaskScope in structured concurrency handle exceptions from subtasks, and what is the significance of the ShutdownOnSuccess policy?",
    "ground_truth": "StructuredTaskScope cancels remaining subtasks when one fails or completes abnormally by default. ShutdownOnSuccess automatically cancels incomplete subtasks once any subtask completes successfully, useful for short-circuit patterns where the first successful result is sufficient.",
    "source": "structured_concurrency"
  },
  {
    "id": "je_028",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "How do ScopedValue instances differ from ThreadLocal in terms of inheritance and lifetime management, and what performance implications does this have for virtual threads?",
    "ground_truth": "ScopedValues are tied to execution scope rather than thread identity, and are automatically inherited by child threads/scopes without explicit passing. This reduces virtual thread overhead compared to ThreadLocal since ScopedValues don't require per-thread storage, making them ideal for structured concurrency.",
    "source": "scoped_values"
  },
  {
    "id": "je_029",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "What are sequenced collections in Java 21+, and which existing collection interfaces were retrofitted to extend SequencedCollection?",
    "ground_truth": "Sequenced collections define a deterministic encounter order and provide methods like getFirst(), getLast(), reversed(). List, Deque, and LinkedHashSet/LinkedHashMap were retrofitted to extend SequencedCollection, ensuring consistent API for ordered access across collection types.",
    "source": "sequenced_collections"
  },
  {
    "id": "je_030",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "When using record patterns in nested destructuring (e.g., `case Point(int x, int y)`), what compile-time guarantee does Java provide about exhaustiveness checking in pattern matching?",
    "ground_truth": "The compiler performs exhaustiveness analysis on record patterns, ensuring all possible record variants are covered in switch statements. For sealed records, the compiler can prove exhaustiveness; for unsealed records, it requires a default case or all constructors to be covered.",
    "source": "record_patterns"
  },
  {
    "id": "je_031",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "How does local variable type inference (var) interact with pattern variables in switch expressions, and what type safety guarantees are maintained?",
    "ground_truth": "var cannot be used for pattern variables in switch cases; types must be explicitly declared (e.g., `case String s` not `case var s`). This ensures pattern type safety is explicit and prevents ambiguous type resolution in pattern matching contexts.",
    "source": "local_variable_type_inference"
  },
  {
    "id": "je_032",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "What is the purpose of text blocks in Java 21+, and how does the indentation handling mechanism differ from traditional string concatenation?",
    "ground_truth": "Text blocks simplify multi-line string literals with automatic newline handling and indentation stripping. The compiler removes common leading whitespace based on the closing delimiter position, preserving relative indentation while eliminating boilerplate escape sequences.",
    "source": "text_blocks"
  },
  {
    "id": "je_033",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "In the Foreign Function & Memory API, what is a MethodHandle and how does it relate to calling native functions through the Linker interface?",
    "ground_truth": "A MethodHandle is a typed, directly invocable reference to an underlying method or function. The Linker uses a FunctionDescriptor to create MethodHandles that safely invoke native functions with proper type checking and memory marshalling across language boundaries.",
    "source": "foreign_function_linker"
  },
  {
    "id": "je_034",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "How does Thread.ofVirtual() differ from Thread.ofPlatform() in terms of scheduler interaction and potential for resource exhaustion?",
    "ground_truth": "Virtual threads created via Thread.ofVirtual() are scheduled on a ForkJoinPool shared scheduler and don't consume OS threads. Platform threads created via Thread.ofPlatform() map 1:1 to OS threads, limiting scalability; excessive platform threads can exhaust OS resources.",
    "source": "virtual_threads_creation"
  },
  {
    "id": "je_035",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "What is the purpose of the exhaustiveness checking in sealed class hierarchies combined with switch expressions, and what compile-time errors result from incomplete pattern coverage?",
    "ground_truth": "Sealed classes enable the compiler to verify that all possible subtypes are covered in switch expressions, preventing runtime exceptions. Incomplete pattern coverage generates a compile error stating the missing cases, ensuring all possible sealed class subtypes are explicitly handled.",
    "source": "sealed_classes_exhaustiveness"
  },
  {
    "id": "je_036",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "How do local records (records declared inside methods) enhance code organization and what restrictions apply to their visibility and usage?",
    "ground_truth": "Local records enable type-safe data grouping within method scope, improving readability for temporary data structures. They have method-local visibility and cannot be accessed outside their declaring method, making them ideal for intermediate computations in structured concurrency patterns.",
    "source": "records_local"
  },
  {
    "id": "je_037",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "When configuring ZGC for low-latency requirements, what is the trade-off between pause time and throughput, and which tuning parameters directly influence maximum pause time?",
    "ground_truth": "Reducing ZGC pause time may increase overall GC overhead and reduce throughput. Parameters like -XX:ZCollectionInterval and -XX:ZUncommitDelay control pause timing and memory reclamation; lower values reduce pauses but increase GC frequency and CPU usage.",
    "source": "zgc_tuning"
  },
  {
    "id": "je_038",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "In structured concurrency with StructuredTaskScope, what is the scope of cancellation when a subtask throws an exception, and how does this relate to resource cleanup guarantees?",
    "ground_truth": "When a subtask fails, StructuredTaskScope automatically cancels all remaining subtasks within that scope before propagating the exception. The try-with-resources pattern ensures the scope's close() is called, providing deterministic cleanup guarantees for all scope-local resources.",
    "source": "structured_concurrency_cleanup"
  },
  {
    "id": "je_039",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "How does the Java Language Specification update for Java 21+ define the interaction between pattern matching exhaustiveness and default cases in switch statements?",
    "ground_truth": "If all patterns in a switch statement are provably exhaustive (e.g., all sealed subtypes covered), a default case is not required. However, if exhaustiveness cannot be proven by the compiler, a default case is mandatory to prevent compilation errors.",
    "source": "jls_pattern_matching"
  },
  {
    "id": "je_040",
    "domain": "java_expert",
    "difficulty": "medium",
    "question": "What happens when you attempt to create a MemorySegment in the Foreign Function & Memory API without an explicit Arena, and what are the lifetime implications?",
    "ground_truth": "You must provide an Arena when creating MemorySegments; there is no default implicit Arena. The Arena determines the memory segment's lifetime\u2014once the Arena is closed, all its segments become invalid. Using Arena.ofAuto() provides automatic lifecycle management but may introduce unpredictable cleanup timing.",
    "source": "foreign_function_arena_lifecycle"
  },
  {
    "id": "je_041",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "When using virtual threads with Executors.newVirtualThreadPerTaskExecutor(), what is the critical performance implication if a task performs a blocking operation on a native method (JNI call) that doesn't yield control back to the Java scheduler?",
    "ground_truth": "The underlying carrier thread (OS thread) becomes pinned and cannot be reused for other virtual threads, defeating the scalability benefits of virtual threads. The JVM cannot unmount the virtual thread during native blocking, causing thread pool exhaustion and potential deadlocks if many tasks encounter native blocking simultaneously.",
    "source": "Virtual Threads (Project Loom) - carrier thread pinning"
  },
  {
    "id": "je_042",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "In pattern matching for switch statements, explain why a guarded pattern with an unguarded pattern of the same type in the same switch can lead to a compile error, and what the JLS stipulates about exhaustiveness in this scenario.",
    "ground_truth": "Guarded patterns are not considered exhaustive even if the guard logically covers all cases, because guards are evaluated at runtime. If an unguarded pattern of the same type appears later, it creates unreachable code. The JLS requires switch statements with guarded patterns to be explicitly total (cover all possible values) or have a default clause to ensure no unhandled cases.",
    "source": "Pattern Matching for Switch - guarded patterns and exhaustiveness"
  },
  {
    "id": "je_043",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "When designing a sealed class hierarchy with the permits clause, what architectural considerations must you account for regarding subclass initialization, and how does this interact with compact record constructors in sealed record hierarchies?",
    "ground_truth": "Sealed classes must declare all permitted subclasses at compile-time, limiting extensibility but enabling exhaustive switch statements. With sealed records, compact constructors cannot invoke super() explicitly; instead, the record's implicit canonical constructor handles field initialization. This constrains the design\u2014shared initialization logic must be in static factories or instance initializers, and cross-subclass initialization patterns require careful architectural planning.",
    "source": "Sealed Classes and Records - architecture and initialization"
  },
  {
    "id": "je_044",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "Explain the memory safety guarantees of the Foreign Function & Memory API when using Arena scopes with MemorySegment, particularly regarding scope confinement and the implications of closing an Arena containing segments still referenced by active virtual threads.",
    "ground_truth": "Arena implements thread-confined scope semantics; segments are bound to the Arena's lifecycle and thread context. Closing an Arena invalidates all its segments, causing SegmentScope.scope() checks to fail. If virtual threads hold references to closed segments and attempt access, a WrongThreadException or SegmentAccessException is thrown at runtime. The lifetime of the Arena must be managed to outlive all segment accesses, or use shared/global arenas for multi-threaded access.",
    "source": "Foreign Function & Memory API - Arena scope and confinement"
  },
  {
    "id": "je_045",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "In generational ZGC tuning, what is the relationship between -XX:ZGenerational and -XX:ZYoungGenSize, and how does enabling generational mode affect the pause time predictability and throughput trade-offs compared to non-generational ZGC?",
    "ground_truth": "Generational ZGC (-XX:+ZGenerational) separates young and old object collections, allowing frequent young-gen collections with lower latency. -XX:ZYoungGenSize controls the young generation size; smaller values increase collection frequency but reduce pause times, while larger values improve throughput but increase individual pause time variance. Generational mode reduces old-gen pause times significantly (sub-millisecond) but may increase overall GC frequency and CPU overhead compared to non-generational ZGC.",
    "source": "ZGC - generational tuning and pause time characteristics"
  },
  {
    "id": "je_046",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "When using StructuredTaskScope in a deeply nested concurrent call chain with multiple scopes and subtasks, what happens if a subtask spawned in an inner scope throws an exception and how does this interact with scope shutdown semantics and resource cleanup?",
    "ground_truth": "When a subtask throws an exception, the inner StructuredTaskScope captures it and upon scope.join() or scope.close(), it rethrows as a StructuredTaskScope.StructureViolationException wrapping the cause. The exception triggers shutdown of all sibling subtasks in that scope. Outer scopes are notified only after inner scopes complete; each scope ensures cleanup in LIFO order. Uncaught exceptions in nested scopes can suppress outer exceptions, requiring careful exception composition handling.",
    "source": "Structured Concurrency - exception propagation and scope cleanup"
  },
  {
    "id": "je_047",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "Compare ScopedValue to ThreadLocal in the context of virtual threads and explain why ScopedValue's inheritance semantics and lack of .remove() method make it superior for scoped context propagation in Project Loom applications.",
    "ground_truth": "ScopedValue is immutable and lexically scoped, binding values to try-with-resources blocks rather than thread lifecycle; values are automatically cleaned up when the scope exits, preventing memory leaks. Unlike ThreadLocal, ScopedValue copies values (via inheritance) to spawned virtual threads without explicit propagation, avoiding manual cleanup and context leakage. The absence of .remove() enforces disciplined scope usage and eliminates accidental reuse of stale values across independent execution contexts.",
    "source": "Scoped Values - context propagation for virtual threads"
  },
  {
    "id": "je_048",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "Describe the performance characteristics and use-case trade-offs between SequencedCollection implementations (SequencedSet, SequencedMap) versus traditional Collection APIs, particularly regarding iteration order guarantees and backward-compatibility concerns.",
    "ground_truth": "SequencedCollections guarantee encounter order (first-to-last and reversed access) at API level, enabling methods like getFirst(), getLast(), reversed() without type-casting or manual reversal. LinkedHashSet/LinkedHashMap inherit SequencedSet/Map and maintain predictable order, while TreeSet and TreeMap provide natural/custom ordering. Performance is comparable to standard Collections, but SequencedCollections add a layer of semantic clarity. Backward compatibility is preserved\u2014existing code using Set/Map interfaces continues to work, though without ordered traversal guarantees.",
    "source": "Sequenced Collections - API design and performance"
  },
  {
    "id": "je_049",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "In a text block containing escape sequences and embedded expressions (if supported), what are the nuances of whitespace handling regarding the incidental common leading whitespace algorithm, and how does this interact with string concatenation and indentation stripping?",
    "ground_truth": "Text blocks automatically strip incidental common leading whitespace (based on the leftmost non-whitespace character across all lines). Escape sequences like \\n, \\t, and \\s are processed after whitespace stripping. Embedded expressions (Java 21+, preview in some versions) are evaluated within the block's context. If a text block is split across multiple lines with inconsistent indentation, the algorithm computes the minimum leading whitespace and removes it uniformly, potentially leaving intended indentation. Developers must account for this when mixing expressions and multiline content.",
    "source": "Text Blocks - whitespace handling and escape sequences"
  },
  {
    "id": "je_050",
    "domain": "java_expert",
    "difficulty": "hard",
    "question": "When using local variable type inference (var) in lambda expressions and complex generic contexts, what are the limitations and ambiguities that the compiler faces, and why does the JLS explicitly disallow var in certain declaration contexts?",
    "ground_truth": "var cannot be used in lambda expression parameters, catch clause parameters, or method/constructor parameters because type inference requires explicit context that is unavailable in these declarations. In complex generic scenarios (e.g., var x = new HashMap<String, Integer>() {}), var infers the anonymous class type, not the generic parameter types. The JLS restricts var to local variable declarations with initializers where the initializer's type is unambiguous, preserving type safety and enabling predictable type inference without breaking encapsulation or creating hidden type dependencies.",
    "source": "Local Variable Type Inference (var) - inference limitations and JLS constraints"
  }
]
