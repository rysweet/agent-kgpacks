{"id": "ownership_001", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What are the three ownership rules in Rust?", "ground_truth": "1. Each value has a variable called its owner. 2. There can only be one owner at a time. 3. When the owner goes out of scope, the value is dropped.", "source": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"}
{"id": "ownership_002", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is the difference between move and copy semantics in Rust?", "ground_truth": "Move transfers ownership of heap-allocated data, invalidating the original variable. Copy duplicates stack-only data, allowing both variables to remain valid. Types implement Copy trait for copy semantics.", "source": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"}
{"id": "ownership_003", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is a reference in Rust?", "ground_truth": "A reference is a pointer that borrows a value without taking ownership. References use & syntax and must always be valid (no null references). They allow reading or modifying data without ownership transfer.", "source": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}
{"id": "ownership_004", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is the difference between &T and &mut T?", "ground_truth": "&T is an immutable reference allowing read-only access. &mut T is a mutable reference allowing modification. You can have multiple &T or one &mut T, but not both simultaneously.", "source": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}
{"id": "ownership_005", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What does 'static lifetime mean?", "ground_truth": "'static means the reference is valid for the entire program execution. String literals have 'static lifetime. It's the longest possible lifetime in Rust.", "source": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"}
{"id": "ownership_006", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is the borrow checker?", "ground_truth": "The borrow checker is Rust's compile-time mechanism that enforces ownership and borrowing rules. It ensures memory safety by preventing data races, use-after-free, and dangling references at compile time.", "source": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}
{"id": "ownership_007", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What happens when a value goes out of scope?", "ground_truth": "When a value goes out of scope, Rust automatically calls its Drop trait implementation (if present) to clean up resources. For heap data, this deallocates memory. This is called RAII (Resource Acquisition Is Initialization).", "source": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"}
{"id": "ownership_008", "domain": "ownership_borrowing", "difficulty": "easy", "question": "Can you have multiple mutable references to the same data?", "ground_truth": "No. Rust's borrowing rules prevent multiple mutable references to the same data in the same scope to avoid data races. You can have either one &mut T or any number of &T references, but not both.", "source": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}
{"id": "ownership_009", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is a dangling reference?", "ground_truth": "A dangling reference points to memory that has been freed. Rust's borrow checker prevents dangling references at compile time by ensuring references never outlive the data they point to.", "source": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}
{"id": "ownership_010", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What does it mean to 'borrow' a value?", "ground_truth": "Borrowing means taking a reference to a value without taking ownership. The borrower can use the value temporarily, but the original owner retains ownership and the value remains valid.", "source": "https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html"}
{"id": "ownership_011", "domain": "ownership_borrowing", "difficulty": "medium", "question": "Explain lifetime elision rules in Rust.", "ground_truth": "Lifetime elision allows omitting lifetime annotations in common cases: 1) Each input reference gets its own lifetime. 2) If one input lifetime, output gets that lifetime. 3) If &self or &mut self, output gets self's lifetime. Compiler infers these automatically.", "source": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"}
{"id": "ownership_012", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is the difference between String and &str?", "ground_truth": "String is an owned, heap-allocated, growable UTF-8 string. &str is a borrowed string slice, an immutable view into string data (either String or literal). &str doesn't own its data and has fixed size.", "source": "https://doc.rust-lang.org/book/ch04-03-slices.html"}
{"id": "ownership_013", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How do lifetimes work with struct fields?", "ground_truth": "If a struct holds references, it needs lifetime parameters. Example: struct Foo<'a> { field: &'a str }. The struct cannot outlive the references it holds. The lifetime parameter connects the struct's lifetime to its references.", "source": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"}
{"id": "ownership_014", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is non-lexical lifetimes (NLL)?", "ground_truth": "Non-lexical lifetimes is a borrow checker improvement that ends borrows when they're last used, not at scope end. This allows more flexible borrowing patterns that are safe but would fail with lexical scopes.", "source": "https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/non-lexical-lifetimes.html"}
{"id": "ownership_015", "domain": "ownership_borrowing", "difficulty": "medium", "question": "Explain interior mutability and RefCell.", "ground_truth": "Interior mutability allows mutating data through immutable references using runtime borrow checking. RefCell<T> provides this via borrow() and borrow_mut() methods that panic if borrowing rules are violated at runtime.", "source": "https://doc.rust-lang.org/book/ch15-05-interior-mutability.html"}
{"id": "ownership_016", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is the difference between Box, Rc, and Arc?", "ground_truth": "Box<T> provides single ownership of heap data. Rc<T> enables multiple ownership via reference counting (not thread-safe). Arc<T> is atomic reference counting for thread-safe shared ownership. All use smart pointers.", "source": "https://doc.rust-lang.org/book/ch15-00-smart-pointers.html"}
{"id": "ownership_017", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What are the borrowing rules for method receivers?", "ground_truth": "Methods can take self (consume), &self (borrow immutably), or &mut self (borrow mutably). The receiver type determines if the method moves, borrows immutably, or borrows mutably. This follows standard borrowing rules.", "source": "https://doc.rust-lang.org/book/ch05-03-method-syntax.html"}
{"id": "ownership_018", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How do you return a reference from a function?", "ground_truth": "References returned from functions need lifetime annotations to connect input and output lifetimes. Example: fn first<'a>(s: &'a str, t: &'a str) -> &'a str. The returned reference must be derived from an input or be 'static.", "source": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"}
{"id": "ownership_019", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is a slice and how does it differ from a vector?", "ground_truth": "A slice (&[T]) is a borrowed view into contiguous sequence (array, Vec). It has fixed size and doesn't own data. Vec<T> is owned, growable, heap-allocated. Slices enable flexible, efficient data access without copying.", "source": "https://doc.rust-lang.org/book/ch04-03-slices.html"}
{"id": "ownership_020", "domain": "ownership_borrowing", "difficulty": "medium", "question": "Explain the difference between move semantics and borrowing.", "ground_truth": "Move transfers ownership permanently, invalidating the source. Original variable can't be used after move. Borrowing temporarily lends access via references, ownership returns when borrow ends. Move is permanent, borrowing is temporary.", "source": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"}
{"id": "ownership_021", "domain": "ownership_borrowing", "difficulty": "hard", "question": "What is variance in Rust lifetimes and why does it matter?", "ground_truth": "Variance determines lifetime subtyping compatibility. Covariant ('a outlives 'b allows using 'a where 'b expected), contravariant (opposite), invariant (exact match). Affects generic types like &'a T (covariant), &'a mut T (invariant in T), fn(&'a T) (contravariant in 'a).", "source": "https://doc.rust-lang.org/nomicon/subtyping.html"}
{"id": "ownership_022", "domain": "ownership_borrowing", "difficulty": "hard", "question": "How do you work around lifetime limitations with the 'rental' pattern?", "ground_truth": "The rental pattern (now discouraged) created self-referential structs by splitting into owner and borrower. Modern alternatives: use indices instead of references, restructure with state machines, or use Pin for self-referential async code.", "source": "https://doc.rust-lang.org/nomicon/lifetime-mismatch.html"}
{"id": "ownership_023", "domain": "ownership_borrowing", "difficulty": "hard", "question": "Explain higher-rank trait bounds (HRTBs) with lifetimes.", "ground_truth": "HRTBs (for<'a>) express that a trait is implemented for all possible lifetimes. Example: F: for<'a> Fn(&'a str) means F works with any lifetime. Used for generic code that must work with any borrowed data.", "source": "https://doc.rust-lang.org/nomicon/hrtb.html"}
{"id": "ownership_024", "domain": "ownership_borrowing", "difficulty": "hard", "question": "What are the safety guarantees and limitations of Pin?", "ground_truth": "Pin<P> prevents moving the pointed-to value, enabling safe self-referential types. Required for async/await. Pin doesn't prevent dropping or accessing through &mut. Unpin marker trait opts out. Used to guarantee pointer stability.", "source": "https://doc.rust-lang.org/std/pin/index.html"}
{"id": "ownership_025", "domain": "ownership_borrowing", "difficulty": "hard", "question": "How does Rust prevent iterator invalidation?", "ground_truth": "Iterators borrow collections, preventing modification during iteration. &mut self on modifying methods conflicts with &self in iter(). This prevents use-after-free from concurrent modification. Must finish iteration or drop iterator before modifying.", "source": "https://doc.rust-lang.org/book/ch13-02-iterators.html"}
{"id": "ownership_026", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is the Copy trait?", "ground_truth": "Copy trait marks types whose values can be duplicated by copying bits. Types with Copy don't moveâ€”assignment creates a copy. Only stack-only types can implement Copy (integers, booleans, floats, chars, tuples/arrays of Copy types).", "source": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"}
{"id": "ownership_027", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is the Drop trait?", "ground_truth": "Drop trait defines cleanup code when a value goes out of scope. Rust calls drop() automatically at scope end. Used for releasing resources (files, network connections, locks). Manual drop() call uses std::mem::drop().", "source": "https://doc.rust-lang.org/book/ch15-03-drop.html"}
{"id": "ownership_028", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is the difference between Vec::new() and Vec::with_capacity()?", "ground_truth": "Vec::new() creates empty vector with zero capacity. Vec::with_capacity(n) pre-allocates space for n elements, avoiding reallocation during growth. Use with_capacity when you know the size to improve performance.", "source": "https://doc.rust-lang.org/std/vec/struct.Vec.html"}
{"id": "ownership_029", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How do you clone a value and when should you?", "ground_truth": "Call .clone() to create a deep copy that owns its data. Clone trait must be implemented. Use when you need independent copies, but prefer borrowing when possible as cloning has performance cost.", "source": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"}
{"id": "ownership_030", "domain": "ownership_borrowing", "difficulty": "hard", "question": "What is the difference between reborrow and reference in method chaining?", "ground_truth": "Reborrow (&*x or explicit) creates a new shorter-lived reference from existing reference, enabling method chaining with &mut. Compiler often does this implicitly. Allows multiple uses of &mut in same expression by shortening lifetimes.", "source": "https://doc.rust-lang.org/nomicon/references.html"}
{"id": "traits_001", "domain": "traits_generics", "difficulty": "easy", "question": "What is a trait in Rust?", "ground_truth": "A trait defines shared behavior across types, similar to interfaces. Traits specify method signatures that implementing types must provide. They enable polymorphism and generic programming.", "source": "https://doc.rust-lang.org/book/ch10-02-traits.html"}
{"id": "traits_002", "domain": "traits_generics", "difficulty": "easy", "question": "How do you implement a trait for a type?", "ground_truth": "Use impl TraitName for TypeName { ... } syntax. Implement all required trait methods. Example: impl Display for Point { fn fmt(&self, f: &mut Formatter) -> Result { ... } }", "source": "https://doc.rust-lang.org/book/ch10-02-traits.html"}
{"id": "traits_003", "domain": "traits_generics", "difficulty": "easy", "question": "What are trait bounds?", "ground_truth": "Trait bounds constrain generic types to those implementing specific traits. Syntax: fn foo<T: Display>(x: T) or where T: Display. Ensures generic code can use trait methods on type parameters.", "source": "https://doc.rust-lang.org/book/ch10-02-traits.html"}
{"id": "traits_004", "domain": "traits_generics", "difficulty": "easy", "question": "What is the difference between impl Trait and dyn Trait?", "ground_truth": "impl Trait is static dispatch (compile-time), monomorphization generates code per type. dyn Trait is dynamic dispatch (runtime), uses vtables with performance cost. impl Trait is faster, dyn Trait is more flexible.", "source": "https://doc.rust-lang.org/book/ch17-02-trait-objects.html"}
{"id": "traits_005", "domain": "traits_generics", "difficulty": "easy", "question": "What is a generic function?", "ground_truth": "Generic function works with multiple types via type parameters. Example: fn largest<T: PartialOrd>(list: &[T]) -> &T. Compiler generates specialized code for each concrete type used (monomorphization).", "source": "https://doc.rust-lang.org/book/ch10-01-syntax.html"}
{"id": "traits_006", "domain": "traits_generics", "difficulty": "easy", "question": "What is the Default trait?", "ground_truth": "Default trait provides default values for types. Implement default() method returning default instance. Useful for struct initialization: MyStruct::default(). Many std types implement Default.", "source": "https://doc.rust-lang.org/std/default/trait.Default.html"}
{"id": "traits_007", "domain": "traits_generics", "difficulty": "easy", "question": "What is the Debug trait used for?", "ground_truth": "Debug trait enables formatting with {:?} for debugging output. Usually derived with #[derive(Debug)]. Provides human-readable representation for development. {:?} is debug format, {:#?} is pretty-print format.", "source": "https://doc.rust-lang.org/std/fmt/trait.Debug.html"}
{"id": "traits_008", "domain": "traits_generics", "difficulty": "easy", "question": "What is the Clone trait?", "ground_truth": "Clone trait enables explicit duplication via .clone() method. Types implement clone() to create deep copies. Contrasts with Copy which does implicit copying. Used when you need independent owned copies.", "source": "https://doc.rust-lang.org/std/clone/trait.Clone.html"}
{"id": "traits_009", "domain": "traits_generics", "difficulty": "easy", "question": "What is trait inheritance?", "ground_truth": "Trait inheritance (supertraits) means one trait requires another. Syntax: trait B: A { ... } means implementing B requires implementing A. Example: trait Printable: Display means Printable types must also implement Display.", "source": "https://doc.rust-lang.org/book/ch19-03-advanced-traits.html"}
{"id": "traits_010", "domain": "traits_generics", "difficulty": "easy", "question": "What is a generic struct?", "ground_truth": "Generic struct has type parameters: struct Point<T> { x: T, y: T }. Type parameters can be constrained with trait bounds. Each concrete instantiation is a different type (Point<i32> vs Point<f64>).", "source": "https://doc.rust-lang.org/book/ch10-01-syntax.html"}
{"id": "traits_011", "domain": "traits_generics", "difficulty": "medium", "question": "What are associated types and why use them instead of generics?", "ground_truth": "Associated types are type placeholders in traits. Syntax: type Item; in trait definition. Unlike generic traits, associated types allow only one implementation per type. Cleaner API: Iterator::Item vs Iterator<Item>. Use when one type per implementation makes sense.", "source": "https://doc.rust-lang.org/book/ch19-03-advanced-traits.html"}
{"id": "traits_012", "domain": "traits_generics", "difficulty": "medium", "question": "Explain trait object safety and why some traits can't be made into objects.", "ground_truth": "Trait objects require object-safety: no generic methods, no Self in return types (except special cases), no associated constants. Required because vtables need fixed size. Non-object-safe traits can't use dyn Trait.", "source": "https://doc.rust-lang.org/reference/items/traits.html#object-safety"}
{"id": "traits_013", "domain": "traits_generics", "difficulty": "medium", "question": "What is the From/Into trait pattern?", "ground_truth": "From<T> defines conversion from T: impl From<String> for MyType. Into<U> is the reverse, auto-implemented when From is. Use From for conversions, accept Into in APIs for flexibility: fn foo(s: impl Into<String>).", "source": "https://doc.rust-lang.org/std/convert/trait.From.html"}
{"id": "traits_014", "domain": "traits_generics", "difficulty": "medium", "question": "What is the Deref trait and deref coercion?", "ground_truth": "Deref enables * operator and automatic dereferencing. Deref coercion converts &T to &U when T: Deref<Target=U>. Enables ergonomic API: &String to &str, &Box<T> to &T. Smart pointers implement Deref.", "source": "https://doc.rust-lang.org/book/ch15-02-deref.html"}
{"id": "traits_015", "domain": "traits_generics", "difficulty": "medium", "question": "How do you implement operators for custom types?", "ground_truth": "Implement operator traits from std::ops: Add (+), Sub (-), Mul (*), Div (/), etc. Example: impl Add for Point { type Output = Point; fn add(self, other: Point) -> Point { ... } }. Enables natural syntax.", "source": "https://doc.rust-lang.org/book/ch19-03-advanced-traits.html"}
{"id": "traits_016", "domain": "traits_generics", "difficulty": "medium", "question": "What is the difference between &impl Trait and &dyn Trait?", "ground_truth": "&impl Trait is reference to static dispatch type (compile-time). &dyn Trait is trait object (dynamic dispatch, runtime). impl Trait is faster, monomorphized. dyn Trait allows heterogeneous collections and runtime polymorphism.", "source": "https://doc.rust-lang.org/book/ch17-02-trait-objects.html"}
{"id": "traits_017", "domain": "traits_generics", "difficulty": "medium", "question": "Explain turbofish syntax ::<> in generic contexts.", "ground_truth": "Turbofish ::<T> explicitly specifies type parameters when inference fails. Example: let v = Vec::<i32>::new() or method call x.collect::<Vec<_>>(). Used when compiler can't infer type from context.", "source": "https://doc.rust-lang.org/book/ch10-01-syntax.html"}
{"id": "traits_018", "domain": "traits_generics", "difficulty": "medium", "question": "What are blanket implementations?", "ground_truth": "Blanket implementations implement a trait for all types satisfying bounds. Example: impl<T: Display> ToString for T. Provides implementations for many types at once. Standard library uses extensively (any Display gets ToString).", "source": "https://doc.rust-lang.org/book/ch10-02-traits.html"}
{"id": "traits_019", "domain": "traits_generics", "difficulty": "medium", "question": "How do you use multiple trait bounds?", "ground_truth": "Multiple bounds with + syntax: fn foo<T: Display + Clone>(x: T). Or where clause: fn foo<T>(x: T) where T: Display + Clone. Where clauses improve readability with complex bounds.", "source": "https://doc.rust-lang.org/book/ch10-02-traits.html"}
{"id": "traits_020", "domain": "traits_generics", "difficulty": "medium", "question": "What is the Iterator trait and how does it work?", "ground_truth": "Iterator trait defines next() method returning Option<Item>. Item is associated type. Implementors provide iteration logic. Many adapters (map, filter, etc.) build on Iterator. Central to Rust's functional programming.", "source": "https://doc.rust-lang.org/book/ch13-02-iterators.html"}
{"id": "traits_021", "domain": "traits_generics", "difficulty": "hard", "question": "Explain the orphan rule and why it exists.", "ground_truth": "Orphan rule: can implement trait for type only if trait or type is local to your crate. Prevents conflicting implementations across crates. Without it, two crates could implement same trait differently, breaking coherence. Use newtype pattern to work around.", "source": "https://doc.rust-lang.org/book/ch10-02-traits.html"}
{"id": "traits_022", "domain": "traits_generics", "difficulty": "hard", "question": "What is specialization and what problems does it solve?", "ground_truth": "Specialization (unstable) allows more specific trait implementations to override general ones. Solves overlap between blanket impls and specific cases. Example: generic impl for all T, optimized impl for specific types. Improves performance and flexibility.", "source": "https://rust-lang.github.io/rfcs/1210-impl-specialization.html"}
{"id": "traits_023", "domain": "traits_generics", "difficulty": "hard", "question": "How do you implement a trait that has a generic method?", "ground_truth": "Generic methods in traits: trait Container { fn add<T>(&mut self, item: T); }. Implementor must support all T. Creates challenges with trait objects (not object-safe). Consider associated types or separate traits if object-safety needed.", "source": "https://doc.rust-lang.org/book/ch10-02-traits.html"}
{"id": "traits_024", "domain": "traits_generics", "difficulty": "hard", "question": "What are const generics and when would you use them?", "ground_truth": "Const generics parameterize types with constant values: struct Array<T, const N: usize>. Enables fixed-size arrays of any length in generic code. Useful for buffer sizes, dimensions, compile-time configuration. Available in stable Rust.", "source": "https://doc.rust-lang.org/reference/items/generics.html"}
{"id": "async_001", "domain": "async_programming", "difficulty": "easy", "question": "What is async/await in Rust?", "ground_truth": "async/await enables asynchronous programming. async fn returns Future that must be .await-ed or polled. Allows concurrent I/O without threads. Requires runtime like tokio. Non-blocking: tasks yield during I/O.", "source": "https://doc.rust-lang.org/book/ch16-04-async-await.html"}
{"id": "async_002", "domain": "async_programming", "difficulty": "easy", "question": "What is a Future in Rust?", "ground_truth": "Future represents async computation that will complete eventually. Poll-based: executor calls poll() until Ready. Lazy: doesn't run until polled. async functions return impl Future. Must be awaited or spawned.", "source": "https://doc.rust-lang.org/std/future/trait.Future.html"}
{"id": "async_003", "domain": "async_programming", "difficulty": "easy", "question": "What is tokio?", "ground_truth": "Tokio is async runtime for Rust. Provides task scheduler, async I/O primitives, timers. Required to run async code. Use #[tokio::main] to start runtime. Handles polling Futures efficiently with event loop.", "source": "https://tokio.rs/"}
{"id": "async_004", "domain": "async_programming", "difficulty": "easy", "question": "What does .await do?", "ground_truth": ".await suspends current async function until Future completes. Yields control to executor. Returns Future's output. Only works in async fn or async block. Enables sequential-looking concurrent code.", "source": "https://doc.rust-lang.org/book/ch16-04-async-await.html"}
{"id": "async_005", "domain": "async_programming", "difficulty": "easy", "question": "What is the difference between sync and async functions?", "ground_truth": "Sync functions block thread until complete. Async functions return Future immediately, execute when polled. Async enables concurrency without threads. Use async for I/O-bound work, sync for CPU-bound work.", "source": "https://doc.rust-lang.org/book/ch16-04-async-await.html"}
{"id": "async_006", "domain": "async_programming", "difficulty": "easy", "question": "How do you run an async function?", "ground_truth": "Need async runtime (tokio, async-std). Use #[tokio::main] on main function, or block_on() to bridge sync/async. Runtime polls Future to completion. Example: #[tokio::main] async fn main() { ... }", "source": "https://tokio.rs/tokio/tutorial"}
{"id": "async_007", "domain": "async_programming", "difficulty": "easy", "question": "What is task spawning in async Rust?", "ground_truth": "Spawning creates concurrent task. tokio::spawn(async { ... }) runs Future on runtime. Returns JoinHandle to await result. Tasks run concurrently, scheduled by runtime. Used for parallelism in async context.", "source": "https://tokio.rs/tokio/tutorial/spawning"}
{"id": "async_008", "domain": "async_programming", "difficulty": "easy", "question": "What is an async block?", "ground_truth": "async { ... } creates Future from code block. Returns impl Future. Can capture variables from environment. Useful for inline async code. Example: let fut = async { some_async_fn().await };", "source": "https://doc.rust-lang.org/book/ch16-04-async-await.html"}
{"id": "async_009", "domain": "async_programming", "difficulty": "easy", "question": "What is select! in tokio?", "ground_truth": "select! macro waits on multiple Futures, proceeds with first to complete. Enables timeout patterns, racing operations, cancellation. Pattern matches on results. Others are cancelled when one completes.", "source": "https://tokio.rs/tokio/tutorial/select"}
{"id": "async_010", "domain": "async_programming", "difficulty": "easy", "question": "What is an async runtime?", "ground_truth": "Runtime executes async tasks. Provides executor (polls Futures), reactor (I/O notifications), timer. Examples: tokio, async-std, smol. Manages task scheduling and system resources. Required for async code to run.", "source": "https://tokio.rs/tokio/tutorial"}
{"id": "async_011", "domain": "async_programming", "difficulty": "medium", "question": "What is Send + Sync and why does it matter for async?", "ground_truth": "Send allows transfer between threads. Sync allows shared references across threads. Async tasks must be Send if spawned on multi-threaded runtime. Non-Send types (Rc, RefCell) cause errors in tokio::spawn. Use Arc, Mutex for shared state.", "source": "https://tokio.rs/tokio/tutorial/spawning"}
{"id": "async_012", "domain": "async_programming", "difficulty": "medium", "question": "How do you handle timeouts in async Rust?", "ground_truth": "Use tokio::time::timeout(duration, future). Returns Result<T, Elapsed>. Cancels Future if timeout expires. Example: timeout(Duration::from_secs(5), my_future).await?", "source": "https://tokio.rs/tokio/tutorial/select"}
{"id": "async_013", "domain": "async_programming", "difficulty": "medium", "question": "What is the difference between spawn and spawn_blocking?", "ground_truth": "tokio::spawn runs async task on async runtime. spawn_blocking runs sync blocking code on thread pool. Use spawn_blocking for CPU-intensive work or blocking I/O to avoid blocking async runtime.", "source": "https://tokio.rs/tokio/tutorial/spawning"}
{"id": "async_014", "domain": "async_programming", "difficulty": "medium", "question": "How do you share state between async tasks?", "ground_truth": "Use Arc<Mutex<T>> or Arc<RwLock<T>>. Arc enables shared ownership across tasks. Mutex/RwLock provide interior mutability. Tokio provides async-aware locks. Example: let shared = Arc::new(Mutex::new(data)); clone Arc for each task.", "source": "https://tokio.rs/tokio/tutorial/shared-state"}
{"id": "async_015", "domain": "async_programming", "difficulty": "medium", "question": "What is pin and why is it needed for async?", "ground_truth": "Pin prevents moving self-referential Futures (futures holding references to their own fields). Required for safe async/await. Box::pin() heap-allocates and pins. Futures are often pinned before polling.", "source": "https://doc.rust-lang.org/std/pin/index.html"}
{"id": "async_016", "domain": "async_programming", "difficulty": "medium", "question": "How do async channels work in tokio?", "ground_truth": "tokio::sync::mpsc creates async channels. mpsc::channel() (bounded) or mpsc::unbounded_channel(). Send messages with send().await, receive with recv().await. Non-blocking communication between tasks.", "source": "https://tokio.rs/tokio/tutorial/channels"}
{"id": "async_017", "domain": "async_programming", "difficulty": "medium", "question": "What is join! and how does it differ from select!?", "ground_truth": "join! awaits multiple Futures concurrently, waits for all to complete. Returns tuple of results. select! returns when first completes, cancels others. Use join! when you need all results.", "source": "https://tokio.rs/tokio/tutorial/select"}
{"id": "async_018", "domain": "async_programming", "difficulty": "medium", "question": "How do you make a trait async?", "ground_truth": "Async trait methods aren't directly supported (yet). Workaround: use async-trait crate with #[async_trait] macro. Adds boxing overhead. Alternative: return impl Future or use GATs (generic associated types) when stable.", "source": "https://rust-lang.github.io/async-book/07_workarounds/05_async_in_traits.html"}
{"id": "async_019", "domain": "async_programming", "difficulty": "hard", "question": "Explain structured concurrency and cancellation in async Rust.", "ground_truth": "Structured concurrency: child tasks live within parent's scope. Rust doesn't enforce but tokio::join! and try_join! provide patterns. Cancellation via Drop: dropping Future stops execution. Use CancellationToken for explicit cancellation across tasks.", "source": "https://tokio.rs/tokio/tutorial/select"}
{"id": "async_020", "domain": "async_programming", "difficulty": "hard", "question": "What is the difference between multi-threaded and single-threaded async runtimes?", "ground_truth": "Multi-threaded (tokio multi-threaded): work stealing, tasks can move threads, requires Send. Single-threaded (current_thread): one thread, no Send requirement, simpler. Choose based on workload: single-threaded for I/O-only, multi-threaded for CPU work.", "source": "https://tokio.rs/tokio/topics/runtime"}
{"id": "async_021", "domain": "async_programming", "difficulty": "hard", "question": "How does Future polling work internally?", "ground_truth": "Executor calls future.poll(cx). Returns Poll::Pending (not ready, registered waker) or Poll::Ready(value). Waker notifies executor when Future makes progress. Executor re-polls. Async/await compiles to state machine implementing Future.", "source": "https://rust-lang.github.io/async-book/02_execution/02_future.html"}
{"id": "unsafe_001", "domain": "unsafe_rust", "difficulty": "easy", "question": "What does the unsafe keyword mean?", "ground_truth": "unsafe allows operations that Rust can't verify for safety: dereferencing raw pointers, calling unsafe functions, implementing unsafe traits, accessing/modifying mutable statics, accessing union fields. Programmer guarantees safety.", "source": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}
{"id": "unsafe_002", "domain": "unsafe_rust", "difficulty": "easy", "question": "What are raw pointers in Rust?", "ground_truth": "Raw pointers *const T and *mut T don't follow borrowing rules. Can be null, can dangle, no lifetime tracking. Creating them is safe, dereferencing requires unsafe. Used for FFI and low-level code.", "source": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}
{"id": "unsafe_003", "domain": "unsafe_rust", "difficulty": "easy", "question": "Why would you need to use unsafe?", "ground_truth": "Unsafe enables: FFI with C libraries, implementing low-level abstractions (allocators, smart pointers), performance optimizations bypassing checks, interfacing with hardware. Goal: safe abstractions over unsafe code.", "source": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}
{"id": "unsafe_004", "domain": "unsafe_rust", "difficulty": "easy", "question": "What is FFI in Rust?", "ground_truth": "FFI (Foreign Function Interface) allows calling code from other languages (mainly C). Use extern keyword to declare foreign functions. Calling C functions requires unsafe. Used for system APIs and existing libraries.", "source": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}
{"id": "unsafe_005", "domain": "unsafe_rust", "difficulty": "easy", "question": "What operations require unsafe?", "ground_truth": "Five unsafe superpowers: dereference raw pointers, call unsafe functions/methods, access/modify mutable static variables, implement unsafe traits, access union fields. Everything else is safe Rust.", "source": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}
{"id": "unsafe_006", "domain": "unsafe_rust", "difficulty": "easy", "question": "What is undefined behavior?", "ground_truth": "Undefined behavior (UB) is code that violates language rules, enabling compiler to assume impossible conditions. Causes unpredictable results. Examples: null pointer dereference, data races, use-after-free. Safe Rust prevents UB; unsafe must avoid it.", "source": "https://doc.rust-lang.org/reference/behavior-considered-undefined.html"}
{"id": "unsafe_007", "domain": "unsafe_rust", "difficulty": "easy", "question": "Can you have memory leaks in safe Rust?", "ground_truth": "Yes, safe Rust can leak memory (reference cycles with Rc, Box::leak, mem::forget). Memory leaks are safe but wastes memory. They're considered safe because they don't cause UB or violate memory safety.", "source": "https://doc.rust-lang.org/nomicon/leaking.html"}
{"id": "unsafe_008", "domain": "unsafe_rust", "difficulty": "medium", "question": "How do you create a safe abstraction over unsafe code?", "ground_truth": "Encapsulate unsafe in safe API. Verify all safety invariants hold. Document assumptions. Example: Vec internally uses unsafe but provides safe interface. Use private fields, validate inputs, maintain invariants. Public API must be safe to use.", "source": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}
{"id": "unsafe_009", "domain": "unsafe_rust", "difficulty": "medium", "question": "What is the difference between *const T and *mut T?", "ground_truth": "*const T is immutable raw pointer (like &T but without safety). *mut T is mutable raw pointer (like &mut T but unsafe). Both can be null or dangling. Dereferencing either requires unsafe block.", "source": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}
{"id": "unsafe_010", "domain": "unsafe_rust", "difficulty": "medium", "question": "How do you call a C function from Rust?", "ground_truth": "Declare with extern block: extern \"C\" { fn c_func(x: i32) -> i32; }. Call in unsafe block: unsafe { c_func(42) }. Use #[link] to specify library. Convert types carefully (use libc crate for C types).", "source": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}
{"id": "unsafe_011", "domain": "unsafe_rust", "difficulty": "hard", "question": "What are the rules for implementing unsafe traits like Send and Sync?", "ground_truth": "unsafe trait means implementor must uphold safety invariants. Send: type can be transferred between threads. Sync: &T is Send (safe to share refs). Implement only if type truly satisfies conditions. Compiler can't verify, programmer must ensure correctness.", "source": "https://doc.rust-lang.org/nomicon/send-and-sync.html"}
{"id": "unsafe_012", "domain": "unsafe_rust", "difficulty": "hard", "question": "What is transmute and why is it dangerous?", "ground_truth": "mem::transmute reinterprets bits of one type as another. Extremely unsafe: can violate type safety, create invalid values, undefined behavior. Use only when certain about memory layout. Prefer safer alternatives like From/Into, as_bytes(), union.", "source": "https://doc.rust-lang.org/std/mem/fn.transmute.html"}
{"id": "patterns_001", "domain": "common_patterns", "difficulty": "easy", "question": "What is the Result<T, E> type used for?", "ground_truth": "Result represents operations that can succeed (Ok(T)) or fail (Err(E)). Used for error handling. Must be handled explicitly. Use ? operator to propagate errors. Prefer Result over panicking.", "source": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html"}
{"id": "patterns_002", "domain": "common_patterns", "difficulty": "easy", "question": "What is the Option<T> type?", "ground_truth": "Option represents optional values: Some(T) or None. Used instead of null. Must be handled explicitly preventing null pointer errors. Use pattern matching, unwrap(), unwrap_or(), or ? with Result.", "source": "https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html"}
{"id": "patterns_003", "domain": "common_patterns", "difficulty": "easy", "question": "What is pattern matching with match?", "ground_truth": "match performs exhaustive pattern matching on enums. All cases must be covered. Returns value. Example: match option { Some(x) => x, None => 0 }. More powerful than switch statements.", "source": "https://doc.rust-lang.org/book/ch06-02-match.html"}
{"id": "patterns_004", "domain": "common_patterns", "difficulty": "easy", "question": "What is the ? operator?", "ground_truth": "? operator propagates errors. If Result is Err or Option is None, returns early from function. Converts error types with From trait. Syntactic sugar for match/return pattern. Only works in functions returning Result/Option.", "source": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html"}
{"id": "patterns_005", "domain": "common_patterns", "difficulty": "easy", "question": "What are closures in Rust?", "ground_truth": "Closures are anonymous functions that capture environment. Syntax: |params| expr or |params| { body }. Implement Fn, FnMut, or FnOnce traits. Used with iterators, callbacks. Can capture by reference or value.", "source": "https://doc.rust-lang.org/book/ch13-01-closures.html"}
{"id": "patterns_006", "domain": "common_patterns", "difficulty": "easy", "question": "What is the difference between iter(), iter_mut(), and into_iter()?", "ground_truth": "iter() borrows immutably (yields &T). iter_mut() borrows mutably (yields &mut T). into_iter() consumes collection (yields T). Choose based on whether you need to modify, consume, or just read.", "source": "https://doc.rust-lang.org/book/ch13-02-iterators.html"}
{"id": "patterns_007", "domain": "common_patterns", "difficulty": "easy", "question": "What is if let syntax?", "ground_truth": "if let is concise pattern matching for single case. Example: if let Some(x) = option { use x }. Less verbose than match when only one pattern matters. Else clause optional.", "source": "https://doc.rust-lang.org/book/ch06-03-if-let.html"}
{"id": "patterns_008", "domain": "common_patterns", "difficulty": "easy", "question": "What are commonly used iterator methods?", "ground_truth": "map() transforms elements, filter() selects elements, collect() builds collection, fold() reduces to single value, for_each() applies function, take() limits count, zip() combines iterators. Chain for powerful data processing.", "source": "https://doc.rust-lang.org/book/ch13-02-iterators.html"}
{"id": "patterns_009", "domain": "common_patterns", "difficulty": "easy", "question": "What is the newtype pattern?", "ground_truth": "Newtype wraps existing type in new struct: struct Meters(f64). Creates distinct type with same representation. Used for type safety, implementing external traits, hiding implementation. Zero runtime cost.", "source": "https://doc.rust-lang.org/book/ch19-04-advanced-types.html"}
{"id": "patterns_010", "domain": "common_patterns", "difficulty": "easy", "question": "What is the builder pattern in Rust?", "ground_truth": "Builder pattern constructs complex objects step by step. Methods return self for chaining. Final build() consumes builder, returns object. Example: Config::builder().option1(x).option2(y).build(). Common for configuration.", "source": "https://rust-unofficial.github.io/patterns/patterns/creational/builder.html"}
{"id": "patterns_011", "domain": "common_patterns", "difficulty": "medium", "question": "How do you implement custom error types?", "ground_truth": "Define enum with error variants. Derive Error, Debug, Display traits or implement manually. Use thiserror crate to simplify. Include context. Support conversion with From. Example: enum MyError { Io(io::Error), Parse(ParseError) }.", "source": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html"}
{"id": "patterns_012", "domain": "common_patterns", "difficulty": "medium", "question": "What is the From trait pattern for error conversion?", "ground_truth": "Implement From<OtherError> for MyError to enable ? operator to convert errors automatically. Example: impl From<io::Error> for MyError { fn from(e: io::Error) -> Self { MyError::Io(e) } }. Enables ergonomic error propagation.", "source": "https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html"}
{"id": "patterns_013", "domain": "common_patterns", "difficulty": "medium", "question": "How do you use unwrap_or_else and when is it better than unwrap_or?", "ground_truth": "unwrap_or_else takes closure, only evaluates if None/Err (lazy). unwrap_or takes value, always evaluates (eager). Use unwrap_or_else when default is expensive to compute. Example: opt.unwrap_or_else(|| expensive_fn()).", "source": "https://doc.rust-lang.org/std/option/enum.Option.html"}
{"id": "patterns_014", "domain": "common_patterns", "difficulty": "medium", "question": "What is the type state pattern?", "ground_truth": "Type state uses Rust's type system to enforce state machine correctness at compile time. Different states are different types. Invalid transitions won't compile. Methods consume self, return new state. Zero runtime cost.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/typestate.html"}
{"id": "patterns_015", "domain": "common_patterns", "difficulty": "medium", "question": "How do iterators work and what is lazy evaluation?", "ground_truth": "Iterators are lazy: methods like map/filter don't execute until consumed by collect/for_each. Build processing pipeline cheaply. Only compute what's needed. Chain operations efficiently. Call adapters (map) then consumers (collect).", "source": "https://doc.rust-lang.org/book/ch13-02-iterators.html"}
{"id": "patterns_016", "domain": "common_patterns", "difficulty": "medium", "question": "What is the strategy pattern in Rust?", "ground_truth": "Strategy pattern uses traits to define interchangeable algorithms. Accept trait object or generic with trait bound. Example: fn sort<T: SortStrategy>(data: &mut [i32], strategy: T). Enables runtime or compile-time polymorphism.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/strategy.html"}
{"id": "patterns_017", "domain": "common_patterns", "difficulty": "medium", "question": "How do you implement a command pattern?", "ground_truth": "Command pattern: trait Command { fn execute(&self); }. Struct per command implements trait. Store in Vec<Box<dyn Command>>. Enables undo/redo, queuing. Example: editor commands, transaction logs.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/command.html"}
{"id": "patterns_018", "domain": "common_patterns", "difficulty": "medium", "question": "What is the visitor pattern and why is it less common in Rust?", "ground_truth": "Visitor separates algorithms from data structures. Less common in Rust because pattern matching on enums is more ergonomic. Rust's match is exhaustive, catches missing cases. Match is preferred for most scenarios.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/visitor.html"}
{"id": "patterns_019", "domain": "common_patterns", "difficulty": "medium", "question": "How do you use std::mem::take?", "ground_truth": "mem::take() swaps value with default, returns original. Useful when you need to move out of &mut without clone. Example: let data = mem::take(&mut self.field). Requires Default trait. Zero-cost abstraction.", "source": "https://doc.rust-lang.org/std/mem/fn.take.html"}
{"id": "patterns_020", "domain": "common_patterns", "difficulty": "medium", "question": "What is the RAII pattern in Rust?", "ground_truth": "RAII (Resource Acquisition Is Initialization): resources tied to object lifetime. Acquired in constructor, released in Drop. Guarantees cleanup. Example: File, Mutex, network sockets. Rust enforces RAII via ownership and Drop.", "source": "https://doc.rust-lang.org/book/ch15-03-drop.html"}
{"id": "patterns_021", "domain": "common_patterns", "difficulty": "hard", "question": "Implement the typestate pattern for a state machine with compile-time guarantees.", "ground_truth": "Example: struct Locked, Unlocked; struct Door<State>(State); impl Door<Locked> { fn unlock(self) -> Door<Unlocked> }. impl Door<Unlocked> { fn lock(self) -> Door<Locked> }. Invalid transitions won't compile. Uses zero-sized types, no runtime cost.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/typestate.html"}
{"id": "patterns_022", "domain": "common_patterns", "difficulty": "hard", "question": "How do you implement extension traits?", "ground_truth": "Extension traits add methods to existing types. Define trait with methods, implement for target types. Example: trait MyExt { fn new_method(&self); } impl MyExt for String { ... }. Users import trait to use methods.", "source": "https://rust-lang.github.io/rfcs/0445-extension-trait-conventions.html"}
{"id": "patterns_023", "domain": "common_patterns", "difficulty": "hard", "question": "What is the sealed trait pattern and when should you use it?", "ground_truth": "Sealed traits prevent external implementations. Use private supertrait in private module: mod sealed { pub trait Sealed {} } pub trait MyTrait: sealed::Sealed. Only crate can implement. Prevents breaking changes from new trait methods.", "source": "https://rust-lang.github.io/api-guidelines/future-proofing.html"}
{"id": "ownership_031", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is std::mem::replace and when would you use it?", "ground_truth": "mem::replace swaps value with provided one, returns original. Useful for moving out of borrowed context. Example: let old = mem::replace(&mut self.field, new_value). Similar to take but provides custom replacement.", "source": "https://doc.rust-lang.org/std/mem/fn.replace.html"}
{"id": "ownership_032", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How does the Cow (Clone-on-Write) type work?", "ground_truth": "Cow<'a, T> delays cloning until mutation. Can hold borrowed or owned data. Cow::Borrowed for reads, .to_mut() clones if borrowed. Optimizes for read-heavy scenarios. Common with strings: Cow<'a, str>.", "source": "https://doc.rust-lang.org/std/borrow/enum.Cow.html"}
{"id": "ownership_033", "domain": "ownership_borrowing", "difficulty": "hard", "question": "What are the lifetime variance rules for function pointers?", "ground_truth": "Function pointers are contravariant in argument lifetimes (shorter lifetime can be used where longer expected) and covariant in return lifetimes. This allows safe subtyping for callbacks while preventing dangling references.", "source": "https://doc.rust-lang.org/nomicon/subtyping.html"}
{"id": "ownership_034", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What does mem::forget do and why is it safe?", "ground_truth": "mem::forget prevents Drop from running, leaking memory. It's safe because memory leaks don't cause UB or violate memory safety. Used when transferring ownership to other systems (FFI). Prefer ManuallyDrop for explicit control.", "source": "https://doc.rust-lang.org/std/mem/fn.forget.html"}
{"id": "ownership_035", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How do you work with self-referential structs safely?", "ground_truth": "Self-referential structs are tricky due to moving. Solutions: use indices instead of pointers, Pin for immovable types (async), rental pattern (discouraged), or arena allocation. Pin<Box<T>> prevents moves after creation.", "source": "https://doc.rust-lang.org/std/pin/index.html"}
{"id": "traits_025", "domain": "traits_generics", "difficulty": "medium", "question": "What is the TryFrom/TryInto trait pattern?", "ground_truth": "TryFrom/TryInto for fallible conversions returning Result. Like From/Into but can fail. Example: impl TryFrom<u64> for u32. Use when conversion might overflow or be invalid. Implement TryFrom, get TryInto free.", "source": "https://doc.rust-lang.org/std/convert/trait.TryFrom.html"}
{"id": "traits_026", "domain": "traits_generics", "difficulty": "medium", "question": "How do you implement Display vs Debug?", "ground_truth": "Debug ({:?}) for debugging, usually derived. Display ({}) for user-facing output, manually implemented. Display requires formatting logic. Debug includes all fields, Display shows user-friendly representation. Implement both when appropriate.", "source": "https://doc.rust-lang.org/std/fmt/trait.Display.html"}
{"id": "traits_027", "domain": "traits_generics", "difficulty": "hard", "question": "What are generic associated types (GATs) and what problems do they solve?", "ground_truth": "GATs allow associated types with generic parameters. Example: trait Iterator { type Item<'a> where Self: 'a; }. Solves lending iterator problem (returning refs with lifetime tied to &mut self). Enables more expressive trait APIs.", "source": "https://rust-lang.github.io/rfcs/1598-generic_associated_types.html"}
{"id": "traits_028", "domain": "traits_generics", "difficulty": "easy", "question": "What is the PartialEq vs Eq distinction?", "ground_truth": "PartialEq allows == comparison, may not be transitive (f32 due to NaN). Eq is PartialEq + equivalence relation (reflexive, symmetric, transitive). Implement Eq when equality is true equivalence. Most types use Eq.", "source": "https://doc.rust-lang.org/std/cmp/trait.Eq.html"}
{"id": "traits_029", "domain": "traits_generics", "difficulty": "medium", "question": "What is PartialOrd vs Ord?", "ground_truth": "PartialOrd provides partial ordering via <, <=, >, >= (can have incomparable values like NaN). Ord provides total ordering where all values comparable. Ord requires Eq. PartialOrd returns Option, Ord returns Ordering.", "source": "https://doc.rust-lang.org/std/cmp/trait.Ord.html"}
{"id": "traits_030", "domain": "traits_generics", "difficulty": "medium", "question": "How do derive macros work?", "ground_truth": "Derive macros auto-implement traits: #[derive(Debug, Clone)]. Compiler generates implementation based on struct/enum shape. Common derives: Debug, Clone, Copy, PartialEq, Eq, Default. Custom derives via proc macros.", "source": "https://doc.rust-lang.org/book/appendix-03-derivable-traits.html"}
{"id": "async_022", "domain": "async_programming", "difficulty": "medium", "question": "What is the difference between tokio channels (mpsc, oneshot, broadcast, watch)?", "ground_truth": "mpsc: multi-producer single-consumer queue. oneshot: one-time message. broadcast: multiple consumers get each message. watch: single value, receivers see updates. Choose based on communication pattern.", "source": "https://tokio.rs/tokio/tutorial/channels"}
{"id": "async_023", "domain": "async_programming", "difficulty": "medium", "question": "How do you handle backpressure in async streams?", "ground_truth": "Backpressure prevents fast producer overwhelming slow consumer. Use bounded channels (blocks when full), StreamExt::throttle, buffer() with limits. await on send propagates backpressure. Design for graceful degradation.", "source": "https://tokio.rs/tokio/tutorial/channels"}
{"id": "async_024", "domain": "async_programming", "difficulty": "hard", "question": "What is a Waker and how does it work in the async ecosystem?", "ground_truth": "Waker notifies executor that Future can make progress. Passed in Context to poll(). Resource (I/O, timer) stores Waker, calls wake() when ready. Executor re-polls Future. Enables efficient async without busy-waiting.", "source": "https://rust-lang.github.io/async-book/02_execution/03_wakeups.html"}
{"id": "async_025", "domain": "async_programming", "difficulty": "hard", "question": "How do you implement your own Future?", "ground_truth": "Implement Future trait with poll() method. Return Poll::Pending (register waker) or Poll::Ready(value). Store state as struct fields. Use state machine pattern. Call wake() when ready to progress. Rarely neededâ€”use async/await.", "source": "https://rust-lang.github.io/async-book/02_execution/02_future.html"}
{"id": "unsafe_013", "domain": "unsafe_rust", "difficulty": "medium", "question": "What is the difference between &[u8] and *const u8?", "ground_truth": "&[u8] is safe slice with length and safety guarantees. *const u8 is raw pointer, no length, can be null/dangling. Slice has bounds checking. Raw pointer requires unsafe to dereference. Slice is fat pointer (ptr + len), raw pointer is thin.", "source": "https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html"}
{"id": "unsafe_014", "domain": "unsafe_rust", "difficulty": "hard", "question": "What is the difference between #[repr(C)] and default representation?", "ground_truth": "#[repr(C)] uses C-compatible layout (field order preserved, specific alignment). Default Rust repr can reorder fields for optimization. Use #[repr(C)] for FFI, binary formats. Other options: #[repr(packed)], #[repr(align)].", "source": "https://doc.rust-lang.org/reference/type-layout.html"}
{"id": "unsafe_015", "domain": "unsafe_rust", "difficulty": "hard", "question": "What is the aliasing model (stacked borrows) in Rust?", "ground_truth": "Stacked borrows is Rust's aliasing model for unsafe code validation. Tracks borrow stack, invalidates references when rules violated. Enforced by Miri. Violations are UB. Helps reason about raw pointer safety.", "source": "https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md"}
{"id": "unsafe_016", "domain": "unsafe_rust", "difficulty": "medium", "question": "What is ManuallyDrop and when would you use it?", "ground_truth": "ManuallyDrop<T> disables automatic Drop. Value isn't dropped when out of scope. Use for FFI ownership transfer, custom drop order, or preventing drop. Call ManuallyDrop::drop() or ManuallyDrop::take() explicitly to drop.", "source": "https://doc.rust-lang.org/std/mem/struct.ManuallyDrop.html"}
{"id": "unsafe_017", "domain": "unsafe_rust", "difficulty": "medium", "question": "How do you create a safe API for a C library?", "ground_truth": "Wrap unsafe FFI in safe Rust types. Validate inputs. Use RAII for resource management. Convert between Rust and C types carefully. Hide unsafe behind module boundary. Use bindgen to generate declarations. Document invariants.", "source": "https://doc.rust-lang.org/nomicon/ffi.html"}
{"id": "unsafe_018", "domain": "unsafe_rust", "difficulty": "hard", "question": "What is uninitialized memory and how do you handle it safely?", "ground_truth": "Uninitialized memory (MaybeUninit<T>) hasn't been written. Reading is UB. Use MaybeUninit::new(val) or write(). Call assume_init() only after initialization. Used for performance (skip default), arrays, FFI. Very unsafe if misused.", "source": "https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"}
{"id": "patterns_024", "domain": "common_patterns", "difficulty": "medium", "question": "What is and_then vs map for Option and Result?", "ground_truth": "map transforms inner value (Option<T> -> Option<U>). and_then chains operations returning Option/Result (flattens). Use and_then for operations that can fail, map for transformations. and_then is like flatMap in other languages.", "source": "https://doc.rust-lang.org/std/option/enum.Option.html"}
{"id": "patterns_025", "domain": "common_patterns", "difficulty": "medium", "question": "How do you implement the From trait for custom type conversions?", "ground_truth": "impl From<SourceType> for TargetType { fn from(src: SourceType) -> Self { ... } }. Enables .into() automatically. Use for infallible conversions. For fallible, use TryFrom. Common pattern for ergonomic APIs.", "source": "https://doc.rust-lang.org/std/convert/trait.From.html"}
{"id": "patterns_026", "domain": "common_patterns", "difficulty": "hard", "question": "What is the state machine pattern with enums?", "ground_truth": "Use enum variants as states. Each state can have different data. match exhaustively on state. Transitions return new state enum. Example: enum Connection { Idle, Connecting(TcpStream), Connected(Session) }. Type-safe state management.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/state.html"}
{"id": "patterns_027", "domain": "common_patterns", "difficulty": "medium", "question": "How do you use collect() with different collection types?", "ground_truth": "collect() builds collection from iterator. Type inference: let v: Vec<_> = iter.collect(). Turbofish: iter.collect::<Vec<_>>(). Works for Vec, HashMap, HashSet, etc. Returns Result if iterator items are Results.", "source": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect"}
{"id": "patterns_028", "domain": "common_patterns", "difficulty": "easy", "question": "What is the difference between panic! and Result?", "ground_truth": "panic! aborts program (unrecoverable). Result<T, E> enables error handling (recoverable). Use Result for errors caller should handle. Use panic! for invariant violations, logic bugs. panic! unwinds stack or aborts based on config.", "source": "https://doc.rust-lang.org/book/ch09-01-unrecoverable-errors-with-panic.html"}
{"id": "patterns_029", "domain": "common_patterns", "difficulty": "medium", "question": "How do you use filter_map efficiently?", "ground_truth": "filter_map combines filter and map in one step. Takes closure returning Option<T>. Some(x) keeps and transforms, None filters out. More efficient than .filter().map() chained. Example: iter.filter_map(|x| x.parse().ok()).", "source": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map"}
{"id": "patterns_030", "domain": "common_patterns", "difficulty": "medium", "question": "What is the From/Into pattern for builder-style APIs?", "ground_truth": "Accept Into<TargetType> in functions for flexibility. Callers can pass different types that convert. Example: fn foo(s: impl Into<String>) accepts &str or String. Implements builder ergonomics without overhead.", "source": "https://rust-lang.github.io/api-guidelines/flexibility.html"}
{"id": "ownership_036", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is the difference between Vec<T> and &[T]?", "ground_truth": "Vec<T> owns heap-allocated data, growable, mutable. &[T] is borrowed slice, fixed size, doesn't own. Vec can push/pop, slice is view. Use Vec for ownership, &[T] for flexible borrowing.", "source": "https://doc.rust-lang.org/book/ch08-01-vectors.html"}
{"id": "ownership_037", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What does the move keyword do in closures?", "ground_truth": "move forces closure to take ownership of captured variables. Moves values into closure instead of borrowing. Required when closure outlives scope of captured variables. Example: move || { use_value(x) }", "source": "https://doc.rust-lang.org/book/ch13-01-closures.html"}
{"id": "ownership_038", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How do you split a mutable borrow?", "ground_truth": "Use split_at_mut() for slices, or borrow different struct fields simultaneously. Rust allows multiple &mut to disjoint data. Example: let (left, right) = slice.split_at_mut(mid). Each part is independently mutable.", "source": "https://doc.rust-lang.org/std/primitive.slice.html#method.split_at_mut"}
{"id": "ownership_039", "domain": "ownership_borrowing", "difficulty": "hard", "question": "Explain how PhantomData works with lifetimes.", "ground_truth": "PhantomData<&'a T> makes struct act like it owns reference with lifetime 'a, affecting variance and drop checking. Used when struct doesn't directly hold but logically owns reference. Compiler treats it as if field exists.", "source": "https://doc.rust-lang.org/nomicon/phantom-data.html"}
{"id": "ownership_040", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is the difference between as_ref() and as_mut()?", "ground_truth": "as_ref() converts to immutable reference (&T). as_mut() converts to mutable reference (&mut T). AsRef/AsMut traits enable generic code. Cheap conversion without ownership transfer. Common for string/path conversions.", "source": "https://doc.rust-lang.org/std/convert/trait.AsRef.html"}
{"id": "ownership_041", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is String::from vs str::to_string?", "ground_truth": "Both create String from &str. String::from() is From trait method. to_string() uses Display trait. Functionally identical for &str. Preference is style, String::from often clearer for conversions.", "source": "https://doc.rust-lang.org/std/string/struct.String.html"}
{"id": "ownership_042", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How does split lifetime work in iterators?", "ground_truth": "Iterator methods can return references with lifetime tied to &mut self (lending iterator). Standard Iterator can't do this (returns 'static lifetime). GATs enable lending iterators. Complex due to self-reference constraints.", "source": "https://rust-lang.github.io/rfcs/1598-generic_associated_types.html"}
{"id": "ownership_043", "domain": "ownership_borrowing", "difficulty": "hard", "question": "What are the rules for casting lifetimes?", "ground_truth": "Cannot directly cast lifetimes. Coercion happens automatically for compatible lifetimes (longer to shorter). Unsafe code can use transmute but risks UB. Prefer safe patterns or redesign. Lifetime bounds define relationships.", "source": "https://doc.rust-lang.org/nomicon/lifetime-mismatch.html"}
{"id": "ownership_044", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What does clone() do and when should you use it?", "ground_truth": "clone() creates deep copy with separate ownership. Use when you need independent value. Explicit cost indicator. Prefer borrowing when possible. Required for Rc<T>::clone() (ref count), different from expensive clone.", "source": "https://doc.rust-lang.org/std/clone/trait.Clone.html"}
{"id": "ownership_045", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How do you handle circular references?", "ground_truth": "Circular references cause memory leaks with Rc. Use Weak<T> for cycles: parent owns child with Rc, child references parent with Weak. Weak doesn't prevent deallocation. upgrade() returns Option<Rc<T>>.", "source": "https://doc.rust-lang.org/book/ch15-06-reference-cycles.html"}
{"id": "ownership_046", "domain": "ownership_borrowing", "difficulty": "hard", "question": "What is the difference between subtyping and coercion in Rust?", "ground_truth": "Subtyping allows using one type where another expected (lifetime variance). Coercion automatically converts (e.g., &String to &str). Subtyping is type system feature, coercion is implicit conversion. Both enable ergonomic APIs.", "source": "https://doc.rust-lang.org/nomicon/coercions.html"}
{"id": "ownership_047", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How does deref coercion work?", "ground_truth": "Deref coercion automatically converts &T to &U when T: Deref<Target=U>. Enables &String to &str, &Box<T> to &T. Happens at call sites. Reduces explicit dereferencing. Multiple deref steps possible.", "source": "https://doc.rust-lang.org/book/ch15-02-deref.html"}
{"id": "ownership_048", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is the difference between push and extend for Vec?", "ground_truth": "push() adds single element. extend() adds multiple elements from iterator. push takes ownership of one item, extend consumes iterator. extend more efficient for bulk insertions.", "source": "https://doc.rust-lang.org/std/vec/struct.Vec.html"}
{"id": "ownership_049", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How do you work with &mut self methods in method chaining?", "ground_truth": "Methods taking &mut self borrow mutably, can't chain normally. Return &mut Self to enable chaining. Or use interior mutability. Or redesign to take self, return Self (builder pattern).", "source": "https://doc.rust-lang.org/book/ch05-03-method-syntax.html"}
{"id": "ownership_050", "domain": "ownership_borrowing", "difficulty": "hard", "question": "What are the rules for lifetime bounds on generic parameters?", "ground_truth": "T: 'a means T must live at least as long as 'a. Applies to all references in T. Required when storing T with lifetime 'a. Bounds propagate through generic code. Essential for correct lifetime relationships.", "source": "https://doc.rust-lang.org/nomicon/lifetime-mismatch.html"}
{"id": "ownership_051", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How does partial move work with structs?", "ground_truth": "Can move individual fields from struct if other fields implement Copy or aren't used. Moves field-by-field, not whole struct. Remaining fields still accessible. Whole struct becomes partially moved, can't use as whole.", "source": "https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html"}
{"id": "ownership_052", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What is Box::leak and when would you use it?", "ground_truth": "Box::leak consumes Box, returns 'static reference, leaking memory. Use when you need 'static lifetime and don't need to reclaim. Common for global data, FFI. ManuallyDrop provides more control.", "source": "https://doc.rust-lang.org/std/boxed/struct.Box.html#method.leak"}
{"id": "ownership_053", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How do lifetime annotations work in impl blocks?", "ground_truth": "impl<'a> for Type<'a> connects impl lifetime to type. Methods can have additional lifetimes. Lifetime elision applies. Example: impl<'a> Struct<'a> { fn method(&self) -> &'a T }. Relates self to returned reference.", "source": "https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html"}
{"id": "ownership_054", "domain": "ownership_borrowing", "difficulty": "hard", "question": "What is the 'static bound and how is it different from 'static lifetime?", "ground_truth": "T: 'static bound means T has no non-static references (can be owned or 'static ref). 'static lifetime means reference lives entire program. Bound is about what T contains, lifetime is about reference validity duration.", "source": "https://doc.rust-lang.org/rust-by-example/scope/lifetime/static.html"}
{"id": "ownership_055", "domain": "ownership_borrowing", "difficulty": "medium", "question": "How do you handle lifetime issues with async code?", "ground_truth": "Async functions must have 'static bounds for spawned tasks. Use Arc for shared ownership. Owned data in async blocks. .await doesn't extend lifetimes across suspend points. Pin handles self-referential futures.", "source": "https://rust-lang.github.io/async-book/03_async_await/01_chapter.html"}
{"id": "ownership_056", "domain": "ownership_borrowing", "difficulty": "easy", "question": "What does into_iter().collect() do?", "ground_truth": "Consumes collection (into_iter takes ownership), transforms elements, builds new collection. Type of result from collect(). Efficient pipeline for owned transformations. Use iter() if you want to keep original.", "source": "https://doc.rust-lang.org/book/ch13-02-iterators.html"}
{"id": "ownership_057", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is the difference between Rc::clone and .clone()?", "ground_truth": "Rc::clone(&rc) increments reference count (cheap). rc.clone() also works but less clear. Both are shallow copies, increment counter. Prefer Rc::clone for clarity. Arc same pattern for atomic ref counting.", "source": "https://doc.rust-lang.org/book/ch15-04-rc.html"}
{"id": "ownership_058", "domain": "ownership_borrowing", "difficulty": "hard", "question": "How do you implement a self-referential async struct safely?", "ground_truth": "Use Pin<Box<Self>> to prevent moves. Async state machines are self-referential. Pin guarantees address stability. Implement !Unpin or use pin_project. Required for futures holding references to their own fields.", "source": "https://rust-lang.github.io/async-book/04_pinning/01_chapter.html"}
{"id": "ownership_059", "domain": "ownership_borrowing", "difficulty": "medium", "question": "What is the difference between drop and Drop trait?", "ground_truth": "Drop trait defines destructor (drop method). std::mem::drop function forces immediate drop. Drop trait implemented by types, drop() called automatically. Use std::mem::drop(value) for early cleanup.", "source": "https://doc.rust-lang.org/book/ch15-03-drop.html"}
{"id": "ownership_060", "domain": "ownership_borrowing", "difficulty": "easy", "question": "How do you return multiple values from a function?", "ground_truth": "Use tuple: fn foo() -> (i32, String). Or struct for named fields. Destructure at call site: let (x, y) = foo(). Result and Option also common. Choose based on number and meaning of returns.", "source": "https://doc.rust-lang.org/book/ch03-03-how-functions-work.html"}
{"id": "traits_031", "domain": "traits_generics", "difficulty": "easy", "question": "What is a supertrait?", "ground_truth": "Supertrait is trait dependency. trait B: A means implementing B requires A. Types must implement A to implement B. Example: trait Printable: Display. Enables trait composition and constraints.", "source": "https://doc.rust-lang.org/book/ch19-03-advanced-traits.html"}
{"id": "traits_032", "domain": "traits_generics", "difficulty": "medium", "question": "How do you implement Hash for custom types?", "ground_truth": "Derive or manually implement Hash trait. Hash all fields that Eq uses. Required for HashMap/HashSet keys. Must satisfy: a == b implies hash(a) == hash(b). Usually derive both Hash and Eq.", "source": "https://doc.rust-lang.org/std/hash/trait.Hash.html"}
{"id": "traits_033", "domain": "traits_generics", "difficulty": "hard", "question": "What are negative trait bounds and why aren't they stable?", "ground_truth": "Negative bounds (T: !Trait) mean T doesn't implement trait. Useful for specialization, mutually exclusive impls. Unstable due to coherence issues. Workarounds: sealed traits, type system tricks, wait for stability.", "source": "https://github.com/rust-lang/rust/issues/68318"}
{"id": "traits_034", "domain": "traits_generics", "difficulty": "medium", "question": "How do you use the newtype pattern to implement external traits?", "ground_truth": "Wrap external type in new struct: struct Wrapper(ExternalType). Implement trait for Wrapper. Orphan rule allows this. Use Deref for ergonomics. Zero runtime cost with #[repr(transparent)].", "source": "https://doc.rust-lang.org/book/ch19-04-advanced-types.html"}
{"id": "traits_035", "domain": "traits_generics", "difficulty": "easy", "question": "What is the Sized trait?", "ground_truth": "Sized means type has known size at compile time. Most types are Sized. ?Sized means possibly unsized ([T], dyn Trait). Required for stack allocation. Generic params implicitly T: Sized unless ?Sized specified.", "source": "https://doc.rust-lang.org/std/marker/trait.Sized.html"}
{"id": "traits_036", "domain": "traits_generics", "difficulty": "medium", "question": "How do you use trait objects in collections?", "ground_truth": "Store as Box<dyn Trait> or Arc<dyn Trait>. Trait must be object-safe. Vec<Box<dyn Trait>> enables heterogeneous collections. Dynamic dispatch at runtime. Example: Vec<Box<dyn Error>> for mixed errors.", "source": "https://doc.rust-lang.org/book/ch17-02-trait-objects.html"}
{"id": "traits_037", "domain": "traits_generics", "difficulty": "hard", "question": "What is the difference between trait coherence and object safety?", "ground_truth": "Coherence prevents conflicting implementations (orphan rule). Object safety determines if trait can be dyn. Coherence is about impl uniqueness, object safety about vtable viability. Different constraints serving different purposes.", "source": "https://doc.rust-lang.org/reference/items/implementations.html"}
{"id": "traits_038", "domain": "traits_generics", "difficulty": "medium", "question": "How do you implement PartialEq for types with generics?", "ground_truth": "impl<T: PartialEq> PartialEq for MyType<T>. Compare generic fields. Can derive if all fields implement PartialEq. Manual impl when custom equality logic needed. Propagate bounds to implementation.", "source": "https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"}
{"id": "traits_039", "domain": "traits_generics", "difficulty": "easy", "question": "What is the Fn, FnMut, FnOnce hierarchy?", "ground_truth": "FnOnce consumes captured variables (call once). FnMut can mutate captures (call multiple times). Fn only reads captures (call unlimited). Fn: FnMut: FnOnce hierarchy. Compiler chooses most restrictive needed.", "source": "https://doc.rust-lang.org/book/ch13-01-closures.html"}
{"id": "traits_040", "domain": "traits_generics", "difficulty": "medium", "question": "How do you use phantom type parameters?", "ground_truth": "Type parameter not used in struct fields but affects types. Use PhantomData<T> to satisfy compiler. Enables type-state pattern, compile-time tracking. Zero runtime cost. Example: struct Meters<T>(f64, PhantomData<T>).", "source": "https://doc.rust-lang.org/std/marker/struct.PhantomData.html"}
{"id": "async_026", "domain": "async_programming", "difficulty": "medium", "question": "What is the difference between spawn and spawn_local?", "ground_truth": "spawn requires Send (can move threads). spawn_local doesn't require Send (stays on thread). Use spawn_local for !Send types (Rc, RefCell) on single-threaded runtimes. spawn for multi-threaded runtimes.", "source": "https://tokio.rs/tokio/topics/bridging"}
{"id": "async_027", "domain": "async_programming", "difficulty": "hard", "question": "How do you handle cancellation in async Rust?", "ground_truth": "Drop Future to cancel. Use CancellationToken for explicit control. Select with cancel signal. Cancellation is cooperative, Future might not notice immediately. Ensure cleanup in Drop. Structured concurrency helps.", "source": "https://docs.rs/tokio-util/latest/tokio_util/sync/struct.CancellationToken.html"}
{"id": "async_028", "domain": "async_programming", "difficulty": "medium", "question": "What is the difference between tokio::time::sleep and std::thread::sleep?", "ground_truth": "tokio::time::sleep is async, yields control, doesn't block thread. std::thread::sleep blocks thread. Never use std::thread::sleep in asyncâ€”blocks executor. Use tokio sleep for async delays.", "source": "https://tokio.rs/tokio/topics/bridging"}
{"id": "async_029", "domain": "async_programming", "difficulty": "easy", "question": "What is an async runtime?", "ground_truth": "Runtime provides task scheduler and I/O reactor. Polls futures, handles wake notifications. Examples: tokio, async-std, smol. Required to execute async code. Different runtimes for different needs.", "source": "https://rust-lang.github.io/async-book/01_getting_started/04_async_await_primer.html"}
{"id": "async_030", "domain": "async_programming", "difficulty": "hard", "question": "How do you implement async cancellation with cleanup guarantees?", "ground_truth": "Implement Drop for cleanup. Use guard types. Cancellation drops Future, runs Drop. Ensure critical sections complete atomically. CancellationToken for explicit signals. Test cancellation at various points.", "source": "https://tokio.rs/tokio/topics/shutdown"}
{"id": "unsafe_019", "domain": "unsafe_rust", "difficulty": "medium", "question": "What is the difference between as and transmute for pointer casts?", "ground_truth": "as cast is safe for compatible pointer types (*const T to *const U if compatible). transmute reinterprets bits (extremely unsafe). Use as when possible. transmute for exotic casts, careful with size/alignment.", "source": "https://doc.rust-lang.org/nomicon/casts.html"}
{"id": "unsafe_020", "domain": "unsafe_rust", "difficulty": "hard", "question": "What are the rules for aliasing with raw pointers?", "ground_truth": "Raw pointers follow stacked borrows. Dereferencing *const must not alias active *mut. Reading through *mut while *const exists is UB. LLVM assumes non-aliasing. Miri detects violations. Very subtle rules.", "source": "https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md"}
{"id": "patterns_031", "domain": "common_patterns", "difficulty": "medium", "question": "What is the try_fold pattern?", "ground_truth": "try_fold short-circuits on error, like fold but with Result. Returns Result<Acc, E>. Closure returns Result. Stops iteration on Err. Use for operations that can fail during reduction.", "source": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.try_fold"}
{"id": "patterns_032", "domain": "common_patterns", "difficulty": "easy", "question": "How do you use unwrap_or_default?", "ground_truth": "Returns value or default if None/Err. Requires Default trait. More ergonomic than unwrap_or(Default::default()). Example: opt.unwrap_or_default(). Common for collections (empty vec/string).", "source": "https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_default"}
{"id": "patterns_033", "domain": "common_patterns", "difficulty": "medium", "question": "What is the entry API for HashMap?", "ground_truth": "entry(key) gets Entry enum (Occupied/Vacant). or_insert modifies only if absent. Avoids double lookup. Example: map.entry(k).or_insert(v). More efficient than contains + insert.", "source": "https://doc.rust-lang.org/std/collections/struct.HashMap.html#method.entry"}
{"id": "patterns_034", "domain": "common_patterns", "difficulty": "hard", "question": "How do you implement the strategy pattern with enums vs traits?", "ground_truth": "Enum: variants are strategies, match dispatches. Trait: types implement strategy trait, dynamic or static dispatch. Enum: closed set, exhaustive matching. Trait: open set, extensible. Choose based on extensibility needs.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/strategy.html"}
{"id": "patterns_035", "domain": "common_patterns", "difficulty": "medium", "question": "How do you chain Result operations with and_then?", "ground_truth": "and_then chains operations returning Result. If Ok, applies function. If Err, propagates error. Example: result.and_then(|x| operation(x)). Alternative to nested matches. Similar to ? but functional style.", "source": "https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then"}
{"id": "patterns_036", "domain": "common_patterns", "difficulty": "easy", "question": "What is matches! macro?", "ground_truth": "matches!(value, pattern) returns bool. Concise pattern checking. Example: matches!(x, Some(42)). More readable than match that returns true/false. Supports guards.", "source": "https://doc.rust-lang.org/std/macro.matches.html"}
{"id": "patterns_037", "domain": "common_patterns", "difficulty": "medium", "question": "How do you use partition with iterators?", "ground_truth": "partition splits iterator into two collections based on predicate. Returns tuple (true_collection, false_collection). Example: let (even, odd) = nums.iter().partition(|&n| n % 2 == 0). Single pass through data.", "source": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.partition"}
{"id": "patterns_038", "domain": "common_patterns", "difficulty": "hard", "question": "What is the typestate pattern with zero-sized types?", "ground_truth": "States as zero-sized types: struct Locked; struct Unlocked;. Methods on State<Locked>/State<Unlocked>. Transitions move between state types. Compile-time state checking. No runtime overhead. Invalid operations won't compile.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/typestate.html"}
{"id": "patterns_039", "domain": "common_patterns", "difficulty": "medium", "question": "How do you implement the adapter pattern?", "ground_truth": "Wrap type providing new interface. Implement trait for wrapper. Use Deref for transparent access. Newtype pattern common form. Example: struct FileAdapter(File); impl MyTrait for FileAdapter. Enables interface translation.", "source": "https://rust-unofficial.github.io/patterns/patterns/structural/adapter.html"}
{"id": "patterns_040", "domain": "common_patterns", "difficulty": "medium", "question": "What is ok_or and ok_or_else for Option?", "ground_truth": "ok_or converts Option to Result. Takes error value. ok_or_else takes closure (lazy error). Example: opt.ok_or(\"error\") or opt.ok_or_else(|| create_error()). Use ok_or_else for expensive errors.", "source": "https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or"}
{"id": "patterns_041", "domain": "common_patterns", "difficulty": "easy", "question": "How do you use take with Option?", "ground_truth": "take() removes value from Option, leaving None. Returns original value. Requires &mut Option. Example: let val = opt_field.take(). Useful for moving out of &mut self.", "source": "https://doc.rust-lang.org/std/option/enum.Option.html#method.take"}
{"id": "patterns_042", "domain": "common_patterns", "difficulty": "medium", "question": "What is the difference between inspect and map?", "ground_truth": "inspect calls closure for side effects, passes value through unchanged. map transforms value. Use inspect for debugging, logging. map for transformation. inspect preserves type, map changes it.", "source": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.inspect"}
{"id": "patterns_043", "domain": "common_patterns", "difficulty": "hard", "question": "How do you implement the witness pattern?", "ground_truth": "Type proves property exists. Return witness type guaranteeing invariant. Example: struct NonEmpty<T>(Vec<T>); ensures vec not empty. Encode constraints in types. Compiler enforces correctness. Runtime checks become type-level.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/typestate.html"}
{"id": "patterns_044", "domain": "common_patterns", "difficulty": "medium", "question": "How do you use scan in iterator chains?", "ground_truth": "scan maintains state across iterations. Like fold but yields intermediate values. Takes initial state and closure. Example: iter.scan(0, |state, x| { *state += x; Some(*state) }). Useful for running computations.", "source": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan"}
{"id": "patterns_045", "domain": "common_patterns", "difficulty": "easy", "question": "What is the difference between iter().filter().map() and iter().filter_map()?", "ground_truth": "filter().map() is two passes, chains filter then map. filter_map() combines in one pass, more efficient. filter_map takes closure returning Option. Use filter_map when filtering and transforming simultaneously.", "source": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter_map"}
{"id": "patterns_046", "domain": "common_patterns", "difficulty": "medium", "question": "How do you implement lazy evaluation with closures?", "ground_truth": "Store closure, execute when needed. Example: struct Lazy<T, F: FnOnce() -> T>(Option<F>, Option<T>). Call closure on first access, cache result. Used for expensive computations. once_cell/lazy_static crates provide this.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/strategy.html"}
{"id": "patterns_047", "domain": "common_patterns", "difficulty": "hard", "question": "What is the rental pattern and why is it problematic?", "ground_truth": "Rental stores self-referential data (owner and reference). Problematic: unsafe, complex lifetimes, violates move semantics. Deprecated approach. Better: use indices, restructure to avoid, or Pin for async. Maintained but not recommended.", "source": "https://doc.rust-lang.org/nomicon/lifetime-mismatch.html"}
{"id": "patterns_048", "domain": "common_patterns", "difficulty": "medium", "question": "How do you use cloned() with iterators?", "ground_truth": "cloned() clones each &T to T. Example: vec.iter().cloned(). Enables owned operations on borrowed data. Requires Clone. Alternative to collect() when transforming. More explicit than into_iter on clone.", "source": "https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.cloned"}
{"id": "patterns_049", "domain": "common_patterns", "difficulty": "easy", "question": "What is the expect method and when should you use it?", "ground_truth": "expect(msg) like unwrap but with custom panic message. Use for errors that should never happen. Better than unwrap for debugging. Example: file.read().expect(\"config must exist\"). Documents assumptions.", "source": "https://doc.rust-lang.org/std/option/enum.Option.html#method.expect"}
{"id": "patterns_050", "domain": "common_patterns", "difficulty": "medium", "question": "How do you implement the memento pattern in Rust?", "ground_truth": "Store state snapshots for undo. Clone state or use persistent data structures. Example: Vec<State> for history. Each checkpoint clones. Requires Clone on state. Use for editor undo, transaction rollback.", "source": "https://rust-unofficial.github.io/patterns/patterns/behavioural/command.html"}
