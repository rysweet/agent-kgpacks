[
  {
    "id": "ma_001",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is the primary purpose of Microsoft Agent Framework?",
    "ground_truth": "Microsoft Agent Framework is a unified SDK for building, orchestrating, and deploying AI agents and multi-agent workflows. It converges AutoGen and Semantic Kernel into a single framework for agent development.",
    "source": "overview"
  },
  {
    "id": "ma_002",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What two major frameworks does Microsoft Agent Framework unify?",
    "ground_truth": "Microsoft Agent Framework converges AutoGen and Semantic Kernel into a unified SDK for building and orchestrating AI agents.",
    "source": "framework_convergence"
  },
  {
    "id": "ma_003",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is the @ai_function decorator used for in Microsoft Agent Framework?",
    "ground_truth": "The @ai_function decorator is used to mark functions as AI-callable tools that can be invoked by agents within the framework.",
    "source": "ai_function_decorator"
  },
  {
    "id": "ma_004",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "Name three orchestration patterns supported by Microsoft Agent Framework.",
    "ground_truth": "Microsoft Agent Framework supports sequential, concurrent, handoff, group chat, and magentic orchestration patterns for multi-agent workflows.",
    "source": "orchestration_patterns"
  },
  {
    "id": "ma_005",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is the role of ChatAgent abstraction in Microsoft Agent Framework?",
    "ground_truth": "ChatAgent abstraction provides a unified interface for building and interacting with AI agents, standardizing how agents communicate and process messages.",
    "source": "chat_agent_abstraction"
  },
  {
    "id": "ma_006",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is the primary purpose of checkpointing in Agent Framework's state management?",
    "ground_truth": "Checkpointing in state management enables persistence of agent state, allowing long-running processes to resume from saved points without losing context.",
    "source": "state_management"
  },
  {
    "id": "ma_007",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is the Agent2Agent (A2A) protocol used for?",
    "ground_truth": "The Agent2Agent (A2A) protocol enables communication and interaction between multiple agents within the framework, facilitating agent-to-agent collaboration.",
    "source": "a2a_protocol"
  },
  {
    "id": "ma_008",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is MCP integration in Microsoft Agent Framework?",
    "ground_truth": "MCP (Model Context Protocol) integration allows agents to interact with external tools and systems through a standardized protocol for model-tool communication.",
    "source": "mcp_integration"
  },
  {
    "id": "ma_009",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is the Process Framework used for in Agent Framework?",
    "ground_truth": "The Process Framework is used for building deterministic business workflows that follow explicit decision logic and predefined execution paths.",
    "source": "process_framework"
  },
  {
    "id": "ma_010",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What are graph-based Workflow APIs in Microsoft Agent Framework?",
    "ground_truth": "Graph-based Workflow APIs allow developers to define agent workflows as directed graphs, where nodes represent agents or tasks and edges represent control flow and dependencies.",
    "source": "workflow_apis"
  },
  {
    "id": "ma_011",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "How can agents be used within workflows in Microsoft Agent Framework?",
    "ground_truth": "Agents can be integrated into workflows as nodes that execute tasks, communicate with other agents, and pass data through workflow edges in a coordinated manner.",
    "source": "agents_in_workflows"
  },
  {
    "id": "ma_012",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is the Workflow Builder in Microsoft Agent Framework?",
    "ground_truth": "The Workflow Builder is a tool for constructing and configuring workflows visually or programmatically, defining agent interactions and execution logic.",
    "source": "workflow_builder"
  },
  {
    "id": "ma_013",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "Name two key components of tool integration in Microsoft Agent Framework.",
    "ground_truth": "Tool integration includes model clients for LLM interactions and the @ai_function decorator for exposing functions as callable tools to agents.",
    "source": "tool_integration"
  },
  {
    "id": "ma_014",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is Azure AI Foundry deployment in the context of Agent Framework?",
    "ground_truth": "Azure AI Foundry deployment enables hosting and running Agent Framework applications on Azure cloud infrastructure for scalable, enterprise-grade agent deployments.",
    "source": "azure_deployment"
  },
  {
    "id": "ma_015",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is the purpose of the AutoGen to Microsoft Agent Framework Migration Guide?",
    "ground_truth": "The migration guide provides instructions and best practices for developers to transition existing AutoGen implementations to the new Microsoft Agent Framework.",
    "source": "autogen_migration"
  },
  {
    "id": "ma_016",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What does the Semantic Kernel to Microsoft Agent Framework Migration Guide cover?",
    "ground_truth": "The migration guide explains how to refactor Semantic Kernel applications to leverage Microsoft Agent Framework's unified APIs and orchestration capabilities.",
    "source": "semantic_kernel_migration"
  },
  {
    "id": "ma_017",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "Can workflows be used as agents in Microsoft Agent Framework?",
    "ground_truth": "Yes, workflows can be used as agents, allowing complex workflow definitions to be treated as reusable agent components within larger orchestration scenarios.",
    "source": "workflows_as_agents"
  },
  {
    "id": "ma_018",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What is the handoff orchestration pattern in Agent Framework?",
    "ground_truth": "The handoff pattern allows one agent to delegate a task to another agent, enabling sequential agent collaboration where control passes between agents based on task requirements.",
    "source": "handoff_pattern"
  },
  {
    "id": "ma_019",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What does the group chat orchestration pattern enable?",
    "ground_truth": "The group chat pattern enables multiple agents to communicate and collaborate within a shared conversation context, allowing collective problem-solving and information exchange.",
    "source": "group_chat_pattern"
  },
  {
    "id": "ma_020",
    "domain": "microsoft_agent_framework",
    "difficulty": "easy",
    "question": "What are custom agents in Microsoft Agent Framework?",
    "ground_truth": "Custom agents are user-defined agents built by extending ChatAgent abstractions with specialized behaviors, tools, and logic tailored to specific application requirements.",
    "source": "custom_agents"
  },
  {
    "id": "ma_021",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "How does the @ai_function decorator differ from traditional tool registration in AutoGen, and what advantage does it provide in the Agent Framework?",
    "ground_truth": "The @ai_function decorator is a simplified, declarative approach that automatically registers Python functions as tools available to agents, reducing boilerplate code compared to AutoGen's manual tool definition and registration process. It enables direct function binding without explicit tool schema creation.",
    "source": "ai_function_decorator"
  },
  {
    "id": "ma_022",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "Explain the relationship between ChatAgent abstractions and the underlying model clients in the Agent Framework. What role does each play?",
    "ground_truth": "ChatAgent abstractions provide the high-level agent interface and behavior logic, while model clients (such as OpenAI, Azure OpenAI, or Ollama clients) handle low-level API communication and model interactions. ChatAgent orchestrates agent logic while model clients execute the actual LLM calls.",
    "source": "chatagent_abstractions"
  },
  {
    "id": "ma_023",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "What is the primary difference between sequential and concurrent orchestration patterns in Agent Framework workflows, and when would you use each?",
    "ground_truth": "Sequential orchestration executes agents or tasks one after another in a defined order, useful for dependent workflows; concurrent orchestration runs multiple agents or tasks in parallel, ideal for independent tasks requiring speedup. Choose sequential when output feeds into next step, concurrent when tasks are independent.",
    "source": "orchestration_patterns"
  },
  {
    "id": "ma_024",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "How does the handoff orchestration pattern work in Agent Framework, and what problem does it solve in multi-agent systems?",
    "ground_truth": "Handoff allows one agent to transfer control and context to another agent based on task requirements or complexity. It solves the problem of routing different tasks to specialized agents without requiring a central coordinator, enabling more modular and scalable multi-agent architectures.",
    "source": "handoff_pattern"
  },
  {
    "id": "ma_025",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "What is checkpointing in the context of Agent Framework state management, and why is it critical for long-running processes?",
    "ground_truth": "Checkpointing is the ability to save agent state and execution progress at defined points, allowing workflows to resume from the last checkpoint if interrupted. This is critical for long-running processes because it prevents data loss, enables fault tolerance, and reduces redundant computation on restart.",
    "source": "state_management_checkpointing"
  },
  {
    "id": "ma_026",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "Compare the group chat orchestration pattern with the magentic pattern in Agent Framework. What distinguishes them?",
    "ground_truth": "Group chat enables multiple agents to discuss and collaborate synchronously in a shared conversation context, reaching consensus through dialogue. Magentic is an advanced pattern that manages agent interactions more dynamically, often with specialized roles or priority-based message handling for complex multi-agent scenarios.",
    "source": "group_chat_magentic_patterns"
  },
  {
    "id": "ma_027",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "How does the Agent2Agent (A2A) protocol enable communication between agents in the Agent Framework ecosystem?",
    "ground_truth": "A2A protocol provides a standardized messaging format and interface for direct agent-to-agent communication, enabling agents built with different frameworks or on different systems to interoperate seamlessly without requiring a central message broker.",
    "source": "a2a_protocol"
  },
  {
    "id": "ma_028",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "What is the relationship between graph-based Workflow APIs and the Process Framework in Agent Framework?",
    "ground_truth": "Graph-based Workflow APIs provide a flexible, visual way to define agent workflows as directed graphs with nodes and edges representing agents and transitions. The Process Framework focuses on deterministic, step-by-step business workflows with guaranteed execution order and state tracking.",
    "source": "workflow_apis_process_framework"
  },
  {
    "id": "ma_029",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "When migrating from AutoGen to Agent Framework, what are the key architectural changes you must account for?",
    "ground_truth": "Key changes include shifting from AutoGen's explicit agent group messaging to Agent Framework's unified orchestration patterns, adapting tool registration from AutoGen's format to @ai_function decorator, and restructuring workflows to use graph-based Workflow APIs instead of AutoGen's agent_executor patterns.",
    "source": "autogen_migration"
  },
  {
    "id": "ma_030",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "What advantages does Semantic Kernel integration provide when migrating to Agent Framework, particularly regarding plugin composition?",
    "ground_truth": "Semantic Kernel integration allows reuse of existing SK plugins and skills directly in Agent Framework agents through unified model client abstraction, preserving prior investments in SK-based development while gaining Agent Framework's superior orchestration and multi-agent capabilities.",
    "source": "semantic_kernel_integration"
  },
  {
    "id": "ma_031",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "How does tool integration work in Agent Framework, and what formats does it support beyond @ai_function?",
    "ground_truth": "Tool integration in Agent Framework supports @ai_function decorator for Python functions, OpenAPI/Swagger specifications for REST endpoints, and Semantic Kernel native plugins. All formats are normalized into a unified tool schema that agents can discover and invoke.",
    "source": "tool_integration"
  },
  {
    "id": "ma_032",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "Explain how MCP (Model Context Protocol) integration enhances Agent Framework capabilities. What new scenarios does it enable?",
    "ground_truth": "MCP integration enables agents to connect to external data sources, APIs, and services through standardized protocol clients, allowing agents to access real-time information and perform actions beyond their built-in capabilities. It enables scenarios like live data retrieval, system integration, and dynamic tool discovery.",
    "source": "mcp_integration"
  },
  {
    "id": "ma_033",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "What is the role of model clients in Agent Framework, and how do they abstract different LLM providers?",
    "ground_truth": "Model clients encapsulate provider-specific API details (OpenAI, Azure OpenAI, Ollama, etc.) behind a unified interface, allowing agents to work with different LLM providers through configuration changes only. This abstraction decouples agent logic from model implementation details.",
    "source": "model_clients"
  },
  {
    "id": "ma_034",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "How would you implement a custom agent in Agent Framework that extends ChatAgent with domain-specific behavior?",
    "ground_truth": "Extend ChatAgent by subclassing it and overriding key methods such as process_message() or handle_tool_result() to implement custom logic. Domain-specific behavior can include custom reasoning, state management, or specialized message formatting before passing to the underlying model client.",
    "source": "custom_agents"
  },
  {
    "id": "ma_035",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "What deployment considerations are specific to Agent Framework when targeting Azure AI Foundry?",
    "ground_truth": "When deploying to Azure AI Foundry, consider agent state persistence using managed storage, authentication via Azure credentials, model client configuration for Azure OpenAI endpoints, and workflow execution scaling through Azure's container and serverless options. Checkpointing integrates with Azure Storage for long-running agents.",
    "source": "azure_ai_foundry_deployment"
  },
  {
    "id": "ma_036",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "How does the Workflow Builder interface in Agent Framework simplify workflow creation compared to writing workflows programmatically?",
    "ground_truth": "Workflow Builder provides a visual, drag-and-drop interface for defining agent workflows, eliminating the need to write graph definition code manually. It automatically generates the underlying workflow configuration, making it accessible to non-developers and reducing development time for complex multi-agent orchestrations.",
    "source": "workflow_builder"
  },
  {
    "id": "ma_037",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "What are the key differences between using workflows as orchestrators versus using workflows as agents themselves?",
    "ground_truth": "Workflows as orchestrators coordinate multiple agents and control flow between them. Workflows as agents encapsulate a workflow as a single agent unit that can be composed into larger workflows, enabling hierarchical composition where complex workflows behave like simple agents to higher-level systems.",
    "source": "workflows_as_agents"
  },
  {
    "id": "ma_038",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "How does the Process Framework enforce determinism in business workflows, and why is this important?",
    "ground_truth": "Process Framework guarantees deterministic execution through explicit state transitions, immutable event logs, and ordered task execution without parallelism or nondeterministic agent reasoning. This is critical for business workflows requiring audit trails, compliance, and reproducible outcomes across executions.",
    "source": "process_framework_determinism"
  },
  {
    "id": "ma_039",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "When should you use Agent Framework's unified SDK instead of continuing with separate AutoGen and Semantic Kernel implementations?",
    "ground_truth": "Use Agent Framework when you need multi-agent orchestration, want to consolidate multiple frameworks into one, require advanced patterns like handoff or group chat, or plan to deploy complex workflows at scale. It's ideal when AutoGen and SK feature overlap creates maintenance burden or when orchestration patterns are unavailable in either framework alone.",
    "source": "framework_selection"
  },
  {
    "id": "ma_040",
    "domain": "microsoft_agent_framework",
    "difficulty": "medium",
    "question": "Describe a scenario where you would combine sequential and concurrent orchestration patterns in a single Agent Framework workflow.",
    "ground_truth": "In a data processing pipeline: sequentially route a request to a specialized agent for validation, then concurrently distribute validated data to multiple analysis agents in parallel, finally sequentially aggregate results through a summarization agent. This combines patterns based on dependency requirements at each workflow stage.",
    "source": "mixed_orchestration_patterns"
  },
  {
    "id": "ma_041",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "When migrating from AutoGen to Microsoft Agent Framework, what are the critical architectural differences in how agent communication patterns translate, and how does the ChatAgent abstraction handle the loss of AutoGen's built-in nested chat capability?",
    "ground_truth": "AutoGen's nested chat is replaced by Microsoft Agent Framework's graph-based Workflow APIs and handoff orchestration patterns. ChatAgent abstractions provide unified interfaces for agent definition, but handoff and group chat patterns must be explicitly implemented in workflows rather than relying on AutoGen's automatic nested chat resolution. Developers must restructure agent interaction logic into explicit workflow nodes and transition definitions.",
    "source": "AutoGen_to_MAF_migration"
  },
  {
    "id": "ma_042",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "Explain how state management with checkpointing in long-running agent workflows prevents data loss and enables resumption. What are the performance and consistency implications of different checkpoint granularity levels?",
    "ground_truth": "Checkpointing persists workflow state at defined intervals, allowing resumption from the last checkpoint upon failure. Fine-grained checkpointing (after each node) maximizes fault tolerance but increases I/O overhead and latency. Coarse-grained checkpointing reduces overhead but risks losing more progress. The choice depends on workflow SLA, failure frequency, and cost constraints. Consistency requires idempotent operations and proper state serialization.",
    "source": "state_management_checkpointing"
  },
  {
    "id": "ma_043",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "When designing a complex multi-agent workflow using concurrent orchestration with the magentic pattern, what synchronization challenges arise when agents produce interdependent outputs, and how should you structure the workflow graph to ensure causal consistency?",
    "ground_truth": "Concurrent orchestration executes independent agents in parallel but requires explicit synchronization barriers for dependent tasks. Magentic pattern allows agents to compose and orchestrate themselves dynamically. To ensure causal consistency, implement aggregation nodes that collect outputs, validate completeness before proceeding, and use dependency annotations in the workflow graph. Consider using conditional branching to handle partial failures and implement compensation logic for rollback scenarios.",
    "source": "concurrent_magentic_orchestration"
  },
  {
    "id": "ma_044",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "How does the @ai_function decorator handle type inference and schema generation for complex nested data structures when integrating with external tool APIs, and what validation mechanisms prevent type mismatches at runtime?",
    "ground_truth": "The @ai_function decorator uses Python type hints to automatically generate JSON schemas for function parameters and return types. For complex nested structures, it traverses the type hierarchy to build complete schemas. Validation occurs at serialization/deserialization boundaries through Pydantic models or similar mechanisms. Type mismatches are caught during function invocation, triggering retry logic or fallback handlers. Developers should use TypedDict or Pydantic models for clarity and explicit schema customization.",
    "source": "ai_function_decorator_typing"
  },
  {
    "id": "ma_045",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "In a Semantic Kernel to Microsoft Agent Framework migration, how do the plugin/skill abstraction models differ from the tool integration model, and what refactoring is required when plugins have stateful or async generator patterns?",
    "ground_truth": "Semantic Kernel plugins are function-based with optional state context, while MAF tools are declaratively defined via @ai_function or ToolDefinition. Plugins rely on kernel context for state sharing, whereas MAF uses explicit workflow state management. Async generators in plugins must be refactored to return complete collections or implement streaming through specific MAF APIs. Tool definitions require explicit parameter/return type declarations rather than Semantic Kernel's flexible context-based approach.",
    "source": "semantic_kernel_migration"
  },
  {
    "id": "ma_046",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "How does the MCP (Model Context Protocol) integration in Microsoft Agent Framework enable dynamic tool discovery and capability negotiation, and what security implications arise from untrusted MCP server connections?",
    "ground_truth": "MCP integration allows agents to dynamically discover available tools from MCP servers through capability negotiation protocols. This enables runtime flexibility but introduces security risks: untrusted servers could advertise malicious tools, inject harmful schemas, or eavesdrop on agent invocations. Mitigation requires server authentication, tool schema validation, allowlisting of trusted servers, and sandboxing of tool execution. Organizations should implement MCP server governance policies and audit tool usage.",
    "source": "mcp_integration_security"
  },
  {
    "id": "ma_047",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "When implementing the Agent-to-Agent (A2A) protocol for inter-agent communication, how do you prevent circular dependencies, infinite loops, and ensure eventual termination while maintaining expressiveness for complex coordination patterns?",
    "ground_truth": "A2A protocol prevents circular dependencies through directed acyclic graph (DAG) validation at workflow compile time and message tracking with unique correlation IDs. Infinite loops are prevented by setting maximum hop counts, timeout constraints, and visited node tracking. Eventual termination is ensured by requiring terminal agents (those that don't delegate further) and implementing watchdog timers. Expressiveness is maintained through conditional routing and decision agents that can decide when to delegate versus terminate.",
    "source": "a2a_protocol_termination"
  },
  {
    "id": "ma_048",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "How does the Process Framework in Microsoft Agent Framework differentiate from orchestration patterns when implementing deterministic business workflows, and what guarantees does it provide regarding order of execution and state consistency?",
    "ground_truth": "The Process Framework provides deterministic execution guarantees for business workflows through explicit sequential state machines and event sourcing, unlike orchestration patterns which emphasize coordination flexibility. It guarantees strict ordering of process steps, immutable audit trails of state changes, and repeatable execution from event logs (event sourcing). Process Framework is suited for compliance-heavy workflows (finance, healthcare), while orchestration patterns optimize for adaptability. Consistency is achieved through transactional state updates and compensation-based rollbacks.",
    "source": "process_framework_determinism"
  },
  {
    "id": "ma_049",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "When deploying a multi-agent system to Azure AI Foundry, what are the critical considerations for model client load balancing, rate limiting, cost optimization across different LLM providers, and how do you implement intelligent fallback strategies?",
    "ground_truth": "Azure AI Foundry deployment requires configuring model client routing policies with provider-specific rate limits and quota enforcement. Load balancing should prioritize cost-effective models for simple tasks and reserve expensive models for complex reasoning. Implement intelligent fallback by ranking models by cost/latency/reliability and automatically routing to secondaries on provider degradation. Strategies include round-robin distribution, latency-based routing, and cost-aware model selection. Monitor throughput and implement circuit breakers to prevent cascading failures.",
    "source": "azure_ai_foundry_deployment"
  },
  {
    "id": "ma_050",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "In a custom agent implementation extending ChatAgent, how do you handle prompt injection attacks, tool parameter validation, and output sanitization when agents invoke user-provided or untrusted tools through the framework's extensibility mechanisms?",
    "ground_truth": "Custom agents should implement defense-in-depth: sanitize user inputs before LLM processing through prompt templating, validate tool parameters against schemas with strict type checking, and use allowlists for callable tools. Output sanitization requires parsing LLM responses to extract tool invocations and validating against declared schemas before execution. Use parameterized tool invocations to prevent injection. Implement logging and anomaly detection for suspicious patterns. Consider using PromptGuard or similar safeguards at the framework integration boundary.",
    "source": "custom_agent_security"
  },
  {
    "id": "ma_051",
    "domain": "microsoft_agent_framework",
    "difficulty": "hard",
    "question": "How do you debug and optimize workflow execution performance when using graph-based Workflow APIs, particularly when workflows exhibit high latency variance due to unpredictable agent runtimes or external API dependencies?",
    "ground_truth": "Implement comprehensive observability through instrumentation of workflow nodes with timing metadata, request tracing with distributed trace IDs, and structured logging of state transitions. Use workflow visualization tools to identify critical paths and bottlenecks. Optimize by parallelizing independent paths (concurrent orchestration), caching stable outputs, implementing timeouts with fallbacks, and pre-warming model clients. Profile individual agent execution against SLA targets. Consider implementing predictive queuing or speculative execution for common code paths. Azure Application Insights or similar tools provide performance dashboards.",
    "source": "workflow_performance_debugging"
  }
]
